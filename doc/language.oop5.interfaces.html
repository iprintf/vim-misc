
对象接口

使用接口（interface），可以指定某个类必须实现哪些方法，但不需要定义这些方法的具
体内容。

接口是通过 interface 关键字来定义的，就像定义一个标准的类一样，但其中定义所有的
方法都是空的。

接口中定义的所有方法都必须是公有，这是接口的特性。

实现（implements）

要实现一个接口，使用 implements 操作符。类中必须实现接口中定义的所有方法，否则
会报一个致命错误。类可以实现多个接口，用逗号来分隔多个接口的名称。

    Note:

    实现多个接口时，接口中的方法不能有重名。

    Note:

    接口也可以继承，通过使用 extends 操作符。

    Note:

    类要实现接口，必须使用和接口中所定义的方法完全一致的方式。否则会导致致命错
    误。

常量

接口中也可以定义常量。接口常量和类常量的使用完全相同，但是不能被子类或子接口所
覆盖。

范例

Example #1 接口示例

<?php

// 声明一个'iTemplate'接口
interface iTemplate
{
    public function setVariable($name, $var);
    public function getHtml($template);
}


// 实现接口
// 下面的写法是正确的
class Template implements iTemplate
{
    private $vars = array();
  
    public function setVariable($name, $var)
    {
        $this->vars[$name] = $var;
    }
  
    public function getHtml($template)
    {
        foreach($this->vars as $name => $value) {
            $template = str_replace('{' . $name . '}', $value, $template);
        }
 
        return $template;
    }
}

// 下面的写法是错误的，会报错，因为没有实现 getHtml()：
// Fatal error: Class BadTemplate contains 1 abstract methods
// and must therefore be declared abstract (iTemplate::getHtml)
class BadTemplate implements iTemplate
{
    private $vars = array();
  
    public function setVariable($name, $var)
    {
        $this->vars[$name] = $var;
    }
}
?>

Example #2 可扩充的接口

<?php
interface a
{
    public function foo();
}

interface b extends a
{
    public function baz(Baz $baz);
}

// 正确写法
class c implements b
{
    public function foo()
    {
    }

    public function baz(Baz $baz)
    {
    }
}

// 错误写法会导致一个致命错误
class d implements b
{
    public function foo()
    {
    }

    public function baz(Foo $foo)
    {
    }
}
?>

Example #3 继承多个接口

<?php
interface a
{
    public function foo();
}

interface b
{
    public function bar();
}

interface c extends a, b
{
    public function baz();
}

class d implements c
{
    public function foo()
    {
    }

    public function bar()
    {
    }

    public function baz()
    {
    }
}
?>

Example #4 使用接口常量

<?php
interface a
{
    const b = 'Interface constant';
}

// 输出接口常量
echo a::b;

// 错误写法，因为常量不能被覆盖。接口常量的概念和类常量是一样的。
class b implements a
{
    const b = 'Class constant';
}
?>

接口加上类型约束，提供了一种很好的方式来确保某个对象包含有某些方法。参见
instanceof 操作符和类型约束。


User Contributed Notes 49 notes

===============================================================================

It seems like many contributors are missing the point of using an INTERFACE. An
INTERFACE is not specifically provided for abstraction. That's what a CLASS is
used for. Most examples in this article of interfaces could be achieved just as
easily using just classes alone.

An INTERFACE is provided so you can describe a set of functions and then hide
the final implementation of those functions in an implementing class. This
allows you to change the IMPLEMENTATION of those functions without changing how
you use it.

For example: I have a database. I want to write a class that accesses the data
in my database. I define an interface like this:

interface Database {
function listOrders();
function addOrder();
function removeOrder();
...
}

Then let's say we start out using a MySQL database. So we write a class to
access the MySQL database:

class MySqlDatabase implements Database {
function listOrders() {...
}
we write these methods as needed to get to the MySQL database tables. Then you
can write your controller to use the interface as such:

$database = new MySqlDatabase();
foreach ($database->listOrders() as $order) {

Then let's say we decide to migrate to an Oracle database. We could write
another class to get to the Oracle database as such:

class OracleDatabase implements Database {
public function listOrders() {...
}

Then - to switch our application to use the Oracle database instead of the
MySQL database we only have to change ONE LINE of code:

$database = new OracleDatabase();

all other lines of code, such as:

foreach ($database->listOrders() as $order) {

will remain unchanged. The point is - the INTERFACE describes the methods that
we need to access our database. It does NOT describe in any way HOW we achieve
that. That's what the IMPLEMENTing class does. We can IMPLEMENT this interface
as many times as we need in as many different ways as we need. We can then
switch between implementations of the interface without impact to our code
because the interface defines how we will use it regardless of how it actually
works.
===============================================================================

Just wrote some examples of duck-typing in PHP. Sharing here.

<?php

/**
* An example of duck typing in PHP
*/

interface CanFly {
  public function fly();
}

interface CanSwim {
  public function swim();
}

class Bird {
  public function info() {
    echo "I am a {$this->name}\n";
    echo "I am an bird\n";
  }
}

/**
* some implementations of birds
*/
class Dove extends Bird implements CanFly {
  var $name = "Dove";
  public function fly() {
    echo "I fly\n";
  }
}

class Penguin extends Bird implements CanSwim {
  var $name = "Penguin";
  public function swim() {
    echo "I swim\n";
  }
}

class Duck extends Bird implements CanFly, CanSwim {
  var $name = "Duck";
  public function fly() {
    echo "I fly\n";
  }
  public function swim() {
    echo "I swim\n";
  }
}

/**
* a simple function to describe a bird
*/
function describe($bird) {
  if ($bird instanceof Bird) {
    $bird->info();
    if ($bird instanceof CanFly) {
      $bird->fly();
    }
    if ($bird instanceof CanSwim) {
      $bird->swim();
    }
  } else {
    die("This is not a bird. I cannot describe it.");
  }
}

// describe these birds please
describe(new Penguin);
echo "---\n";

describe(new Dove);
echo "---\n";

describe(new Duck);
===============================================================================

If it's not already obvious, it's worth noticing that the parameters in the
interface's method declaration do not have to have the same names as those in
any of its implementations.

More significantly, default argument values may be supplied for interface
method parameters, and they have to be if you want to use default argument
values in the implemented classes:

<?php
interface isStuffable
{
    public function getStuffed($ratio=0.5);
}

class Turkey implements isStuffable
{
    public function getStuffed($stuffing=1)
    {
        // ....
    }
}
?>

Note that not only do the parameters have different names ($ratio and
$stuffing), but their default values are free to be different as well. There
doesn't seem to be any purpose to the interface's default argument value except
as a dummy placeholder to show that there is a default (a class implementing
isStuffable will not be able to implement methods with the signatures
getStuffed(), getStuffed($a), or getStuffed($a,$b)).
===============================================================================

When should you use interfaces?  What are they good for?
Here are two examples. 

1. Interfaces are an excellent way to implement reusability. 
You can create a general interface for a number of situations
(such as a save to/load from disk interface.)  You can then
implement the interface in a variety of different ways (e.g. for
formats such as tab delimited ASCII, XML and a database.) 
You can write code that asks the object to "save itself to
disk" without having to worry what that means for the object
in question.  One object might save itself to the database,
another to an XML and you can change this behavior over
time without having to rewrite the calling code. 

This allows you to write reusable calling code that can work
for any number of different objects -- you don't need to know
what kind of object it is, as long as it obeys the common
interface. 

2. Interfaces can also promote gradual evolution.  On a
recent project I had some very complicated work to do and I
didn't know how to implement it.  I could think of a "basic"
implementation but I knew I would have to change it later. 
So I created interfaces in each of these cases, and created
at least one "basic" implementation of the interface that
was "good enough for now" even though I knew it would have
to change later. 

When I came back to make the changes, I was able to create
some new implementations of these interfaces that added the
extra features I needed.  Some of my classes still used
the "basic" implementations, but others needed the
specialized ones.  I was able to add the new features to the
objects themselves without rewriting the calling code in most
cases.  It was easy to evolve my code in this way because
the changes were mostly isolated -- they didn't spread all
over the place like you might expect.
===============================================================================

Implementation must be strict, subtypes are not allowed.

"The class implementing the interface must use the EXACT SAME METHOD SIGNATURES
as are defined in the interface. Not doing so will result in a fatal error. "

<?php

interface I
{
  function foo(stdClass $arg);
}

class Test extends stdClass
{
}

class Implementation implements I
{
  function foo(Test $arg)
    {
    }
}
?>
Result:

Fatal error: Declaration of InterfaceImplementation::foo() must be compatible
with I::foo(stdClass $arg) in test.php on line XY
===============================================================================

if you want to implement an interface and in addition to use inheritance, first
it uses “extends” and then “implements” example:

<?php
class MyChildClass extends MyParentClass implements MyInterface
{
   // definition
}
?>
===============================================================================

On an incidental note, it is not necessary for the implementation of an
interface method to use the same variable names for its parameters that were
used in the interface declaration.

More significantly, your interface method declarations can include default
argument values. If you do, you must specify their implementations with default
arguments, too. Just like the parameter names, the default argument values do
not need to be the same. In fact, there doesn't seem to be any functionality to
the one in the interface declaration at all beyond the fact that it is there.

<?php
interface isStuffed {
    public function getStuff($something=17);
}

class oof implements isStuffed {
    public function getStuff($a=42) {
        return $a;
    }
}

$oof = new oof;

echo $oof->getStuff();
?>

Implementations that try to declare the method as getStuff(), getStuff($a), or
getStuff($a,$b) will all trigger a fatal error.
===============================================================================

You can also specify class constants in interfaces as well (similar to
specifying 'public static final' fields in Java interfaces):

<?php

interface FooBar
{

    const SOME_CONSTANT = 'I am an interface constant';

    public function doStuff();

}

?>

Then you can access the constant by referring to the interface name, or an
implementing class, (again similar to Java) e.g.:

<?php

class Baz implements FooBar
{

    //....

}

print Baz::SOME_CONSTANT;
print FooBar::SOME_CONSTANT;

?>

Both of the last print statements will output the same thing: the value of
FooBar::SOME_CONSTANT
===============================================================================

php at wallbash dot com's comment of "It's important to note this because it is
very unexpected behavior and renders many common Interface completly useless"
doesn't make sense.

the idea of the interface is to force objects that aren't related to be reused
in a common way. without them, to force that requirement, all objects that need
those methods implemented would have to be descended from a base class that's
known to have those methods. that's clearly not a smart idea if these objects
aren't actually related.

one example (that i'm currently working on) is a background service that pulls
information down from different content providers. i have a transport and i
have an import. for both, what actually happens in the background is different
from provider to provider, but since i'm implementing a transport & import
interface, i only need to write code once, because i know exactly the what
methods will be implemented to get the job done. then, i just have a config
file that loads the class dynamically. i don't need something like

if ( $provider == "some company" )
{
   // use this set of code
}
elseif ( $provider == "another company" )
{
   // use this other set of code
}

instead, i can do:

foreach ( $providers as $provider => $info )
{
    $_transport = $info['transportObject'];
    $transport = new $_transport();
    $_import = $info['importObject'];
    $import = new $_import();
   
    $transport->setImporter( $import );
    $transport->retrieve();
}

it is expected behavior that when a class implements two interfaces that share
one or more method names, an error is thrown, because interfaces don't relate
to each other. if you want that sort of inferred behavior (i.e. A and B are
different except for these shared methods), stick to [abstract] classes.

it sucks that interface methods might collide for some common types of tasks
(get(), set(), etc.), so knowing that, design your interfaces with more unique
method names.
===============================================================================

Interfaces can define static methods, but note that this won't make sense as
you'll be using the class name and not polymorphism.

...Unless you have PHP 5.3 which supports late static binding:

<?php

interface IDoSomething {
    public static function doSomething();
}

class One implements IDoSomething {
    public static function doSomething() {
        echo "One is doing something\n";
    }
}

class Two extends One {
    public static function doSomething() {
        echo "Two is doing something\n";
    }
}

function example(IDoSomething $doer) {
    $doer::doSomething(); // "unexpected ::" in PHP 5.2
}

example(new One()); // One is doing something
example(new Two()); // Two is doing something

?>

If you have PHP 5.2 you can still declare static methods in interfaces. While
you won't be able to call them via LSB, the "implements IDoSomething" can serve
as a hint/reminder to other developers by saying "this class has a
::doSomething() method".
Besides, you'll be upgrading to 5.3 soon, right? Right?

(Heh. I just realized: "I do something". Unintentional, I swear!)
===============================================================================

Solution for overriding interface constants
//we can override interface constants by using  abstract class
//if Test Class implements inter1 than we can not override inter1 interface
constants
example:

<?php

interface inter1 {

    const interface1 = "I am from interface 1";

    function foo1();

    function bar1();
}

interface inter2 extends inter1 {

    function foo2();

    function bar2();
}

interface inter3 {

    function foo3();

    function bar3();
}

interface inter4 {

    function foo4();

    function bar4();
}

abstract class AbsClass implements inter2 {
   
}

class Test extends AbsClass implements inter3, inter4 {

    const interface1 = "I am from test class";

    public function foo1() {
       
    }

    public function foo2() {
       
    }

    public function foo3() {
       
    }

    public function foo4() {
       
    }

    public function bar1() {
       
    }

    public function bar2() {
       
    }

    public function bar3() {
       
    }

    public function bar4() {
       
    }

    public function display() {
        echo inter1::interface1;
        echo PHP_EOL;
        echo Test::interface1;
    }

}

$Obj = new Test();
$Obj->display(); //I am from interface 1 \n I am from test class
===============================================================================

PHP prevents interface a contant to be overridden by a class/interface that
DIRECTLY inherits it.  However, further inheritance allows it.  That means that
interface constants are not final as mentioned in a previous comment.  Is this
a bug or a feature?

<?php

interface a
{
    const b = 'Interface constant';
}

// Prints: Interface constant
echo a::b;

class b implements a
{
}

// This works!!!
class c extends b
{
    const b = 'Class constant';
}

echo c::b;
?>
===============================================================================

What is not mentioned in the manual is that you can use "self" to force object
hinting on a method of the implementing class:

Consider the following interface:
<?php
interface Comparable
{function compare(self $compare);}
?>

Which is then implemented:

<?php

class String implements Comparable
{
    private $string;
    function __construct($string)
    {$this->string = $string;}
    function compare(self $compare)
    {return $this->string == $compare->string;}
}

class Integer implements Comparable
{
    private $integer;
    function __construct($int)
    {$this->integer = $int;}
    function compare(self $compare)
    {return $this->integer == $compare->integer;}
}

?>

Comparing Integer with String will result in a fatal error, as it is not an
instance of the same class:

<?php
$first_int = new Integer(3);
$second_int = new Integer(3);
$first_string = new String("foo");
$second_string = new String("bar");

var_dump($first_int->compare($second_int)); // bool(true)
var_dump($first_string->compare($second_string)); // bool(false)
var_dump($first_string->compare($second_int)); // Fatal Error
?>
===============================================================================

The class implementing the interface must use the exact same method signatures
as are defined in the interface. Not doing so will result in a fatal error. --
this documentation page.

But, if you use default values in arguments in methods, fatal error is not
follow:

<?php
interface myInterface {
    public function __construct();
}

class concret implements myInterface {

    public function __construct($arg=null)
    {
        print_r(func_get_args());
    }
}

$obj = new concret(123);
?>

Array ( [0] => 123 )
===============================================================================

The statement, that you have to implement _all_ methods of an interface has not
to be taken that seriously, at least if you declare an abstract class and want
to force the inheriting subclasses to implement the interface.
Just leave out all methods that should be implemented by the subclasses. But
never write something like this:

<?php

interface Foo {

      function bar();

}

abstract class FooBar implements Foo {

       abstract function bar(); // just for making clear, that this
                                 // method has to be implemented

}

?>

This will end up with the following error-message:

Fatal error: Can't inherit abstract function Foo::bar() (previously declared
abstract in FooBar) in path/to/file on line anylinenumber
===============================================================================

I was wondering if implementing interfaces will take into account inheritance.
That is, can inherited methods be used to follow an interface's structure?

<?php

interface Auxiliary_Platform {
    public function Weapon();
    public function Health();
    public function Shields();
}

class T805 implements Auxiliary_Platform {
    public function Weapon() {
        var_dump(__CLASS__);
    }
    public function Health() {
        var_dump(__CLASS__ . "::" . __FUNCTION__);
    }
    public function Shields() {
        var_dump(__CLASS__ . "->" . __FUNCTION__);
    }
}

class T806 extends T805 implements Auxiliary_Platform {
    public function Weapon() {
        var_dump(__CLASS__);
    }
    public function Shields() {
        var_dump(__CLASS__ . "->" . __FUNCTION__);
    }
}

$T805 = new T805();
$T805->Weapon();
$T805->Health();
$T805->Shields();

echo "<hr />";

$T806 = new T806();
$T806->Weapon();
$T806->Health();
$T806->Shields();

/* Output:
string(4) "T805"
string(12) "T805::Health"
string(13) "T805->Shields"
<hr />string(4) "T806"
string(12) "T805::Health"
string(13) "T806->Shields"
*/

?>

Class T805 implements the interface Auxiliary_Platform. T806 does the same
thing, but the method Health() is inherited from T805 (not the exact case, but
you get the idea). PHP seems to be fine with this and everything still works
fine. Do note that the rules for class inheritance doesn't change in this
scenario.

If the code were to be the same, but instead T805 (or T806) DOES NOT implement
Auxiliary_Platform, then it'll still work. Since T805 already follows the
interface, everything that inherits T805 will also be valid. I would be careful
about that. Personally, I don't consider this a bug.

This seems to work in PHP5.2.9-2, PHP5.3 and PHP5.3.1 (my current versions).

We could also do the opposite:

<?php

class T805 {
    public function Weapon() {
        var_dump(__CLASS__);
    }
}

class T806 extends T805 implements Auxiliary_Platform {
    public function Health() {
        var_dump(__CLASS__ . "::" . __FUNCTION__);
    }
    public function Shields() {
        var_dump(__CLASS__ . "->" . __FUNCTION__);
    }
}

$T805 = new T805();
$T805->Weapon();

echo "<hr />";

$T806 = new T806();
$T806->Weapon();
$T806->Health();
$T806->Shields();

/* Output:
string(4) "T805"
<hr />string(4) "T805"
string(12) "T806::Health"
string(13) "T806->Shields"
*/

?>

This works as well, but the output is different. I'd be careful with this.
===============================================================================

You can change some methods signature from interface if you pass parameters
with default values. For instance:

<?php

interface Foo {
  public function foo($foo);
}

class Bar implements Foo {
  public function foo($foo, $bar = null) {
    return $foo . $bar;
  }
}

$bar = new Bar();
// output: worksfine
echo $bar->foo('works', 'fine');
===============================================================================

By asking your colleague to implement your interface, you are asking him to
guarantee that he has implemented all the methods you need. He can implement
multiple interfaces, each being a contract, so that the guy cleaning up the
cruft down the road can see which methods belong to which area of concern; but
since interfaces are primarily contracts rather than documentation, a class
cannot implement two interfaces containing the same method since that would
make the contract lose credibility through ambiguity. Thus a class can
implement two interfaces with overlapping concerns only by factoring their
common methods into a third interface that serves as a base for the first two,
which resolves the contractual ambiguity.
===============================================================================

In response to harryjry and mehea concerning your Weather Model. The problem is
that you don't need all the things you think you need. In OOP, good class
definitions get to the point rather quickly.

<?php
class Weather{
  public $time, $temperature, $humidity;

  public function __construct($tm, $t, $h){
    $this->time = $tm;
    $this->temperature = $t;
    $this->humidity = $h;
  }

  public function __toString(){
    return "Time: $this->time,
      Temperature: $this->temperature&deg;,
      Humidity: $this->humidity%";
  }
}

$forecasts = array(
  new Weather("1:00 pm", 65, 42),
  new Weather("2:00 pm", 66, 40),
  new Weather("3:00 pm", 68, 39)
  // add more weather reports as desired...
);
echo "Forecast for Chicago, IL:<br>";
foreach($forecasts as $forecast) echo ' - ' . $forecast '<br>';
?>
Forecast for Chicago, IL:
- Time: 1:00 pm, Temperature: 65°, Humidity: 42%
- Time: 2:00 pm, Temperature: 66°, Humidity: 40%
- Time: 3:00 pm, Temperature: 68°, Humidity: 39%

Note: MySQL can store data like this already, but if you included constants,
more variables, and other functions in the Weather class, then maybe, just
maybe it could be of use.
===============================================================================

In regards to what Hayley Watson is writing:

The "interface" is a method of enforcing that anyone who implements it must
include all the functions declared in the interface. This is an abstraction
method, since you cannot just declare a base class and do something like
"public abstract function myTest();" and later on extend that class.

If you don't override the default value in a parameter list, it's assumed that
the default value was received by time you have any control to read or relay
the value on again. There should be no problem in having all or none of your
parameters in an interface having a default value, as the value is
"auto-filled" if not explicitly provided.

I just came across interfaces in PHP.. but I use them quite a bit in Java and
Delphi. Currently building different DB wrappers, but all must enforce common
access using a base class.. and also enforce that all of specific routines are
implemented.
===============================================================================

Note that you can extend interfaces with other interfaces since under-the-hood
they are just abstract classes:

<?php

interface Foo {
    public function doFoo();
}

interface Bar extends Foo {
    public function doBar();
}

class Zip implements Bar {
    public function doFoo() {
        echo "Foo";
    }
    public function doBar() {
        echo "Bar";
    }
}

$zip = new Zip();
$zip->doFoo();
$zip->doBar();

?>

This is quite useful when you're using interfaces for identity more than the
rigidity it places upon an API.  You can get the same result by implementing
multiple interfaces.

An example of where I've used this in the past is with EventListener objects
ala Java's Swing UI.  Some listeners are effectively the same thing but happen
at different times therefore we can keep the same API but change the naming for
clarity.
===============================================================================

If you want to ensure implementation classes are correctly initialised (i.e.
due to trickery one needs to do to work around lack of multiple inheritance),
simply add  __construct() to your interface, so risk of init being forgotten is
reduced.
===============================================================================

to dlovell2011 at yahoo dot com wrote:
It seems like many contributors are missing the point of using an INTERFACE. An
INTERFACE is not specifically provided for abstraction.
...
An INTERFACE is provided so you can describe a set of functions and then hide
the final implementation of those functions in an implementing class. This
allows you to change the IMPLEMENTATION of those functions without changing how
you use it.
--------------
I believe the unique thing that Interfaces provide is to support the same
functions in different classes that are **not descended from a common
ancestor**. 
Different implementations of the same functions does not need interfaces--it
can be achieved through subclasses.
===============================================================================

While a subclass may implement an interface by extending an abstract class that
implements the interface, I question whether it is good design to to do so. 
Here's what I would suggest while taking the liberty of modifying the above
weather/wet model:

<?php
interface water
{
    public function makeItWet();
}


/**
   * abstract class implements water but defines makeItWet
   * in the most general way to allow child class to
   * provide specificity
**/
abstract class weather implements water                   
{
   private $cloudy;
   public function makeItWet(){}
   abstract public function start();
   abstract public function getCloudy();
   abstract public function setCloudy();
}

class rain extends weather                            {
    private $cloudy;   
    public function start() {
        return "Here's some weather. ";
    }
   
    public function makeItWet() {
        return 'it is raining cats and dogs today.';
    }
    public function getCloudy() {
        return $this->cloudy;
    }
    public function setCloudy($bln=false) {
        $this->cloudy = $bln;
    }
}

$a = new rain();
echo $a->start();
$a->setCloudy(true);
if ($a->getCloudy()) {
    echo 'It is a cloudy day and ';
}
echo $a->makeItWet();

?>
===============================================================================

In their book on Design Patterns, Erich Gamma and his associates (AKA: "The
Gang of Four") use the term "interface" and "abstract class" interchangeably.
In working with PHP and design patterns, the interface, while clearly a
"contract" of what to include in an implementation is also a helpful guide for
both re-use and making changes. As long as the implemented changes follow the
interface (whether it is an interface or abstract class with abstract methods),
large complex programs can be safely updated without having to re-code an
entire program or module.

In PHP coding with object interfaces (as a keyword) and "interfaces" in the
more general context of use that includes both object interfaces and abstract
classes, the purpose of "loose binding" (loosely bound objects) for ease of
change and re-use is a helpful way to think about both uses of the  term
"interface." The focus shifts from "contractual" to "loose binding" for the
purpose of cooperative development and re-use.
===============================================================================

interfaces support multiple inheritance

<?php

interface SQL_Result extends SeekableIterator, Countable
{
    // new stuff
}

abstract class SQL_Result_Common
{
    // just because that's what one would do in reality, generic implementation
}

class SQL_Result_mysql extends SQL_Result_Common implements SQL_Result
{
   // actual implementation
}

?>

This code raises a fatal error because SQL_Result_mysql doesn't implement the
abstract methods of SeekableIterator (6) + Countable (1)
===============================================================================

By asking your colleague to implement your interface, you are asking him to
guarantee that he has implemented all the methods you need. He can implement
multiple interfaces, each being a contract, so that the guy cleaning the cruft
down the road can see which methods belong to which area of concern; but since
interfaces are primarily contracts rather than documentation, a class cannot
implement two interfaces containing the same method since that would make the
contract lose credibility through ambiguity. Thus a class can implement two
interfaces with overlapping concerns only by factoring their common methods
into a third interface that serves as a base for the first two, which resolves
the contractual ambiguity.
===============================================================================

If it isn't already obvious, you can create an object of a class above the
class declaration if it does NOT implement an interface. However, when a class
DOES implement an interface, PHP will throw a "class not found" error unless
the instantiation declaration is _below_ the class definition.

<?php
$bar = new foo(); // Valid

class foo
{
   
}
?>

<?php
$bar = new foo(); // Invalid - throws fatal error

interface foo2
{

}

class bar implements foo2
{
   
}

$bar = new foo(); // Valid, since it is below the class declaration

?>

Also, @Jeffrey -- Lol? What? Is that a joke? PHP interfaces have nothing to do
with connecting to "peripheral devices" or "cameras", etc. Not even in the
least sense. This is a very common miscommunication with the word "interface",
as interfaces in programming are not at all like interfaces in electronics or
drivers, etc.
===============================================================================

If you use namespaces and autoloading, do not forget to mention the use
statement for each class used in yours arguments, before your class:

<?php
#file : fruit/squeezable.php
namespace fruit
use Bar\Foo;

interface squeezable {
  public function squeeze (Foo $foo);
}
?>

<?php
#file: orange

namespace fruit\citrus;

class orange {
  public function squeeze(Foo $foo);
}
#Will throw an exception Fatal error: Declaration of "fruit\citrus\
orange::squeeze must be compatible with that of fruit\squeezable() in fruit/
squeezable.php
?>

<?php
#file: orange

namespace fruit\citrus;
use Bar\Foo; #DO NOT FORGET THIS!

class orange {
  public function squeeze (Foo $foo);
}
#Will be correct
?>
===============================================================================

In case you would want to, a child class can implement an interface:

<?php

interface water
{
    public function makeItWet();
}

class weather
{
    public function start()
    {
        return 'Here is some weather';
    }
}

class rain extends weather implements water
{
    public function makeItWet()
    {
        return 'It is wet';
    }
}

$a = new rain();
echo $a->start();
echo $a->makeItWet();

?>
===============================================================================

php inheritance interfaces on function/methods type declarations:

<?php
interface iInvokable {
        function __invoke($arg = null);
    }

    interface iResponder extends iInvokable {
        /** Bind next responder */
        function then(iInvokable $responder);
    }

    class Responder implements \iResponder {

        function __invoke($arg = null)
        {
            // TODO: Implement __invoke() method.
        }

        /** Bind next responder */
        function then(iInvokable $responder)
        {
            // TODO: Implement then() method.
        }
    }

    class OtherResponder implements \iResponder {

        function __invoke($arg = null)
        {
            // TODO: Implement __invoke() method.
        }

        /** Bind next responder */
        function then(iInvokable $responder)
        {
            // TODO: Implement then() method.
        }
    }

    class Invokable implements \iInvokable {

        function __invoke($arg = null)
        {
            // TODO: Implement __invoke() method.
        }
    }

    $responder = new Responder();
    $responder->then(new OtherResponder());
    $responder->then(new Invokable());
?>
===============================================================================

<?php
    interface ClassThatCanBuild
    { }

    interface SpecificClass extends \ClassThatCanBuild
    { }

    Class MySpecificClass implements \SpecificClass
    { }

    interface BuilderInterface
    {
        function build(\ClassThatCanBuild $container);

        function weCanHaveMethods();
    }

    interface SpecificBuilderInterface extends \BuilderInterface
    {
        /**
         * (!!) this class want to allow just for build
         *      specific classes.
         *      i`m still on the rule with MySpecificClass
         *      because extend from ClassThatCanBuild
         *      but php don`t allow it at all
         *
         *      "" declaration of must be compatible with
         *         interface of BuilderInterface->build ""
         *
         * @param \MySpecificClass $container
         */
        function build(\MySpecificClass $container);
    }
?>
===============================================================================

I think interfaces ONLY help us to understand what should we do, when working
on a big project not any more!
===============================================================================

simple example :)

<?php
interface testThis
{
public function alpha();
public function beta();
}

trait setInterface
{
public  function alpha()
{
echo __function__." wurde implementiert";
}
}

class b
{
public function beta()
{
echo __function__." wurde implementiert";
}
}

class a extends b implements testThis
{

use setInterface;

/*
public  function alpha()
{
echo __function__." wurde implementiert";
}

public function beta()
{
echo __function__." wurde implementiert";
}
*/

public function __construct()
{
echo "wat geht? <br>";   
}   

}

$testInterface = new a();
$testInterface ->alpha();
echo "<br>";
$testInterface ->beta();
?>
===============================================================================

This may help understand EX.2. Below are modifiers and additions to
the code. Refer to EX.2 to make a complete code block(this saves comment
space!).
I found the function definition baz(Baz $baz) baffling. Lucky was
able to sus it out fast. Seems method baz requires just one arg and
that must be an instance of the class Baz. Here is a way to know how to
deal with that sort of arg...
<?php
# modify iface b...adding $num to get better understanding
interface b extends a
{
    public function baz(Baz $baz,$num);
}
# mod claas c
class c implements b
{
    public function foo()
    {
        echo'foo from class c';
    }
    public function baz(Baz $baz,$num)
    {
        var_dump ($baz);# object(Baz)#2 (1) { ["bb"]=>  string(3) "hot" }
        echo '<br>';
        echo $baz->bb." $num";echo '<br>';# hot 6
    }
}
# add a class Baz...
class Baz
{
    public $bb='hot';
    function ebaz(){   
        echo'this is BAZ';
    }
}
# set instance of Baz and get some output...
$bazI=new Baz;
baz::ebaz();echo '<br>';# this is BAZ
c::baz($bazI,6);
?>
===============================================================================

FYI, interfaces can define constructors, destructors, and magic methods. This
can be very helpful especially in the case of constructors when instantiating
an implementing class via reflection in some sort of factory. Of course, it is
not recommended to do such a thing since it goes against the nature of a true
interface.
===============================================================================

The structure I am working with has a lot of inheritance going on, but not all
methods are specified in one place. I needed a way to make sure an interface
would be used, but that the method(s) defined in the interface are defined
somewhere.

As such, I learned that the parent can define the interface's methods, and then
the children can override that method at will without having to worry about the
interface.

To expand on nrg1981's example, the following is possible:

<?php
interface water
{
    public function makeItWet();
}

class weather
{
    public function makeItWet()
    {
        return 'it may or may not be wet';
    }
   
    public function start()
    {
        return 'Here is some weather';
    }
}

class rain extends weather implements water
{
    public function makeItWet()
    {
        return 'It is wet';
    }
}

class thunder extends weather implements water
{

}

$a = new rain();
echo $a->start() . "\n";
echo $a->makeItWet() . "\n";

$a = new thunder();
echo $a->start() . "\n";
echo $a->makeItWet() . "\n";

?>
===============================================================================

Regarding my previous note (04-Jul-2007 9:01):

I noticed a minor but critical mistake in my explanation. After the link to the
PHP manual page on class abstraction, I stated:

"So by definition, you may only overload non-abstract methods."

This is incorrect. This should read:

"So by definition, you may only override non-abstract methods."

Sorry for any confusion.
===============================================================================

prometheus at php-sparcle:

Your code fails because you're effectively trying to do this:

<?php
    abstract class IFoo
    {
        abstract public function Foo();
    }
   
    abstract class IBar extends IFoo
    {
        // Fails; abstract method IFoo::Foo() must be defined in child and must
match parent's definition
        abstract public function Foo($bar);
    }
?>

By definition, all methods in an interface are abstract. So the above code
segment is equivalent to your interface definitions and results in the same
error. Why? Let's have a look at the PHP manual. From the second paragraph on
class abstraction:

"When inheriting from an abstract class, all methods marked abstract in the
parent's class declaration must be defined by the child;"

http://www.php.net/manual/en/language.oop5.abstract.php

So by definition, you may only overload non-abstract methods.

For example:

<?php
    abstract class IFoo
    {
        public function Foo()
        {
            // do something...
        }
    }
   
    abstract class IBar extends IFoo
    {     
        public function Foo($bar)
        {
            // do something else...
        }
    }
?>

This can't be directly replicated with interfaces since you can't implement
methods inside of an interface. They can only be implemented in a class or an
abstract class.

If you must use interfaces, the following accomplishes the same thing, but with
two separate method names:

<?php
    interface IFoo
    {
        public function Foo();
    }
   
    interface IBar extends IFoo
    {
        public function Bar($bar);
    }
   
    class FooBar implements IBar
    {
        public function Foo()
        {
            // do something...
        }
       
        public function Bar($bar)
        {
            // do something else...
        }
    }
?>

If both methods need the same name, then you'll have to use non-abstract
methods. In this case, interfaces aren't the right tool for the job. You'll
want to use abstract classes (or just regular classes).
===============================================================================

Consider the following:
[vbolshov@localhost tmp]$ cat t.php
<?php

error_reporting(E_ALL | E_STRICT);

interface i {
        function f($arg);
}
class c implements i {
        function f($arg, $arg2 = null)
        {
        }
}
?>
[vbolshov@localhost tmp]$ php t.php
[vbolshov@localhost tmp]$

PHP doesn't generate a Fatal Error in this case, although the method
declaration in the class differs from that in the interface. This situation
doesn't seem good to me: I'd prefer classes being strictly bound to their
interfaces.
===============================================================================

To two notes below: There is one situation where classes and interfaces can be
used interchangeably. In function definitions you can define parameter types to
be classes or interfaces. If this was not so then there would not be much use
for interfaces at all.
===============================================================================

on the post below:

An interface is in fact the same like an abstract class containing abstract
methods, that's why interfaces share the same namespace as classes and why
therefore "real" classes cannot have the same name as interfaces.
===============================================================================

Interfaces and Type Hinting can be used but not with Inherintance in the same
time :

<?

class AbstractClass
{
    public function __ToString ( ) { return 'Here I\'m I'; }
}

class DescendantClass extends AbstractClass
{

}

interface MyI
{
    public function Hello ( AbstractClass $obj );
}

class MyClassOne implements MyI
{
    public function Hello ( AbstractClass $obj )
    {
        echo $obj;
    }
} // Will work as Interface Satisfied

class MyClassTwo implements MyI
{
    public function Hello ( DescendantClass $obj )
    {
        echo $obj;
    }
} // Will output a fatal error because Interfaces don't support Inherintance in
TypeHinting

//Fatal error: Declaration of MyClassTwo::hello() must be compatible with that
of MyI::hello()

?>

Something a little bit bad in PHP 5.0.4 :)
===============================================================================

Classes and interface names share a common name space, so you can't have a
class and an interface with the same name, even though the two can never be
used ambiguously (i.e. there are no circumstances in which a class and an
interface can be used interchangeably). e.g. this will not work:

interface foo {
public function bling();
}

class foo implements foo {
public function bling() {
}
}

You will get a 'Cannot redeclare class' error, even though it's only been
declared as a class once.
===============================================================================

WHOA! KEEP IT SIMPLE...

With the code below, you already get a feel at how much ground this app might
cover.

<?php

interface ElectricalDevice{
  public function power_on();
  public function power_off();
}

interface FrequencyTuner{
  public function get_frequencey();
  public function set_frequency($f);
}

class ElectricFan implements ElectricalDevice{
  // define ElectricalDevice...
}

class MicrowaveOven implements ElectricalDevice{
  // define ElectricalDevice...
}

class StereoReceiver implements ElectricalDevice, FrequencyTuner{
  // define ElectricalDevice...
  // define FrequencyTuner...
}

class CellPhone implements ElectricalDevice, FrequencyTuner{
  // define ElectricalDevice...
  // define FrequencyTuner...
}

?>

Even those who lack imagination can fill in the blanks from here.
===============================================================================

Makes them useles a bit. I give an example:
I have a class that enumerate (so implements iterator) a interface that has
method key() that returns key for the enumerated object.
I cannot implement iterator, that enumerates the objects by itself (so current
() returns this), because of collision of method key(). But it's not collision
- the key in the iterator and the key in the enumerated object has the same
meaning and allways returns same values.
(Common example of this iterator is iterator, that reads from database - make a
special object for each row is waste of time).

Yes - there are workarounds - e.g. rewrite the code so current don't return
this - but it's in some cases waste of processor time.
Or I can rename the method key in enumerated object - but why should I wrote
the same method twice? It's either waste of time (if the function key is simply
duplicated) or waste of time (if the renamed key calls original key).
Well, the right, clear way there would be to redefine interface iterator --
move the method key to the ancestor of iterator, and makes the ancestor
ancestor of enumerated interface too. But it's (with built-in interfaces)
impossible too.
===============================================================================

Another note about default values in interfaces is that an class must implement
at least the arguments as in the interface. that is: an implementation may have
more arguments but not less if these additional arguments have an default value
and thus can be called as declared in the interface.

an litte example:
<?php
interface myInterface{
  public function setStuff($id, $name);
}

class MyFirstClass implements myInterface{
  public function setStuff($id, $name);
}

class MySecondClass implements myInterface{
public function setStuff($id, $name, $type);
}

class myThirdClass implements myInterface{
public function setStuff($id, $name, $type=0);
}
?>

Here mySecondClass will print an fatal error while myThirdClass is just fine
because myThirdClass::setStuff($id, $name); is valid and thus fullfills the
interface requirements. an interface declares as set of requirement on how
methods can be called and any class implementing an interface thus agrees that
is will provide these methods and that they can be called as in the interface.
adding additional arguments with default values is thus allowed because it does
not violate the agreement that the method can be called as in the interface.
===============================================================================

Regarding the example by cyrille.berliat:

This is not a problem and is consistent with other languages.  You'd just want
to use inheritance like so:

<?php

class AbstractClass {
   public function __ToString ( ) { return 'Here I am'; }
}

class DescendantClass extends AbstractClass {}

interface MyInterface {
   public function Hello ( AbstractClass $obj );
}

class MyClassOne implements MyInterface {

   public function Hello ( AbstractClass $obj ) {
       echo $obj;
   }
} // Will work as Interface Satisfied

$myDC = new DescendantClass() ;
MyClassOne::Hello( $myDC ) ;

?>
===============================================================================

Despite my expectations, it seems PHP does not support variables of type
interface!? (using PHP 5.5)
<?php
interface InterfaceText {
  public function setText($text);
}
class Sticker implements InterfaceText {
  public function setText($text);
}

// While this is possible:
$Cool = new Sticker ();

// You can not make interface variables.
$IntfCool = new InterfaceText($Cool);
// ^ Fatal error: Cannot instantiate interface InterfaceText()

// or cast them directly:
$IntfCool = InterfaceText($Cool);
// ^ Fatal error: Call to undefined function InterfaceText()
?>
Being used to what other languages allow Interfaces, it seems PHP has no
runtime support, i now see it a static class that generates parse-warnings to
force implementation.
