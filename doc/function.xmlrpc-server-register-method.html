
xmlrpc_server_register_method

(PHP 4 >= 4.1.0, PHP 5, PHP 7)

xmlrpc_server_register_method — 注册一个 PHP 函数用于匹配 xmlrpc 方法名

说明

bool xmlrpc_server_register_method ( resource $server , string $method_name , 
string $function )
Warning

此函数是实验性的。此函数的表象，包括名称及其相关文档都可能在未来的 PHP 发布版本
中未通知就被修改。使用本函数风险自担。

Warning

本函数还未编写文档，仅有参数列表。


User Contributed Notes 6 notes

===============================================================================

Here is an example how to register a class methode:

xml_rpc_server_register_methode($xmlrpc_server, "foo", array(&$bar,
"foo_func"));

where $bar is the instance of your class and foo_func a methode of this class.
Don't forget the '&'!

hope this may be useful...

Chrigu
===============================================================================

prototype of registered function:

function method_impl(string $method_name, array $params, array $user_data);

$method_name
    the public method name, known by calling client
$params
    parameters specified by calling client
$user_data
    any local data, passed by `xmlrpc_server_call_method'
===============================================================================

Remember that you can't do like Chrigu and Nate said if you want to add methods
from a static class (Hence you can't create any instances of it).
A workaround is to create lambda functions calling the
methods:

// Our static handler class
static class MyHandler
{
    public function getPrice($item)
    {
        $prices = array("apple" => 4, "orange" => 5);
        return $prices[$item];
    }
    public function buy($item, $number)
    {
        $price = self::getPrice($item) * $number;
        do_thing_to_sell_the_item();
        return $price;
    }
}

// Use reflection to get method names and parameters
$mirror = new ReflectionClass("MyHandler");
foreach ($mirror->getMethods() as $method)
{
    // Create new "lambda" function for each method
   
    // Generate argument list
    $args = array();
    foreach ($method->getParameters() as $param)
    {
        $args[] = '$'.$param->getName();
    }
    $args = implode(',', $args);
   
    // Generate code
    $methodname = $method->getName();
    $code = "return {$real_class}::{$methodname}({$args});";
   
    // Create function, retrieve function name
    $function_name = create_function($args, $code);

    // Register the function
    xmlrpc_server_register_method($myserver, $methodname, $function_name);
}
===============================================================================

To have an xmlrpc fault response programatically generated by the server, the
php function registered as method handler must return an array containing a
FaultCode and a FaultString members.

function $myfunc($methodname, $vals, $extra_data)
{
...
return array('faultCode' => 666, 'faultString' => 'DOH!');
}
===============================================================================

To register a callback to a 'static' function within the same class, consider a
syntax like the following:
<code>
$callback = array (__CLASS__, "my_function_name");
xmlrpc_server_register_method($xmlrpc_server, "my_function", $callback);
</code>
Doing it this way makes it easier to rename your class later.
===============================================================================

In case its not completely obvious what Chrigu meant,

You can register a method inside your class by doing the following:

xml_rpc_server_register_methode($xmlrpc_server, "myClientCall", array(&$this,
"handleClientCallFunc"));

where $this == the magic class $this. =)
