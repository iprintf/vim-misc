
DOMDocument::loadHTML

(PHP 5, PHP 7)

DOMDocument::loadHTML — Load HTML from a string

说明

public bool DOMDocument::loadHTML ( string $source [, int $options = 0 ] )

The function parses the HTML contained in the string source. Unlike loading
XML, HTML does not have to be well-formed to load. This function may also be
called statically to load and create a DOMDocument object. The static
invocation may be used when no DOMDocument properties need to be set prior to
loading.

参数

source

    The HTML string.

options

    Since PHP 5.4.0 and Libxml 2.6.0, you may also use the options parameter to
    specify additional Libxml parameters.

返回值

成功时返回 TRUE，或者在失败时返回 FALSE。 If called statically, returns a
DOMDocument 或者在失败时返回 FALSE.

错误／异常

If an empty string is passed as the source, a warning will be generated. This
warning is not generated by libxml and cannot be handled using libxml's error
handling functions.

此方法可以被静态调用,但会抛出一个 E_STRICT 错误。

尽管非正确格式化的 HTML 仍应该被成功调入，但此函数会在遇到错误标记时产生
E_WARNING 错误。libxml 错误处理函数可以用来处理这类错误。

范例

Example #1 Creating a Document

<?php
$doc = new DOMDocument();
$doc->loadHTML("<html><body>Test<br></body></html>");
echo $doc->saveHTML();
?>

更新日志

版本            说明
5.4.0 Added options parameter.

参见

  • DOMDocument::loadHTMLFile() - Load HTML from a file
  • DOMDocument::saveHTML() - Dumps the internal document into a string using
    HTML formatting
  • DOMDocument::saveHTMLFile() - Dumps the internal document into a file using
    HTML formatting


User Contributed Notes 13 notes

===============================================================================

You can also load HTML as UTF-8 using this simple hack:

<?php

$doc = new DOMDocument();
$doc->loadHTML('<?xml encoding="UTF-8">' . $html);

// dirty fix
foreach ($doc->childNodes as $item)
    if ($item->nodeType == XML_PI_NODE)
        $doc->removeChild($item); // remove hack
$doc->encoding = 'UTF-8'; // insert proper

?>
===============================================================================

DOMDocument is very good at dealing with imperfect markup, but it throws
warnings all over the place when it does.

This isn't well documented here. The solution to this is to implement a
separate aparatus for dealing with just these errors.

Set libxml_use_internal_errors(true) before calling loadHTML. This will prevent
errors from bubbling up to your default error handler. And you can then get at
them (if you desire) using other libxml error functions.

You can find more info here http://www.php.net/manual/en/ref.libxml.php
===============================================================================

Pay attention when loading html that has a different charset than iso-8859-1.
Since this method does not actively try to figure out what the html you are
trying to load is encoded in (like most browsers do), you have to specify it in
the html head. If, for instance, your html is in utf-8, make sure you have a
meta tag in the html's head section:

<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
</head>

If you do not specify the charset like this, all high-ascii bytes will be
html-encoded. It is not enough to set the dom document you are loading the html
in to UTF-8.
===============================================================================

It should be noted that when any text is provided within the body tag
outside of a containing element, the DOMDocument will encapsulate that
text into a paragraph tag (<p>).

For example:
<?php
$doc = new DOMDocument();
$doc->loadHTML("<html><body>Test<br><div>Text</div></body></html>");
echo $doc->saveHTML();
?>

will yield:
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
"http://www.w3.org/TR/REC-html40/loose.dtd">
<html><body>
<p>Test<br></p>
<div>Text</div>
</body></html>

while:
<?php
$doc = new DOMDocument();
$doc->loadHTML(
    "<html><body><i>Test</i><br><div>Text</div></body></html>");
echo $doc->saveHTML();
?>

will yield:
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
"http://www.w3.org/TR/REC-html40/loose.dtd">
<html><body>
<i>Test</i><br><div>Text</div>
</body></html>
===============================================================================

When using loadHTML() to process UTF-8 pages, you may meet the problem that the
output of dom functions are not like the input. For example, if you want to get
"Cạnh tranh", you will receive "Cáº¡nh tranh".  I suggest we use
mb_convert_encoding before load UTF-8 page :
<?php
    $pageDom = new DomDocument();   
    $searchPage = mb_convert_encoding($htmlUTF8Page, 'HTML-ENTITIES', "UTF-8");
    @$pageDom->loadHTML($searchPage);

?>
===============================================================================

Be aware that this function doesn't actually understand HTML -- it fixes
tag-soup input using the general rules of SGML, so it creates well-formed
markup, but has no idea which element contexts are allowed.

For example, with input like this where the first element isn't closed:

    <span>hello <div>world</div>

loadHTML will change it to this, which is well-formed but invalid:

    <span>hello <div>world</div></span>
===============================================================================

Note that the elements of such document will have no namespace even with <html
xmlns="http://www.w3.org/1999/xhtml">
===============================================================================

Using loadHTML() automagically sets the doctype property of your DOMDocument
instance(to the doctype in the html, or defaults to 4.0 Transitional). If you
set the doctype with DOMImplementation it will be overridden.

I assumed it was possible to set it and then load html with the doctype I
defined(in order to decide the doctype at runtime), and ran into a huge
headache trying to find out where my doctype was going. Hopefully this helps
someone else.
===============================================================================

Here is a function I wrote to capitalize the previous remarks about charset
problems (UTF-8...) when using loadHTML and then DOM functions.
It adds the charset meta tag just after <head> to improve automatic encoding
detection, converts any specific character to an html entity, thus PHP DOM
functions/attributes will return correct values.

<?php
mb_detect_order("ASCII,UTF-8,ISO-8859-1,windows-1252,iso-8859-15");
function loadNprepare($url,$encod='') {
        $content        = file_get_contents($url);
        if (!empty($content)) {
                if (empty($encod))
                        $encod  = mb_detect_encoding($content);
                $headpos        = mb_strpos($content,'<head>');
                if (FALSE=== $headpos)
                        $headpos= mb_strpos($content,'<HEAD>');
                if (FALSE!== $headpos) {
                        $headpos+=6;
                        $content = mb_substr($content,0,$headpos) . '<meta
http-equiv="Content-Type" content="text/html; charset='.$encod.'">' .mb_substr(
$content,$headpos);
                }
                $content=mb_convert_encoding($content, 'HTML-ENTITIES', $encod
);
        }
        $dom = new DomDocument;
        $res = $dom->loadHTML($content);
        if (!$res) return FALSE;
        return $dom;
}
?>

NB: it uses mb_strpos/mb_substr instead of mb_ereg_replace because that seemed
more efficient with huge html pages.
===============================================================================

If you use loadHTML() to process utf HTML string (eg in Vietnamese), you may
experience result in garbage text, while some files were OK. Even your HTML
already have meta charset  like

  <meta http-equiv="content-type" content="text/html; charset=utf-8">

I have discovered that, to help loadHTML() process utf file correctly, the meta
tag should come first, before any utf string appear. For example, this HTML
file

<html>
<head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <title> Vietnamese - Tiếng Việt</title>
  </head>
<body></body>
</html>

will be OK with loadHTML() when <meta> tag appear <title> tag.

But the file below will not regcornize by loadHTML() because <title> tag
contains utf string appear before <meta> tag.

<html>
<head>
    <title> Vietnamese - Tiếng Việt</title>
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
  </head>
<body></body>
</html>
===============================================================================

Remember: If you use an HTML5 doctype and a meta element like so

<meta charset=utf-8">

your HTML code will get interpreted as ISO-8859-something and non-ASCII chars
will get converted into HTML entities. However the HTML4-like version will work
(as has been pointed out 10 years ago by "bigtree at 29a"):

<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
===============================================================================

Warning:  This does not function well with HTML5 elements such as SVG.  Most of
the advice on the Web is to turn off errors in order to have it work with
HTML5.
===============================================================================

Beware of the "gotcha" (works as designed but not as expected): if you use
loadHTML, you cannot validate the document. Validation is only for XML. Details
here: http://bugs.php.net/bug.php?id=43771&edit=1
