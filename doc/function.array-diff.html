
array_diff

(PHP 4 >= 4.0.1, PHP 5, PHP 7)

array_diff — 计算数组的差集

说明

array array_diff ( array $array1 , array $array2 [, array $... ] )

对比返回在 array1 中但是不在 array2 及任何其它参数数组中的值。

参数

array1

    要被对比的数组

array2

    和这个数组进行比较

...

    更多相比较的数组

返回值

返回一个数组，该数组包括了所有在 array1 中但是不在任何其它参数数组中的值。注意
键名保留不变。

范例

Example #1 array_diff() 例子

<?php
$array1 = array("a" => "green", "red", "blue", "red");
$array2 = array("b" => "green", "yellow", "red");
$result = array_diff($array1, $array2);

print_r($result);
?>

在 $array1 中多次出现的值一样处理，输出结果为：

Array
(
    [1] => blue
)

注释

    Note:

    两个单元仅在 (string) $elem1 === (string) $elem2 时被认为是相同的。也就是说
    ，当字符串的表达是一样的时候。

    Note:

    注意本函数只检查了多维数组中的一维。当然可以用 array_diff($array1[0],
    $array2[0]); 检查更深的维度。

参见

  • array_diff_assoc() - 带索引检查计算数组的差集
  • array_intersect() - 计算数组的交集
  • array_intersect_assoc() - 带索引检查计算数组的交集


User Contributed Notes 51 notes

===============================================================================

Again, the function's description is misleading right now. I sought a function,
which (mathematically) computes A - B, or, written differently, A \ B. Or,
again in other words, suppose

A := {a1, ..., an} and B:= {a1, b1, ... , bm}

=> array_diff(A,B) = {a2, ..., an}

array_diff(A,B) returns all elements from A, which are not elements of B (= A
without B).

You should include this in the documentation more precisely, I think.
===============================================================================

The difference is made only on the first level. If you want compare 2 arrays,
you can use the code available at https://gist.github.com/wrey75/
c631f6fe9c975354aec7 (including a class with an function to patch the array)

Here the basic function:

function my_array_diff($arr1, $arr2) {
        $diff = array();
       
        // Check the similarities
        foreach( $arr1 as $k1=>$v1 ){
            if( isset( $arr2[$k1]) ){
                $v2 = $arr2[$k1];
                if( is_array($v1) && is_array($v2) ){
                    // 2 arrays: just go further...
                    // .. and explain it's an update!
                    $changes = self::diff($v1, $v2);
                    if( count($changes) > 0 ){
                        // If we have no change, simply ignore
                        $diff[$k1] = array('upd' => $changes);
                    }
                    unset($arr2[$k1]); // don't forget
                }
                else if( $v2 === $v1 ){
                    // unset the value on the second array
                    // for the "surplus"
                    unset( $arr2[$k1] );
                }
                else {
                    // Don't mind if arrays or not.
                    $diff[$k1] = array( 'old' => $v1, 'new'=>$v2 );
                    unset( $arr2[$k1] );
                }
            }
            else {
                // remove information
                $diff[$k1] = array( 'old' => $v1 );
            }
        }
       
        // Now, check for new stuff in $arr2
        reset( $arr2 ); // Don't argue it's unnecessary (even I believe you)
        foreach( $arr2 as $k=>$v ){
            // OK, it is quite stupid my friend
            $diff[$k] = array( 'new' => $v );
        }
        return $diff;
    }
===============================================================================

Sorry for the bug in my last comment (probably rightfully removed by the
admins).
If you want to compare more than 2 arrays, or don't know how many arrays need
to be compared, this is your function:

<?php
# An extention to array_diff:
# It returns an array of all values not present in all arrays given. If
'$strict' is true,
# it returns all values not present or not in the same order in all arrays
given. The
# arrays to compare must be placed in another array, which is used as argument
'$arrays'.
# Returns false if the '$arrays' is invalid.
function array_rdiff ($arrays, $strict = false) {
    # check if argument is valid.
    if (!is_array ($arrays))
        return false;
    foreach ($arrays as $array)
        if (!is_array ($array))
            return false;

    # set working variables
    $diff    = array ();
    $amount  = count ($arrays);
    $needles = array_shift ($arrays);

    # compare
    for ($n = 0; $n < $amount; $n++) {
        for ($m = 0; $needles[$m]; $m++) {
            $found     = true;
            $positions = array ($m);
            foreach ($arrays as $haystack) {
                if (($pos = array_search ($needles[$m], $haystack)) === false)
                    $found = false;
                if ($strict)
                    $positions[] = $pos;
            }
            if (!$found)
                $diff[] = $needle;
            elseif ($strict && (count (array_unique ($positions)) > 1))
                $diff[] = $needle;
        }
        $arrays[] = $needles;
        $needles  = array_shift ($arrays);
    }
    return array_unique ($diff);
}
?>
===============================================================================

I always wanted something like this to avoid listing all the files and folders
you want to exclude in a project directory.

function array_preg_diff($a, $p) {
    foreach ($a as $i => $v)
        if (preg_match($p, $v))
            unset($a[$i]);
    return $a;
}

$relevantFiles = array_preg_diff(scandir('somedir'), '/^\./');

instead of

$relevantFiles = array_diff(scandir('somedir'), array('.', '..', '.idea',
'.project));
===============================================================================

I just came upon a really good use for array_diff(). When reading a dir
(opendir;readdir), I _rarely_ want "." or ".." to be in the array of files I'm
creating. Here's a simple way to remove them:

<?php
$someFiles = array();
$dp = opendir("/some/dir");
while($someFiles[] = readdir($dp));
closedir($dp);

$removeDirs = array(".","..");
$someFiles = array_diff($someFiles, $removeDirs);

foreach($someFiles AS $thisFile) echo $thisFile."\n";
?>

S
===============================================================================

If you just need to know if two arrays' values are exactly the same (regardless
of keys and order), then instead of using array_diff, this is a simple method:

<?php

function identical_values( $arrayA , $arrayB ) {

    sort( $arrayA );
    sort( $arrayB );

    return $arrayA == $arrayB;
}

// Examples:

$array1 = array( "red" , "green" , "blue" );
$array2 = array( "green" , "red" , "blue" );
$array3 = array( "red" , "green" , "blue" , "yellow" );
$array4 = array( "red" , "yellow" , "blue" );
$array5 = array( "x" => "red" , "y" =>  "green" , "z" => "blue" );

identical_values( $array1 , $array2 );  // true
identical_values( $array1 , $array3 );  // false
identical_values( $array1 , $array4 );  // false
identical_values( $array1 , $array5 );  // true

?>

The function returns true only if the two arrays contain the same number of
values and each value in one array has an exact duplicate in the other array.
Everything else will return false.

my alternative method for evaluating if two arrays contain (all) identical
values:

<?php

sort($a); $sort(b); return $a == $b;

?>

may be slightly faster (10-20%) than this array_diff method:

<?php

return ( count( $a ) == count( $b ) && !array_diff( $a , $b ) ? true : false );

?>

but only when the two arrays contain the same number of values and then only in
some cases. Otherwise the latter method will be radically faster due to the use
of a count() test before the array_diff().

Also, if the two arrays contain a different number of values, then which method
is faster will depend on whether both arrays need to be sorted or not. Two
times sort() is a bit slower than one time array_diff(), but if one of the
arrays have already been sorted, then you only have to sort the other array and
this will be almost twice as fast as array_diff().

Basically: 2 x sort() is slower than 1 x array_diff() is slower than 1 x sort
().
===============================================================================

If the element number returned is 0, this function NOT return a valid array,
return NULL.
===============================================================================

array_diff provides a handy way of deleting array elements by their value,
without having to unset it by key, through a lengthy foreach loop and then
having to rekey the array.

<?php

//pass value you wish to delete and the array to delete from
function array_delete( $value, $array)
{
    $array = array_diff( $array, array($value) );
    return $array;
}
?>
===============================================================================

just comment ... i don't know whether the following implementation of
array_diff is having a much better meaning to the function name.

function ary_diff( $ary_1, $ary_2 ) {
  // compare the value of 2 array
  // get differences that in ary_1 but not in ary_2
  // get difference that in ary_2 but not in ary_1
  // return the unique difference between value of 2 array
  $diff = array();

  // get differences that in ary_1 but not in ary_2
  foreach ( $ary_1 as $v1 ) {
    $flag = 0;
    foreach ( $ary_2 as $v2 ) {
      $flag |= ( $v1 == $v2 );
      if ( $flag ) break;
    }
    if ( !$flag ) array_push( $diff, $v1 );
  }

  // get difference that in ary_2 but not in ary_1
  foreach ( $ary_2 as $v2 ) {
    $flag = 0;
    foreach ( $ary_1 as $v1 ) {
      $flag |= ( $v1 == $v2 );
      if ( $flag ) break;
    }
    if ( !$flag && !in_array( $v2, $diff ) ) array_push( $diff, $v2 );
  }

  return $diff;
}

i think array_diff should return the difference between the array independent
of the order of passing the parameter.
===============================================================================

Here's a little wrapper for array_diff - I found myself needing to iterate
through the edited array, and I didn't need to original keys for anything.

<?php
function arrayDiff($array1, $array2){
    # This wrapper for array_diff rekeys the array returned
    $valid_array = array_diff($array1,$array2);
   
    # reinstantiate $array1 variable
    $array1 = array();
   
    # loop through the validated array and move elements to $array1
    # this is necessary because the array_diff function returns arrays that
retain their original keys
    foreach ($valid_array as $valid){
        $array1[] = $valid;
        }
    return $array1;
    }
?>
===============================================================================

<?php
function array_key_diff($ar1, $ar2) {  // , $ar3, $ar4, ...
    // returns copy of array $ar1 with those entries removed
    // whose keys appear as keys in any of the other function args
    $aSubtrahends = array_slice(func_get_args(),1);
    foreach ($ar1 as $key => $val)
        foreach ($aSubtrahends as $aSubtrahend)
            if (array_key_exists($key, $aSubtrahend))
                unset ($ar1[$key]);
    return $ar1;
}

$a = array("c" => "catty", "b" => "batty", "a" => "aunty", 5 => 4, 2.9 => 7, 11
, "n" => "nutty");
$b = array(9, "d" => "ditty", "b" => "bratty", "a" => null, 10, 13);
$c = array_key_diff ($a, $b, array(5 => 6));
?>

$c is then equivalent to array('c' => 'catty', 6 => 11, 'n' => 'nutty')

Csaba Gabor from New York
===============================================================================

Hi!
I tried hard to find a solution to a problem I'm going to explain here, and
after have read all the array functions and possibilities, I had to create what
I think should exist on next PHP releases.

What I needed, it's some kind of Difference, but working with two arrays and
modifying them at time, not returning an array as a result with the diference
itself.

So, as an example:

A = 1,2,3
B = 2,3,4

should NOT be:

C = 1,4

but:

A = 1
B = 4

so basically, I wanted to delete coincidences on both arrays.

Now, I've some actions to do, and I know wich one I've to do with the values
from one array or another.
With the normal DIFF I can't, because if I've an array like C=1,4, I dont know
if I've to do the Action_A with 1 or with 4, but I really know that everything
in A, will go to the Action_A and everithing in B, will go to Action_B. So same
happens with 4, don't know wich action to apply...

So I created this:

<?php
function array_diff_ORG_NEW(&$org, &$new, $type='VALUES'){
    switch($type){
        case 'VALUES':
            $int = array_values(array_intersect($org, $new)); //C = A ^ B
            $org = array_values(array_diff($org, $int)); //A' = A - C
            $new= array_values(array_diff($new, $int)); //B' = B - C
            break;
        case 'KEYS':
            $int = array_values(array_intersect_key($org, $new)); //C = A ^ B
            $org = array_values(array_diff_key($org, $int)); //A' = A - C
            $new= array_values(array_diff_key($new, $int)); //B' = B - C
            break;
    }
}
?>

This cute, works by reference, and modifies the arrays deleting coincidences on
both, and leaving intact the non coincidences.

So a call to this will be somethin' like:

<?php
$original = array(1,2,3);
$new = array(2,3,4);

array_diff_ORG_NEW($original, $new, 'VALUES');
?>

And HERE, I'll have my arrays as I wanted:

$original = 1
$new = 4

Now, why I use it precisely?

Imagine you've some "Events" and some users you select when create the event,
can "see" this event you create. So you "share" the event with some users. Ok?

Imagine you created and Event_A, and shared with users 1,2,3.

Now you want to modify the event, and you decide to modify the users to share
it. Imagine you change it to users 2,3,4.

(numbers are users ID).

So you can manage when you are going to modify, to have an array with the IDs
in DDBB ($original), and then, have another array with ID's corresponding to
the users to share after modifying ($new). Wich ones you've to DELETE from
DDBB, and wich ones do you've to INSERT?

If you do a simple difference or somehow, you get somethin' like C=1,4.
You have no clue on wich one you've to insert or delete.

But on this way, you can know it, and that's why:

- What keeps on $original, it's somethin not existing in $new at the beggining.
So you know that all what you've inside $original, have to be deleted from DDBB
because what you did in the modifying process, it's to unselect those users
keeping in $original.
- What keeps on $new, it's something not existing in $original at the
beggining. Wich means that in the modifying process you added some new users.
And those have to be inserted in DDBB. So, everything keeping inside $new, have
to be inserted in the DDBB.

Conclusion:

- Remaining in $original --> delete from DB.
- Remaining in $new --> insert into DB.

And that's all!

I hope you find it useful, and I encourage PHP "makers", to add in a not
distant future, somethin' like this one natively, because I'm shure that I'm
not the first one needing something like this.

Best regards all,

Light.
===============================================================================

The fact that it will use the string representation causes alot of problems
with php 5.4.

When you will have an array inside your elements, it will throw a notice error.
It will throw huge amounts of notices depending on how many items you have.

The same problem you will notice when checking with objects inside your array.
It will cause catchable fatal errors.
This is also the case in php 5.3

I'm going to send a bug report, because I think php should handle this.
===============================================================================

There is more fast implementation of array_diff, but with some limitations. If
you need compare two arrays of integers or strings you can use such function:

    public static function arrayDiffEmulation($arrayFrom, $arrayAgainst)
    {
        $arrayAgainst = array_flip($arrayAgainst);
       
        foreach ($arrayFrom as $key => $value) {
            if(isset($arrayAgainst[$value])) {
                unset($arrayFrom[$key]);
            }
        }
       
        return $arrayFrom;
    }

It is ~10x faster than array_diff

php > $t = microtime(true);$a = range(0,25000); $b = range(15000,500000); $c =
array_diff($a, $b);echo microtime(true) - $t;
4.4335179328918
php > $t = microtime(true);$a = range(0,25000); $b = range(15000,500000); $c =
arrayDiffEmulation($a, $b);echo microtime(true) - $t;
0.37219095230103
===============================================================================

Hi, I´d like to give a piece of advice to all who need to use this function to
compare two arrays that have a great quantity of elements. You should sort both
arrays first before comparing, it will work faster.
Thanks
===============================================================================

The description is wrong, array_diff() returns an array consisting of all
elements in $array1 that are not in $array2. The example shows this.

Thats how it works on my php anyway.
===============================================================================

Hello guys,

I´ve been looking for a array_diff that works with recursive arrays, I´ve tried
the ottodenn at gmail dot com function but to my case it doesn´t worked as
expected, so I made my own. I´ve haven´t tested this extensively, but I´ll
explain my scenario, and this works great at that case :D

We got 2 arrays like these:

<?php
$aArray1['marcie'] = array('banana' => 1, 'orange' => 1, 'pasta' => 1);
$aArray1['kenji'] = array('apple' => 1, 'pie' => 1, 'pasta' => 1);

$aArray2['marcie'] = array('banana' => 1, 'orange' => 1);
?>

As array_diff, this function returns all the items that is in aArray1 and IS
NOT at aArray2, so the result we should expect is:

<?php
$aDiff['marcie'] = array('pasta' => 1);
$aDiff['kenji'] = array('apple' => 1, 'pie' => 1, 'pasta' => 1);
?>

Ok, now some comments about this function:
- Different from the PHP array_diff, this function DON´T uses the === operator,
but the ==, so 0 is equal to '0' or false, but this can be changed with no
impacts.
- This function checks the keys of the arrays, array_diff only compares the
values.

I realy hopes that this could help some1 as I´ve been helped a lot with some
users experiences. (Just please double check if it would work for your case, as
I sad I just tested to a scenario like the one I exposed)

<?php
function arrayRecursiveDiff($aArray1, $aArray2) {
    $aReturn = array();
  
    foreach ($aArray1 as $mKey => $mValue) {
        if (array_key_exists($mKey, $aArray2)) {
            if (is_array($mValue)) {
                $aRecursiveDiff = arrayRecursiveDiff($mValue, $aArray2[$mKey]);
                if (count($aRecursiveDiff)) { $aReturn[$mKey] = $aRecursiveDiff
; }
            } else {
                if ($mValue != $aArray2[$mKey]) {
                    $aReturn[$mKey] = $mValue;
                }
            }
        } else {
            $aReturn[$mKey] = $mValue;
        }
    }
  
    return $aReturn;
}
?>
===============================================================================

Until recently, the description said:
"array_diff() returns an array containing all the values of array1 that are not
present in any of the other arguments. Note that keys are preserved."

Now it says:
"Compares array1 against array2 and returns the difference."

Now it's not clear what the optional arguments after the first two do.  Also,
the difference is not symmetric in its arguments (that is array_intersect).
===============================================================================

An earlier comment suggested using array_merge() to reindex the array. While
this will work, array_values() is about 30-40% faster and accomplishes the same
task.
===============================================================================

Even tough the description of this function's behavior has changed it
does not appear as tough the function's behavior has changed.  Below is some
test code and its output:

<?php

    $a = array('1','2','3','4','5');
    $b = array('1','a','b','c','d','e');
    $c = array('2','f','g','h','i','j');
   
    print_r(array_diff($a, $b, $c));

?>

Array
(
    [2] => 3
    [3] => 4
    [4] => 5
)
===============================================================================

Here is a few functions to do a fast diff between two arrays in a few lines.
You can use it with other functions described in the function array_merge :
array_merge_replace from an other user, and two functions using it :
array_merge_diff and array_merge_diff_reverse.
Note that the keys are preserved!
<?
// returns a two dimensions array with the deleted data
// and the added data
function array_diff_both($new,$old)
{
    $del=array_diff_assoc($old,$new);
    $add=array_diff_assoc($new,$old);
    return $diff=array("del"=>$del, "add"=>$add);
}

// returns a two dimensions array with the equal data,
// deleted data and the added data
function array_diff_all($arr_new,$arr_old)
{
    $arr_equ=array_intersect_assoc($arr_new,$arr_old);
    $arr_del=array_diff_assoc($arr_old,$arr_new);
    $arr_add=array_diff_assoc($arr_new,$arr_old);
    return $diff=array("equ"=>$arr_equ, "del"=>$arr_del, "add"=>$arr_add);
}
?>
===============================================================================

Here is some code to take the difference of two arrays. It allows custom
modifications like prefixing with a certain string (as shown) or custom compare
functions.

<?php
// returns all elements in $all which are not in $used in O(n log n) time.
  // elements from $all are prefixed with $prefix_all.
  // elements from $used are prefixed with $prefix_used.
  function filter_unused( $all, $used, $prefix_all = "", $prefix_used = "" ) {
      $unused = array();

      // prefixes are not needed for sorting
      sort( $all );
      sort( $used );

      $a = 0;
      $u = 0;

      $maxa = sizeof($all)-1;
      $maxu = sizeof($used)-1;

      while( true ) {
          if( $a > $maxa ) {
              // done; rest of $used isn't in $all
              break;
          }
          if( $u > $maxu ) {
              // rest of $all is unused
              for( ; $a <= $maxa; $a++ ) {
                  $unused[] = $all[$a];
              }
              break;
          }

          if( $prefix_all.$all[$a] > $prefix_used.$used[$u] ) {
              // $used[$u] isn't in $all?
              $u++;
              continue;
          }

          if( $prefix_all.$all[$a] == $prefix_used.$used[$u] ) {
              // $all[$a] is used
              $a++;
              $u++;
              continue;
          }

          $unused[] = $all[$a];

          $a++;
      }

      return $unused;
  }
?>
===============================================================================

Undocumented return:  it appears this will return NULL if an error occurs
(e.g., an argument is not an array) and is not caught.

<?
@array_diff(NULL, array(1));
@array_diff(array(1), NULL);
@array_diff();
?>

All return NULL.  (Note the "@")
===============================================================================

A simple multidimentional key aware array_diff function.
   
<?php   
function arr_diff($a1,$a2){
  foreach($a1 as $k=>$v){
    unset($dv);
    if(is_int($k)){
      // Compare values
      if(array_search($v,$a2)===false) $dv=$v;
      else if(is_array($v)) $dv=arr_diff($v,$a2[$k]);
      if($dv) $diff[]=$dv;
    }else{
      // Compare noninteger keys
      if(!$a2[$k]) $dv=$v;
      else if(is_array($v)) $dv=arr_diff($v,$a2[$k]);
      if($dv) $diff[$k]=$dv;
    }   
  }
  return $diff;
}
?>

This function meets my immidiate needs but I'm shure it can be improved.
===============================================================================

Based on one lad's code, I created following function for creating something
like HTML diff. I hope it will be useful.

<?php
private function diff ($old, $new)
{
  $old = preg_replace ('/ +/', ' ', $old);
  $new = preg_replace ('/ +/', ' ', $new);
 
  $lo = explode ("\n", trim ($old) . "\n");
  $ln = explode ("\n", trim ($new) . "\n");
  $size = max (count ($lo), count ($ln));

  $equ = array_intersect ($lo, $ln);
  $ins = array_diff ($ln, $lo);
  $del = array_diff ($lo, $ln);
 
  $out = '';
 
  for ($i = 0; $i < $size; $i++)
  {
    if (isset ($del [$i]))
    {
      $out .= '<p><del>' . $del [$i] . '</del></p>';
    }
   
    if (isset ($equ [$i]))
    {
      $out .= '<p>' . $equ [$i] . '</p>';
    }
   
    if (isset ($ins [$i]))
    {
      $out .= '<p><ins>' . $ins [$i] . '</ins></p>';
    }
  }
 
  return $out;
}
?>
===============================================================================

From the page:
Note:  Please note that this function only checks one dimension of a
n-dimensional array. Of course you can check deeper dimensions by using
array_diff($array1[0], $array2[0]);

I've found a way to bypass that. I had 2 arrays made of arrays.
I wanted to extract from the first array all the arrays not found in the second
array. So I used the serialize() function:

<?php
function my_serialize(&$arr,$pos){
  $arr = serialize($arr);
}

function my_unserialize(&$arr,$pos){
  $arr = unserialize($arr);
}

//make a copy
$first_array_s = $first_array;
$second_array_s = $second_array;

// serialize all sub-arrays
array_walk($first_array_s,'my_serialize');
array_walk($second_array_s,'my_serialize');

// array_diff the serialized versions
$diff = array_diff($first_array_s,$second_array_s);

// unserialize the result
array_walk($diff,'my_unserialize');

// you've got it!
print_r($diff);
?>
===============================================================================

Multidimensional array_diff

<?php
echo '<pre>';
$bdd['80395']= array('80396','80397','80398','777');
$folder['80395']= array('80396','80397','666','80398','154223');
$folder['80397']= array('34','35','36','45','57');

echo '<hr>';

function multidimensional_array_diff($a1,$a2)
{
  $r = array();

foreach ($a2 as $key => $second)
{
      foreach ($a1 as $key => $first)
      {
             
            if (isset($a2[$key]))
            {
                foreach ($first as $first_value)
                {
                    foreach ($second as $second_value)
                    {
                        if ($first_value == $second_value)
                        {
                            $true = true;
                            break;   
                        }
                    }
                    if (!isset($true))
                    {
                       
                        $r[$key][] = $first_value;
                    }
                    unset($true);
                }
            }
            else
            {
                $r[$key] = $first;
            }
      }
}
  return $r;
}
print_r(single_diff_assoc($folder,$bdd));
?>

RESULT :

Array
(
    [80395] => Array
        (
            [0] => 666
            [1] => 154223
        )

    [80397] => Array
        (
            [0] => 34
            [1] => 35
            [2] => 36
            [3] => 45
            [4] => 57
        )

)
===============================================================================

I needed a function to only remove the element the amount of times he appears
in the second array. In other words, if you have Array(1, 1, 2) and Array(1),
the return value should be Array(1, 2).
So I built this function right here:

<?php
function array_diff_once(){
    if(($args = func_num_args()) < 2)
        return false;
    $arr1 = func_get_arg(0);
    $arr2 = func_get_arg(1);
    if(!is_array($arr1) || !is_array($arr2))
        return false;
    foreach($arr2 as $remove){
        foreach($arr1 as $k=>$v){
            if((string)$v === (string)$remove){ //NOTE: if you need the diff to
be STRICT, remove both the '(string)'s
                unset($arr1[$k]);
                break; //That's pretty much the only difference from the real
array_diff :P
            }
        }
    }
    //Handle more than 2 arguments
    $c = $args;
    while($c > 2){
        $c--;
        $arr1 = array_diff_once($arr1, func_get_arg($args-$c+1));
    }
    return $arr1;
}
$arr1 = Array("blue", "four"=>4, "color"=>"red", "blue", "green", "green", 
"name"=>"jon", "green");
$arr2 = Array("4", "red", "blue", "green");
print_r(array_diff_once($arr1, $arr2));
?>
This prints:
Array ( [1] => blue [3] => green [name] => jon [4] => green )

Note that it removes the elements left to right, opposite to what you might
expect; in my case the order of elements had no importance. Fixing that would
require a small variation.
===============================================================================

After spending half an hour scratching my head wondering why this function
wasn't working I realised I had the arguments the wrong way round!

I needed to remove the contents of $array1 from $array2 so I tried:

<?php
$diff    = array_diff($members1, $members2);
?>

WRONG!! A quick swap around and things worked smoothly...

<?php
$diff    = array_diff($members2, $members1);
?>

Hope this saves someone a bit of bother
===============================================================================

Yes you can get rid of gaps/missing keys by using:

<?php
$result = array_values(array_diff($array1,$array2));
?>

But to drop the storage of void spaces (actually a line feed) which are
irritatingly indexed when reading from files - just use difference:

<?php
$array = array ();
$array[0] = "\n";
$result = array_diff($result,$array);
?>

dst
===============================================================================

One common caveat of this function is that if the arrays match, an empty array
is return, not a strict boolean. E.g.:

<?php
$array1 = $array2 = array('a','b','c');

var_dump(array_diff($array1,$array2));
/*
*Returns:
* array(0) {
* }
*/
?>
===============================================================================

<?php

// first array
$vid_player = $vm->getVideosByPlayer($player);

// second array
$vid_playlist = $vm->getVideosByPlaylist($playlist);

// this will not work...
$vid_player = array_diff($vid_player, $vid_playlist);

// but if you do this first...
$videos = array();
foreach ( $vid_player as $player )
{
    if ( $vid_playlist != null )
    {
        foreach ( $vid_playlist as $video )
        {
            if ( $player->id == $video->id )
                $videos[] = $player;
        }
    }
}

// this will work...
$vid_player = array_diff($vid_player, $videos);

?>
The first array_diff() compares two arrays only to find out that all the
objects are unique!
===============================================================================

Note that array_diff is not equivalent to

<?php
function fullArrayDiff($left, $right)
{
    return array_diff(array_merge($left, $right), array_intersect($left, $right
));
}
?>

since it is a set-theoretical complement as in

http://en.wikipedia.org/wiki/Complement_(set_theory)
===============================================================================

As touched on in kitchin's comment of 19-Jun-2007 03:49 and nilsandre at gmx
dot de's comment of 17-Jul-2007 10:45, array_diff's behavior may be
counter-intuitive if you aren't thinking in terms of set theory.

array_diff() returns a *mathematical* difference (a.k.a. subtraction) of
elements in array A that are in array B and *not* what elements are different
between the arrays (i.e. those that elements that are in either A or B but
aren't in both A and B).

Drawing one of those Ven diagrams or Euler diagrams may help with
visualization...

As far as a function for returning what you may be expecting, here's one:

<?php
function array_xor ($array_a, $array_b) {
    $union_array = array_merge($array_a, $array_b);
    $intersect_array = array_intersect($array_a, $array_b);
    return array_diff($union_array, $intersect_array)
}
?>
===============================================================================

A small thing that caused me trouble today, wich I don't see listed on this
page is that array_diff keeps the placing for the uniqe values, and removes the
duplicated. This gives us empty fields in the array, wich caused me a lot of
trouble. The solutions was simply to use array_merge() around the array_diff.

For example:
$array1 = array('blue', 'red', 'green');
$array2 = array('red');

array_diff($array1, $array2);

Will give us:
------
Array
(
   [0] => red
   [1] =>
   [2] => green
)

But if we use:

array_merge(array_diff($array1, $array2));

We will get:
------
Array
(
   [0] => red
   [1] => green
)
===============================================================================

To anybody wanting a double-sided array_diff - mentioned by rudigier at noxx
dot at. Remember, array_diff gives you everything in the first array that isn't
in the subsequent arrays.

$array1=array('blue','red','green');
$array2=array('blue','yellow','green');

array_merge(array_diff($array1, $array2),array_diff($array2, $array1));

Result
------
Array
(
    [0] => red
    [1] => yellow
)
===============================================================================

Resubmitting... the update for takes into account comparison issues 

Computes the difference of all the arrays

<?php

/**
* array_diffs — Computes the difference of all the arrays
*
* @param array
*
*    array1 - The array to compare from and against
*    array2 - The array to compare from and against
*    array(n) - More arrays to compare from and against
*       
* @return array Returns all the arrays that do contains entries that cannot be
matched in any of the arrays. 
*/

function array_diffs() {
    $count = func_num_args();
    if($count < 2) {
        trigger_error('Must provide at least 2 arrays for comparison.');
    }
    $check = array();
    $out = array();
     //resolve comparison issues in PHP
    $func = function($a, $b) {
        if(gettype($a) == 'integer' && gettype($b['value']) == 'double' || 
gettype($a) == 'double' && gettype($b['value']) == 'integer') {
            if(gettype($a) == 'integer') {
                if((double) $a == $b['value']) {
                    return true;
                }
            } else {
                if((double) $b['value'] == $a) {
                    return true;
                }
            }
        } elseif(gettype($a) == 'double' && gettype($b['value']) == 'double') {
            $epsilon = 0.00001;
            if(abs($a - $b['value']) < $epsilon) {
                return true;
            }
        } else {
            if($a == $b['value']) {
                return true;
            }
        }
        return false;
    };
    for ($i = 0; $i < $count; $i++) {
        if(!is_array(func_get_arg($i))) {
            trigger_error('Parameters must be passed as arrays.');
        }
        foreach(func_get_arg($i) as $key => $value) {
            if(is_numeric($key) && is_string($value)) {
                if(array_key_exists($value, $check) && $func($value, $check[
$value])) {
                    $check[$value]['count'] = $check[$value]['count'] + 1;
                } else {
                    $check[$value]['value'] = $value;
                    $check[$value]['count'] = 1;
                }
            } elseif(is_numeric($key) && (is_bool($value) || is_null($value) ||
is_numeric($value) || is_object($value) || is_resource($value))) {
                $update = false;
                foreach($check as $check_key => $check_value) {
                    if(is_numeric($key) && (is_bool($check_value['value']) || 
is_null($check_value['value']) || is_numeric($check_value['value']) || 
is_object($check_value['value']) || is_resource($check_value['value']))) {
                        if($func($value, $check_value)) {
                            $update = true;
                            $check[$check_key]['count'] = $check[$check_key][
'count'] + 1;
                        }
                    }
                }
                if(!$update) {
                    $check[] = array('value' => $value, 'count' => 1);
                }
            } else {
                if(array_key_exists($key, $check) && $func($value, $check[$key
])) {
                    $check[$key]['count'] = $check[$key]['count'] + 1;
                } else {
                    $check[$key]['value'] = $value;
                    $check[$key]['count'] = 1;
                }
            }
        }
    }
    foreach($check as $check_key => $check_value) {
        if($check_value['count'] == 1) {
            for ($i = 0; $i < $count; $i++) {
                foreach(func_get_arg($i) as $key => $value) {
                    if(is_numeric($key) && is_string($value)) {
                        if($value == (string) $check_key) {
                            $out[$i][$key] = $value;
                        }
                    } elseif(is_numeric($key) && (is_bool($value) || is_null(
$value) || is_numeric($value) || is_object($value) || is_resource($value))) {
                        if(is_numeric($key) && (is_bool($check_value['value'])
|| is_null($check_value['value']) || is_numeric($check_value['value']) || 
is_object($check_value['value']) || is_resource($check_value['value']))) {
                            if($check_value['value'] == $value) {
                                $out[$i][$key] = $value;
                            }
                        }
                    } else {
                        if($key == $check_key) {
                            $out[$i][$key] = $value;
                        }
                    }
                }
            }
        }
    }
    return $out;
}

?>
===============================================================================

For case-insensitive array_diff use:

$result = array_udiff($array1, $array2, 'strcasecmp');

(Found on stackoverflow)
===============================================================================

Resubmitting... the update for takes into account comparison issues 
Computes the difference of all the arrays
<?php

/**
* array_diffs â€” Computes the difference of all the arrays
*
* @param array
*
*    array1 - The array to compare from and against
*    array2 - The array to compare from and against
*    array(n) - More arrays to compare from and against
*       
* @return array Returns all the arrays that do contains entries that cannot be
matched in any of the arrays.
*/

function array_diffs() {
    $count = func_num_args();
    if($count < 2) {
        trigger_error('Must provide at least 2 arrays for comparison.');
    }
    $check = array();
    $out = array();
     //resolve comparison issue
    $func = function($a, $b) {
        $dbl = function($i, $d) {
            $e = 0.00001;
            if(abs($i-$d) < $e) {
                return true;
            }
            return false;
        };
        if((gettype($a) == 'integer' && gettype($b['value']) == 'double') || (
gettype($a) == 'double' && gettype($b['value']) == 'integer')) {
            if((gettype($a) == 'integer' && $dbl((double) $a, $b['value'])) ||
(gettype($b['value']) == 'integer' && $dbl((double) $b['value'], $a))) {
                return true;
            }
        } elseif((gettype($a) == 'double') && (gettype($b['value']) == 'double'
)) {
            return $dbl($a,$b['value']);
        } elseif($a == $b['value']) {
            return true;
        }
        return false;
    };
    for($i = 0; $i < $count; $i++) {
        if(!is_array(func_get_arg($i))) {
            trigger_error('Parameters must be passed as arrays.');
        }
        foreach(func_get_arg($i) as $key => $value) {
            if(is_numeric($key) && is_string($value)) {
                if(array_key_exists($value, $check) && $func($value, $check[
$value])) {
                    $check[$value]['count'] = $check[$value]['count'] + 1;
                } else {
                    $check[$value]['value'] = $value;
                    $check[$value]['count'] = 1;
                }
            } elseif(is_numeric($key) && (is_bool($value) || is_null($value) ||
is_numeric($value) || is_object($value) || is_resource($value))) {
                $update = false;
                foreach($check as $check_key => $check_value) {
                    if(is_numeric($key) && (is_bool($check_value['value']) || 
is_null($check_value['value']) || is_numeric($check_value['value']) || 
is_object($check_value['value']) || is_resource($check_value['value'])) && 
$func($value, $check_value)) {
                        $update = true;
                        $check[$check_key]['count'] = $check[$check_key][
'count'] + 1;
                    }
                }
                if(!$update) {
                    $check[] = array('value' => $value, 'count' => 1);
                }
            } else {
                if(array_key_exists($key, $check) && $func($value, $check[$key
])) {
                    $check[$key]['count'] = $check[$key]['count'] + 1;
                } else {
                    $check[$key]['value'] = $value;
                    $check[$key]['count'] = 1;
                }
            }
        }
    }
    foreach($check as $check_key => $check_value) {
        if($check_value['count'] == 1) {
           for ($i = 0; $i < $count; $i++) {
                foreach(func_get_arg($i) as $key => $value) {
                    if(is_numeric($key) && is_string($value) && ($value ==
(string) $check_key)) {
                        $out[$i][$key] = $value;
                    } elseif(is_numeric($key) && ($check_value['value'] == 
$value)) {
                        $out[$i][$key] = $value;
                    } elseif(is_string($key) && ($check_value['value'] == 
$value)) {
                        $out[$i][$key] = $value;
                    }
                }
            }
        }
    }
    return $out;
}

?>
===============================================================================

This function comes in handy if we want to compare two array values only

For example we want to make a quick check on some required $_POST parameters:

function required_array($required_array_values, $dynamic_array_values){
  return (count(array_diff(
            $required_array_values,
            $dynamic_array_values
          )) > 0) ? false : true;
}

// we expect $_POST['change_password'][new, old, repeat]
$required_params = required_array(
        array('old','new','repeat'),
        array_keys($_POST['change_password'])
      );

if( !$requred_params  ){
  die('error: all parameters are required!');
}else{
  echo 'good to go';
}
===============================================================================

If you're not getting a count(array_diff($a1,$a2))>0 with something similar to
the following arrays should use the php.net/array_diff_assoc function instead.

$a1 = Array
(
    [0] => id
    [1] => id_1
    [2] => id_2
)

$a2 = Array
(
    [0] => id
    [1] => id_2
    [2] => id_1
)
===============================================================================

This is quite a simple example to compute the difference between array values
without any recursive function:--
<?php

    function array_idiff($a,$b) {
        
        $store = array();
        foreach($a as $key => $values) {
            if(!isset($b[$key]) || $b[$key] !== $values){
                
                $store[] = strtolower($values);
               
            }
        }
        return $store;
    }
    $arr1 = array('this','that','those','they','them');
    $arr2 = array('this','that','them');
    echo "<pre>";
    print_r(array_idiff($arr1,$arr2));
===============================================================================

This is my simple function do compare two arrays. It adds the deleted values
from the original array.

<?php
function array_diff_($old_array,$new_array) {
        foreach($new_array as $i=>$l){
                if($old_array[$i] != $l){
                        $r[$i]=$l;
                }
        }

        //adding deleted values
        foreach($old_array as $i=>$l){
                if(!$new_array[$i]){
                        $r[$i]="";
                }
        }
        return $r;
}
?>
===============================================================================

To: effectpenguin at antarctida dot ru
Re: interesting effect
<?php
function arraycpy(&$target,&$array)
{
if (!is_array($target)) {$target = array();}
foreach($array as $k=>$v) {if ($k != "GLOBALS") {$target[$k] = $v;}}
}
arraycpy($old,$GLOBALS);
// some actions with variables:
$homer = "beer";
arraycpy($new,$GLOBALS);
$diff = array_diff($new,$old);
var_dump($diff);
?>
array(1) {
  ["homer"]=>
  string(4) "beer"
}
Windows NT WPX_NB 5.1 build 2600 PHP/5.0.4
===============================================================================

Suppose you have a CMS which saves a list of phone numbers for each user. They
are stored like this:

$phones['Home'] = '(555)555-1234';
$phones['Office'] = '(555)555-2222';

You only want to save to the database if the list of items has changed.
Including if the ORDER of them has changed.

<?php
// Compares two arrays- keys and values (as strings) must match.
// Keys and order must be the same to be equal.
function arraysEqual($arr1, $arr2){
    if(count($arr1) != count($arr2)){
        return(FALSE);
    }else{
        $arrStr1 = serialize($arr1);
        $arrStr2 = serialize($arr2);
        if( strcmp($arrStr1, $arrStr2)==0 ){
            return(TRUE);
        }else{
            return(FALSE);
        }      
    }
}
?>
===============================================================================

With previous solutions handling multi-dimensional arrays or objects through
serialization, if compared variables contain references at some point, these
will be serialized and stand as such after the diff function.
Here is a safer solution :
<?php
function array_diff_no_cast(&$ar1, &$ar2) {
   $diff = Array();
   foreach ($ar1 as $key => $val1) {
      if (array_search($val1, $ar2) === false) {
         $diff[$key] = $val1;
      }
   }
   return $diff;
}
?>

Example:
<?php
$referenced = Array(1,1);
$array1 = Array(&$referenced, Array(2,3));
$array2 = Array(Array(1,1), Array(4,5));
$result = array_diff_no_cast($array1, $array2);

print_r($result);   //Outputs Array(1 => Array(2,3))
//And $referenced stands unchanged (not serialized)
?>
===============================================================================

array_diff does not have buggy behavior as described above.  The problem stems
from calling array_diff() each time in the loop, therefore regererating a new
array with an index always at the beginning EVERY time, so each will always
pick the first entry.  This is not buggy, but in fact what you've told the
program to do :)  The solution is not as much a solution, but properly
instructing the program what to do!

Cheers!
TheoDiggers
===============================================================================

//array_diff function compare first array against all of the array and return
the elements with index that are not present in either of the array.
<?php
$array1 = array("a" => "green", "red", "c"=>"blue", "red","cyan",2,3,"white");
$array2 = array("b" => "green", "yellow", "red");
$array3 = array("b" => "green", "yellow", "white",4);
$array4 = array("b" => "green", "yellow", "blue",2);
$result = array_diff($array1, $array2,$array3,$array4);
echo "<pre>";
print_r($result);
?>
//outputs
Array
(
    [3] => cyan
    [5] => 3
)
===============================================================================

Are you looking for a function which returns an edit script (a set of insert
and delete instructions on how to change one array into another)? At least,
that's what I hoped to find here, so here's some code based on http://
www.cs.arizona.edu/people/gene/PAPERS/diff.ps :

<?php
function diff_rek(&$a1,&$a2,$D,$k,&$vbck)
{
$x=$vbck[$D][$k]; $y=$x-$k;
if ($D==0)
{
  if ($x==0) return array(array(),array());
  else
  return array(array_slice($a1,0,$x),array_fill(0,$x,"b"));
}
$x2=$vbck[$D-1][$k+1];
$y2=$vbck[$D-1][$k-1]-($k-1);
$xdif=$x-$x2; $ydif=$y-$y2;
$l=min($x-$x2,$y-$y2);
$x=$x-$l;
$y=$y-$l;
if ($x==$x2)
{
   $res=diff_rek($a1,$a2,$D-1,$k+1,$vbck);
   array_push($res[0],$a2[$y-1]);
   array_push($res[1],"2");
   if ($l>0)
   {
    $res[0]=array_merge($res[0],array_slice($a2,$y,$l));
    $res[1]=array_merge($res[1],array_fill(0,$l,"b"));
   }
}
else
{
   $res=diff_rek($a1,$a2,$D-1,$k-1,$vbck);
   array_push($res[0],$a1[$x-1]);
   array_push($res[1],"1");
   if ($l>0)
   {
    $res[0]=array_merge($res[0],array_slice($a1,$x,$l));
    $res[1]=array_merge($res[1],array_fill(0,$l,"b"));
   }
}
return $res;
}

function arr_diff(&$a1,&$a2)
{
$max=70;
$c1=count($a1);
$c2=count($a2);
$v[1]=0;
for ($D=0; $D<=$max; $D++)
{
   for ($k=-$D; $k<=$D; $k=$k+2)
  {
   if (($k==-$D) || ($k!=$D && $v[$k-1]<$v[$k+1]))
    $x=$v[$k+1];
   else
    $x=$v[$k-1]+1;
   $y=$x-$k;
   while (($x<$c1)&&($y<$c2)&&($a1[$x]==$a2[$y]))
    {
     $x++;
     $y++;
    }
    $v[$k]=$x;
    if (($x>=$c1)&&($y>=$c2))
   {
    $vbck[$D]=$v;
    return diff_rek($a1,$a2,$D,$c1-$c2,$vbck);
   };
  }
  $vbck[$D]=$v;
};
return -1;
}
?>

This works on arrays of all elements for which the operator "==" is defined.
arr_dif($a1,$a2) returns an array of two arrays:
$result[0] = array of elements from $a1 and $a2
$result[1] = array of chars - one for each element from $result[0]:
"1" : The corresponding element is from $a1
"2" : The corresponding element is from $a2
"b" : The correspondig element is from both source arrays
The function returns -1, when the number of different elements is greater than
$max

Example:
$a1=array("hello","world");
$a2=array("good","bye","world");
=> arr_diff($a1,$a2) = array(array("hello","good","bye","world"), array
("1","2","2","b"));
===============================================================================

Please note that array_diff cannot compare with an undefined array. For
example:

<?php
$array1 = array ("ABC", "DEF");

$Result = $array_diff( $array1, $array2);

var_dump($Result);
?>

will output NULL NULL. If your script causes an undefined array (like mine did)
it can be hard to find the mistake.

Greetings
===============================================================================

be careful kids, this function can be tricky
<?php
$tab1=array(0=>"a");
$tab2=array(0=>"a",1=>"b");

print_r(array_diff($tab1,$tab2));
?>
gives
Array
(
)
