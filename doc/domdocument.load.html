
DOMDocument::load

(PHP 5, PHP 7)

DOMDocument::load — Load XML from a file

说明

public mixed DOMDocument::load ( string $filename [, int $options = 0 ] )

Loads an XML document from a file.

Warning

Unix style paths with forward slashes can cause significant performance
degradation on Windows systems; be sure to call realpath() in such a case.

参数

filename

    The path to the XML document.

options

    Bitwise OR of the libxml option constants.

返回值

成功时返回 TRUE，或者在失败时返回 FALSE。 If called statically, returns a
DOMDocument 或者在失败时返回 FALSE.

错误／异常

If an empty string is passed as the filename or an empty file is named, a
warning will be generated. This warning is not generated by libxml and cannot
be handled using libxml's error handling functions.

此方法可以被静态调用,但会抛出一个 E_STRICT 错误。

范例

Example #1 Creating a Document

<?php
$doc = new DOMDocument();
$doc->load('book.xml');
echo $doc->saveXML();
?>

参见

  • DOMDocument::loadXML() - Load XML from a string
  • DOMDocument::save() - Dumps the internal XML tree back into a file
  • DOMDocument::saveXML() - Dumps the internal XML tree back into a string


User Contributed Notes 14 notes

===============================================================================

I had a problem with loading documents over HTTP. I would get errors looking
like this:

Warning: DOMDocument::load(http://external/document.xml): failed to open
stream: HTTP request failed! HTTP/1.1 500 Internal Server Error

The document would load fine in browsers and using wget. The problem is that
DOMDocument::load() on my systems (both OS X and Linux) didn't send any
User-Agent header which for some weird reason made Microsoft-IIS/6.0 respond
with the 500 error.

The solution is found on http://php.net/manual/en/
function.libxml-set-streams-context.php :

<?php
$opts = array(
    'http' => array(
        'user_agent' => 'PHP libxml agent',
    )
);

$context = stream_context_create($opts);
libxml_set_streams_context($context);

// request a file through HTTP
$doc = DOMDocument::load('http://www.example.com/file.xml');
?>
===============================================================================

in the default example:

<?php
$doc = new DOMDocument();
$doc->load('book.xml');
echo $doc->saveXML();
?>

you must enter the absolute path for book.xml due for get a false result in
load function.
===============================================================================

NOTE, will not load successfully if there is a comment at the beginning of the
file before the <?xml version="1.0" ?> declaration!
===============================================================================

If you are loading xml with the intention of validating it against an internal
dtd and you have experienced issues with the validation it could be related to
missing LIBXML constants.

I found this post by "aidan at php dot net" in root level dom docs and thought
it might be more useful here:
As of PHP 5.1, libxml options may be set using constants rather than the use of
proprietary DomDocument properties.

DomDocument->resolveExternals is equivilant to setting
LIBXML_DTDLOAD
LIBXML_DTDATTR

DomDocument->validateOnParse is equivilant to setting
LIBXML_DTDLOAD
LIBXML_DTDVALID

PHP 5.1 users are encouraged to use the new constants.

Example:
<?php
$dom = new DOMDocument;
// Resolve externals
$dom->load($file, LIBXML_DTDLOAD|LIBXML_DTDATTR);
// OR
// Validate against DTD
$dom->load($file, LIBXML_DTDLOAD|LIBXML_DTDVALID);
$dom->validate();
?>
===============================================================================

BadGuy´s note may be confusing since what he depicts is no special property of
the relevant method. PHP works always in and on a local file system which means
that if you want to use resources from other systems or - what is, indeed,
BadGuy´s problem - need resources that have been dealt with by other programs
or processes, you have to state and manage that explicitly in your code. PHP is
just a quite normal program in that.

BadGuy´s solution is using the "http wrapper" to get output from another
process (see "wrappers" in the PHP manual). Doing this, the appropriate syntax
for http calls has to be respected.
===============================================================================

i've found the partial solution for xml:id warning,is explained at this
address: https://fosswiki.liip.ch/display/BLOG/GetElementById+Pitfalls

there explains that:
The ID does have to be a valid NCName, which for example means, that the first
letter can't be a number.

and in my xml:id i had a number. :D
===============================================================================

XHTML and entities: The solution proposed below by zachatwork at gmail dot com
didn't work for me. I checked on a number of servers (both LAMPP and WAMPP) -
on each of them, calling loadXML() with the LIBXML_DTDLOAD option triggered an
external request for the DTD. And that's bad news.

If allow_url_fopen is turned off, the request for the DTD fails with a warning.
If it is turned on, the request fails because these w3c URLs return a 503
Service Unavailable.

HTML entities still generate a warning in either case.

The best solution, as far as I can tell, is simply to ignore the warnings and
suppress them using '@'. I can't recommend parsing XHTML with loadHTML()
instead of loadXML() - yes, you get rid of the entity problem, but loadHTML()
changes the source while parsing it (tries to 'fix' it even though there is
nothing to fix).
===============================================================================

You can easily avoid the warning about &nbsp; references by using the
LIBXML_DTDLOAD option.

<?php

$html = <<<EOF
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://
www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
  </head>
  <body>
    <p>&nbsp;</p>
  </body>
</html>
EOF;

// This one works perfectly.
$dom = new DOMDocument();
$dom->loadXML($html, LIBXML_DTDLOAD);
print $dom->saveXML();

// This one produces a warning.
$dom = new DOMDocument();
$dom->loadXML($html);
print $dom->saveXML();

?>

See also: http://www.php.net/manual/en/libxml.constants.php

Note that libxml will detect that your DTD is locally available via /etc/xml/
catalog. So there is no worry about this causing your DOM loads to make
external network requests.
===============================================================================

Function will not work if using XML DOM PECL module
===============================================================================

In reply to BadGuy [at] BadGuy [dot] nl

When the news.php file is located on the same server, like you said in the
first example then http://my.beautiful-website.com/xmlsource/news.php wouldn't
work, but you should use http://localhost/xmlsource/news.php or http://
127.0.0.1/xmlsource/news.php
===============================================================================

Note that this method uses the local file system before doing anything remote.
The 'disadvantage' would be that if you would do the following:
<?php
$xml = new DOMDocument;
$xml->load("xmlsource/news.php");
?>

This would not make the method read the actual output of the news.php file
--presumably valid xml data--, but the file contents --obviously this would be
php code. So this will return an error saying news.php is missing the xml
declaration and maybe the xml start-tag

What would work is the following:

<?php
$xml = new DOMDocument;
$xml->load("http://my.beautiful-website.com/xmlsource/news.php");
?>

This will force a http request to be used to get this file instead of just
locally reading it and the file just returning code
===============================================================================

Suppose you wanted to dynamically load an array from an .XSD file. This method
is your guy. just remember to use the actual xs: portion in xpaths and such.

All the other "load" methods will error out.

<?php
$attributes = array();
$xsdstring = "/htdocs/api/xsd/common.xsd";
$XSDDOC = new DOMDocument();
$XSDDOC->preserveWhiteSpace = false;
if ($XSDDOC->load($xsdstring))
{
    $xsdpath = new DOMXPath($XSDDOC);
    $attributeNodes =
              $xsdpath->
              query('//xs:simpleType[@name="attributeType"]')
              ->item(0);
    foreach ($attributeNodes->childNodes as $attr)
    {
        $attributes[ $attr->getAttribute('value') ] = $attr->getAttribute(
'name');
    }
    unset($xsdpath);
}
print_r($attributes);
?>
===============================================================================

load() will handle non-ASCII characters depending on the details of the XML
declaration, but in a somewhat surprising way. One would assume that the
declarations '<?xml version="1.0" encoding="UTF-8"?>' and '<?xml version=
"1.0"?>' are treated in the same way because UTF-8 is the default encoding
anyway. But not so.

* If there is an XML declaration defining the encoding *explicitly*, the
non-ASCII characters remain unchanged.
* If the XML declaration does not define the encoding explicitly, or if the XML
declaration is missing, non-ASCII characters are converted into numeric
entities.

So the document

    <?xml version="1.0"?>
    <root><nonascii>ä</nonascii></root>

will be converted to

    <?xml version="1.0"?>
    <root><nonascii>&#xE4;</nonascii></root>

The same happens if there is no XML declaration at all. On the other hand, the
document

    <?xml version="1.0" encoding="UTF-8"?>
    <root><nonascii>ä</nonascii></root>

will remain as it is.

This behaviour applies to loadXML() as well.
===============================================================================

adding an id for a child, when i use abstract mode i get the following warning:

[quote]Warning: DOMDocument::load() [domdocument.load]: xml:id : attribute
value xx is not an NCName in /fake/path/to/xmlfile[/quote]
