
gmp_xor

(PHP 4 >= 4.0.4, PHP 5, PHP 7)

gmp_xor — Bitwise XOR

说明

GMP gmp_xor ( GMP $a , GMP $b )

Calculates bitwise exclusive OR (XOR) of two GMP numbers.

参数

a

    可以是一个 GMP 数据 resouce，或一个可以转换为数值的字符串。

b

    可以是一个 GMP 数据 resouce，或一个可以转换为数值的字符串。

返回值

GMP 数值资源.

范例

Example #1 gmp_xor() example

<?php
$xor1 = gmp_init("1101101110011101", 2);
$xor2 = gmp_init("0110011001011001", 2);

$xor3 = gmp_xor($xor1, $xor2);

echo gmp_strval($xor3, 2) . "\n";
?>

以上例程会输出：

1011110111000100


User Contributed Notes 5 notes

===============================================================================

To be unbreakable XOR encryption must have a key that is totally random and is
never re-used.  If you use a key a second time, it can be broken.  This can be
confirmed by reading the page at http://en.wikipedia.org/wiki/One-time_pad.

Although I am not an expert on cryptography, I understand that decyphering
involves recognizing patterns and that it would be possible to decrypt code
that was encoded using XOR with the same key if there were enough samples to
examine.  Maintaining unique keys for each encryption at both encryption and
decryption points to ensure 100 percent unbreakability has security problems of
its own - where and how are the keys stored and how are they transmitted to the
decryption points?
===============================================================================

XOR encryption is an ultimate encryption algorithm. It can't be be broken. It
is used to encrypt stealth submarine's orders. I cannot agree with "kid-sister"
post below. If you use vast key (as long as encrypted message) which is random
(space noise recorded on a cd), the encrypted message is also radnom -
impossible to decrypt without key. Under those conditions, XOR is strongest
encryption algorithm ever known.
===============================================================================

here's a fast alternative to compute the xor-value of two bitstrings of an
arbitrary (but same) length.

<?php
/**
* xor-op for bitstrings of arbitrary length
* bitstrings must have same length
*
* @param string $o1
* @param string $o2
* @return string
*/
function bitxor($o1, $o2) {
    $xorWidth = PHP_INT_SIZE*8;
    $o1 = str_split($o1, $xorWidth);
    $o2 = str_split($o2, $xorWidth);
    $res = '';
    $runs = count($o1);
    for($i=0;$i<$runs;$i++)
        $res .= decbin(bindec($o1[$i]) ^ bindec($o2[$i]));       
    return $res;
}
?>
===============================================================================

XOR encryption only works if the key is at liest the same size as the
plaintext, and the key is perfectly random. And no, rand() is not perfectly
random.
===============================================================================

The logical XOR can be used for encrypting data. Use resource A as your
original text and resource B as the key. Be sure to use long enough key so that
the key doesn't loop. Decryption works the same way, input encrypted text as
res A and key as res B.
