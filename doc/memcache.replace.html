
Memcache::replace

(PECL memcache >= 0.2.0)

Memcache::replace — 替换已经存在的元素的值

说明

bool Memcache::replace ( string $key , mixed $var [, int $flag [, int $expire
]] )

Memcache::replace()通过key来查找元素并替换其值。当key 对应的元素不存在时，
Memcache::replace()返回FALSE。其他方面Memcache::replace() 的行为和Memcache::set
()一样。同样你也可以使用函数memcache_replace()。

参数

key

    期望替换值的元素的key。

var

    将要存储的新的值，字符串和数值直接存储，其他类型序列化后存储。

flag

    使用MEMCACHE_COMPRESSED指定对值进行压缩(使用zlib)。

expire

    当前写入缓存的数据的失效时间。如果此值设置为0表明此数据永不过期。你可以设置
    一个UNIX时间戳或以秒为单位的整数（从当前算起的时间差）来说明此数据的过期时
    间，但是在后一种设置方式中，不能超过 2592000秒（30天）。

返回值

成功时返回 TRUE，或者在失败时返回 FALSE。

范例

Example #1 Memcache::replace()示例

<?php

$memcache_obj = memcache_connect('memcache_host', 11211);

/* procedural API */
memcache_replace($memcache_obj, "test_key", "some variable", false, 30);

/* OO API */
$memcache_obj->replace("test_key", "some variable", false, 30);

?>

参见

  • Memcache::set() - Store data at the server
  • Memcache::add() - 增加一个条目到缓存服务器


User Contributed Notes 1 note

===============================================================================

This page mentions that replace should be used rather than set, but gives no
reason. Best information I could find was a comment by 'argyleblanket' on the
set page. (http://www.php.net/manual/en/memcache.set.php#84032)

"Using set more than once for the same key seems to have unexpected results -
it does not behave as a "replace," but instead seems to "set" more than one
value for the same key.  "get" may return any of the values.

This was tested on a multiple-server setup - behaviour may be different if you
only have one server. "
