
imageline

(PHP 4, PHP 5, PHP 7)

imageline — 画一条线段

说明

bool imageline ( resource $image , int $x1 , int $y1 , int $x2 , int $y2 , int
$color )

imageline() 用 color 颜色在图像 image 中从坐标 x1，y1 到 x2，y2（图像左上角为
0, 0）画一条线段。

Example #1 画一条粗线

<?php

function imagelinethick($image, $x1, $y1, $x2, $y2, $color, $thick = 1)
{
    /* 下面两行只在线段直角相交时好使
    imagesetthickness($image, $thick);
    return imageline($image, $x1, $y1, $x2, $y2, $color);
    */
    if ($thick == 1) {
        return imageline($image, $x1, $y1, $x2, $y2, $color);
    }
    $t = $thick / 2 - 0.5;
    if ($x1 == $x2 || $y1 == $y2) {
        return imagefilledrectangle($image, round(min($x1, $x2) - $t), round(
min($y1, $y2) - $t), round(max($x1, $x2) + $t), round(max($y1, $y2) + $t), 
$color);
    }
    $k = ($y2 - $y1) / ($x2 - $x1); //y = kx + q
    $a = $t / sqrt(1 + pow($k, 2));
    $points = array(
        round($x1 - (1+$k)*$a), round($y1 + (1-$k)*$a),
        round($x1 - (1-$k)*$a), round($y1 - (1+$k)*$a),
        round($x2 + (1+$k)*$a), round($y2 - (1-$k)*$a),
        round($x2 + (1-$k)*$a), round($y2 + (1+$k)*$a),
    );
    imagefilledpolygon($image, $points, 4, $color);
    return imagepolygon($image, $points, 4, $color);
}

?>

参见 imagecreatetruecolor() 和 imagecolorallocate()。


User Contributed Notes 30 notes

===============================================================================

Here is a simple code to draw a line with an arbitrary stroke. The parameter
aStroke is treated as a cyclic boolean array where true equals "set a point"
e.g. $aDotStroke = array(true,false);

function ImageStrokeLine($im,$x1,$y1,$x2,$y2,$farbe, $aStroke)
  {
    $deltax = abs($x2 - $x1);       
    $deltay = abs($y2 - $y1);       
    $x = $x1;                      
    $y = $y1;                      
   
    if ($x2 >= $x1)                
    {
      $xinc1 = 1;
      $xinc2 = 1;
    }
    else                         
    {
      $xinc1 = -1;
      $xinc2 = -1;
    }
   
    if ($y2 >= $y1)                
    {
      $yinc1 = 1;
      $yinc2 = 1;
    }
    else                         
    {
      $yinc1 = -1;
      $yinc2 = -1;
    }
   
    if ($deltax >= $deltay) 
    {
      $xinc1 = 0;                
      $yinc2 = 0;                
      $den = $deltax;
      $num = $deltax / 2;
      $numadd = $deltay;
      $numpixels = $deltax;
    }
    else                         
    {
      $xinc2 = 0;            
      $yinc1 = 0;            
      $den = $deltay;
      $num = $deltay / 2;
      $numadd = $deltax;
      $numpixels = $deltay;
    }
   
    for ($curpixel = 0; $curpixel <= $numpixels; $curpixel++)
    {
      if ($iStrokeCount >= count($aStroke))
      {
        $iStrokeCount = 0;
      }
 
      if ($aStroke[$iStrokeCount++])
      {
        ImageSetPixel($im,$x, $y,$farbe);           
      }           
      $num += $numadd;           
      if ($num >= $den)            
      {
        $num -= $den;              
        $x += $xinc1;              
        $y += $yinc1;              
      }
      $x += $xinc2;                
      $y += $yinc2;                
    }
  }
===============================================================================

Here my function do clear all problems. With this, you can draw firstly smooth
lines (basic code adapted from code_couturier at graffiti dot net, with some
performance changes). The special is, you can define the alpha-value of the
line (0 = normal smooth line, 127 = fully transparent). Change whatever you
want to make it better, but post your results ;)

<?php
/**
* function imageSmoothAlphaLine() - version 1.0
* Draws a smooth line with alpha-functionality
*
* @param   ident    the image to draw on
* @param   integer  x1
* @param   integer  y1
* @param   integer  x2
* @param   integer  y2
* @param   integer  red (0 to 255)
* @param   integer  green (0 to 255)
* @param   integer  blue (0 to 255)
* @param   integer  alpha (0 to 127)
*
* @access  public
*
* @author  DASPRiD <d@sprid.de>
*/
function imageSmoothAlphaLine ($image, $x1, $y1, $x2, $y2, $r, $g, $b, $alpha=0
) {
  $icr = $r;
  $icg = $g;
  $icb = $b;
  $dcol = imagecolorallocatealpha($image, $icr, $icg, $icb, $alpha);
 
  if ($y1 == $y2 || $x1 == $x2)
    imageline($image, $x1, $y2, $x1, $y2, $dcol);
  else {
    $m = ($y2 - $y1) / ($x2 - $x1);
    $b = $y1 - $m * $x1;

    if (abs ($m) <2) {
      $x = min($x1, $x2);
      $endx = max($x1, $x2) + 1;

      while ($x < $endx) {
        $y = $m * $x + $b;
        $ya = ($y == floor($y) ? 1: $y - floor($y));
        $yb = ceil($y) - $y;
  
        $trgb = ImageColorAt($image, $x, floor($y));
        $tcr = ($trgb >> 16) & 0xFF;
        $tcg = ($trgb >> 8) & 0xFF;
        $tcb = $trgb & 0xFF;
        imagesetpixel($image, $x, floor($y), imagecolorallocatealpha($image, (
$tcr * $ya + $icr * $yb), ($tcg * $ya + $icg * $yb), ($tcb * $ya + $icb * $yb),
$alpha));
 
        $trgb = ImageColorAt($image, $x, ceil($y));
        $tcr = ($trgb >> 16) & 0xFF;
        $tcg = ($trgb >> 8) & 0xFF;
        $tcb = $trgb & 0xFF;
        imagesetpixel($image, $x, ceil($y), imagecolorallocatealpha($image, (
$tcr * $yb + $icr * $ya), ($tcg * $yb + $icg * $ya), ($tcb * $yb + $icb * $ya),
$alpha));
 
        $x++;
      }
    } else {
      $y = min($y1, $y2);
      $endy = max($y1, $y2) + 1;

      while ($y < $endy) {
        $x = ($y - $b) / $m;
        $xa = ($x == floor($x) ? 1: $x - floor($x));
        $xb = ceil($x) - $x;
 
        $trgb = ImageColorAt($image, floor($x), $y);
        $tcr = ($trgb >> 16) & 0xFF;
        $tcg = ($trgb >> 8) & 0xFF;
        $tcb = $trgb & 0xFF;
        imagesetpixel($image, floor($x), $y, imagecolorallocatealpha($image, (
$tcr * $xa + $icr * $xb), ($tcg * $xa + $icg * $xb), ($tcb * $xa + $icb * $xb),
$alpha));
 
        $trgb = ImageColorAt($image, ceil($x), $y);
        $tcr = ($trgb >> 16) & 0xFF;
        $tcg = ($trgb >> 8) & 0xFF;
        $tcb = $trgb & 0xFF;
        imagesetpixel ($image, ceil($x), $y, imagecolorallocatealpha($image, (
$tcr * $xb + $icr * $xa), ($tcg * $xb + $icg * $xa), ($tcb * $xb + $icb * $xa),
$alpha));
 
        $y ++;
      }
    }
  }
} // end of 'imageSmoothAlphaLine()' function
?>
===============================================================================

here is a function that helps you create arrows...

<?php
function get_arrowheads ($x1, $y1, $x2, $y2, $arrhead, $arrang) {
    $debug = false;
   
    define("INFINITE", 'INFINITE');
    if (($x2-$x1)==0) {
        if ($y1 == 0) {
            $slope = 0;
        } else {
            $slope = INFINITE;
        }
    } else {
        $slope = -($y2-$y1)/($x2-$x1);
    }

    //$slope = number_format($slope, 2, '.','');
    if ($slope == 'INFINITE') {
        $ang = 90;
    } else {
        $ang = atan ($slope);
        $ang = ($ang * 180)/pi();
    }
    //$ang = number_format($ang, 2, '.', '');
    //echo ($ang);
    //exit;

    //convert the angle
    $arrang1 = ($ang - $arrang);
    $arrangdeg1 = ($ang - $arrang);
    //echo ($arrang1);exit;
    $arrang1 = ($arrang1*pi())/180;

    $arrang2 = ($ang + $arrang);
    $arrangdeg2 = ($ang + $arrang);
    $arrang2 = ($arrang2*pi())/180;
    //echo ($arrang1);

    $arx1 = (floor(cos($arrang1)*$arrhead));
    $ary1 = (floor(sin($arrang1)*$arrhead));
    $arx2 = (floor(cos($arrang2)*$arrhead));
    $ary2 = (floor(sin($arrang2)*$arrhead));
    if ($debug) {
        echo ("Values of arx1.. before add/sub</br>");
        echo ("$arx1,$ary1&nbsp;&nbsp;&nbsp;$arx2,$ary2</br>");
    }
    if ($ang==0) {
        if ($x2 > $x1) {
            $arx1 = $x2 - $arx1;    $ary1 = $y2 - $ary1;
            $arx2 = $x2 - $arx2;    $ary2 = $y2 - $ary2;
        } elseif ($x2 < $x1) {
            $arx1 = $x2 + $arx1;    $ary1 = $y2 - $ary1;
            $arx2 = $x2 + $arx2;    $ary2 = $y2 - $ary2;
        }
    }
    if ($ang > 0 && $ang < 90) {
        if (($x2 > $x1) && ($y2 < $y1)) {
            $arx1 = $x2 - $arx1;    $ary1 = $y2 + $ary1;
            $arx2 = $x2 - $arx2;    $ary2 = $y2 + $ary2;
        } elseif (($x2 < $x1) && ($y2 > $y1)) {
            $arx1 = $x2 + $arx1;    $ary1 = $y2 - $ary1;
            $arx2 = $x2 + $arx2;    $ary2 = $y2 - $ary2;
        }
    }
    if ($ang==90) {
        if (($y2 > $y1)) {
            $arx1 = $x2 - $arx1;    $ary1 = $y2 - $ary1;
            $arx2 = $x2 - $arx2;    $ary2 = $y2 - $ary2;
        } elseif (($y2 < $y1)) {
            $arx1 = $x2 - $arx1;    $ary1 = $y2 + $ary1;
            $arx2 = $x2 - $arx2;    $ary2 = $y2 + $ary2;
        }
    }
    if ($ang > -90 && $ang < 0) {
        if (($x2 > $x1) && ($y2 > $y1)) {
            $arx1 = $x2 - $arx1;    $ary1 = $y2 + $ary1;
            $arx2 = $x2 - $arx2;    $ary2 = $y2 + $ary2;
        } elseif (($x2 < $x1) && ($y2 < $y1)) {
            $arx1 = $x2 + $arx1;    $ary1 = $y2 - $ary1;
            $arx2 = $x2 + $arx2;    $ary2 = $y2 - $ary2;
        }
    }

    if ($debug) {
        echo ("Angle of line is (".$ang*180/pi().")</br>");
        echo ("Angle of line1 is $arrangdeg1</br>");
        echo ("Angle of line2 is $arrangdeg2</br>");
        echo ("$arx1,$ary1&nbsp;&nbsp;&nbsp;$x2,$y2</br>");
        echo ("$arx2,$ary2&nbsp;&nbsp;&nbsp;$x2,$y2");
        exit;
    }
   
    $array_arrows = array (
                    'x1' =>$arx1,
                    'y1' => $ary1,
                    'x2' => $arx2,
                    'y2' => $ary2
                    );
    return $array_arrows;

}

$x1 = 200; $y1 = 200;
$x2 = 400; $y2 = 100;
$arrhead = 15; //10px
$arrang = 10; //10 deg

$ar_arrws = get_arrowheads ($x1, $y1, $x2, $y2, $arrhead, $arrang);

$im  = imagecreate (400, 400);
$w   = imagecolorallocate ($im, 255, 255, 255);
$red = imagecolorallocate ($im, 255, 0, 0);

//creates the base line
imageline ($im, $x1, $y1, $x2, $y2, $green);
imageline ($im, $x1+1, $x2+1, $y1+1, $y2+1, $red);
imageline ($im, $x2, $y2, $ar_arrws['x1'], $ar_arrws['y1'], $green);
imageline ($im, $x2, $y2, $ar_arrws['x2'], $ar_arrws['y2'], $green);

?>
===============================================================================

The most bold-line-functions i found have problems with lines in a certian
direction (they draw smaller lines with some angles). To do a real bold line
just use this function:

<?php
function imageBoldLine($resource, $x1, $y1, $x2, $y2, $Color, $BoldNess=2, 
$func='imageLine')
{
$center = round($BoldNess/2);
for($i=0;$i<$BoldNess;$i++)
{ 
  $a = $center-$i; if($a<0){$a -= $a;}
  for($j=0;$j<$BoldNess;$j++)
  {
   $b = $center-$j; if($b<0){$b -= $b;}
   $c = sqrt($a*$a + $b*$b);
   if($c<=$BoldNess)
   {
    $func($resource, $x1 +$i, $y1+$j, $x2 +$i, $y2+$j, $Color);
   }
  }
}        
}
?>
===============================================================================

Here is a analog clock representation of the system time along with digits for
hours and little dots for minutes/seconds:

<?php
$img = imagecreatetruecolor(450, 450);

$white = imagecolorallocate($img, 255, 255, 255);
$red = imagecolorallocate($img, 255, 0, 0);
$black = imagecolorallocate($img, 0, 0, 0);
$grey = imagecolorallocate($img, 211, 211, 211);

imagefill($img, 0, 0, $white);
imagearc($img, 224, 224, 400, 400, 0, 0, $black);
imagefilledarc($img, 224, 224, 15, 15, 0, 0, $black, IMG_ARC_PIE);

for ($zz = 0; $zz < 60; $zz++) {
    $digitCoords['x'][] = 175 * cos(deg2rad(($zz-10) * (360/60))) + 224;
    $digitCoords['y'][] = 175 * sin(deg2rad(($zz-10) * (360/60))) + 224;
}

for ($zz = 0; $zz < 60; $zz++) {
    if ($zz % 5 == 0)
        imagestring($img, 5, $digitCoords['x'][$zz] - 4, $digitCoords['y'][$zz]
- 6, ($zz/5) + 1, $black);
    else
        imagefilledarc($img, $digitCoords['x'][$zz], $digitCoords['y'][$zz], 3,
3, 0, 0, $grey, IMG_ARC_PIE);
}

$seconds = date('s');
$minutes = date('i') + ($seconds/60);
$hours = date('h') + ($minutes/60);

$r_sec = 175;
$r_min = 175;
$r_hr = 125;

$x_sec = $r_sec * cos(deg2rad(($seconds-15) * (360/60))) + 224;
$y_sec = $r_sec * sin(deg2rad(($seconds-15) * (360/60))) + 224;

$x_min = $r_min * cos(deg2rad(($minutes-15) * (360/60))) + 224;
$y_min = $r_min * sin(deg2rad(($minutes-15) * (360/60))) + 224;

$x_hr = $r_hr * cos(deg2rad(($hours-3) * (360/12))) + 224;
$y_hr = $r_hr * sin(deg2rad(($hours-3) * (360/12))) + 224;

imageline($img, 224, 224, $x_sec, $y_sec, $red);
imagesetthickness($img, 3);
imageline($img, 224, 224, $x_min, $y_min, $black);
imagesetthickness($img, 5);
imageline($img, 224, 224, $x_hr, $y_hr, $black);

header("Content-type: image/png");
imagepng($img);

imagedestroy($img);
?>
===============================================================================

This is a function to make a dotted line. It accepts (it actually requires) 7
parameters and returns 1 if everything went OK and 0 if there was a problem.

int imagelinedotted ( resource im, int x1, int y1, int x2, int y2, int dist,
int col )

imagelinedotted() draws a line from x1, y1 to x2, y2 (top left is 0, 0) in
image im of colour col where dist defines the distance (measured in pixels)
between one dot and another.

<?php
function imagelinedotted ($im, $x1, $y1, $x2, $y2, $dist, $col) {
    $transp = imagecolortransparent ($im);
   
    $style = array ($col);
   
    for ($i=0; $i<$dist; $i++) {
        array_push($style, $transp);        // Generate style array - loop
needed for customisable distance between the dots
    }
   
    imagesetstyle ($im, $style);
    return (integer) imageline ($im, $x1, $y1, $x2, $y2, IMG_COLOR_STYLED);
    imagesetstyle ($im, array($col));        // Reset style - just in case...
}
?>
===============================================================================

Little function I made to draw faaaaat lines...

<?php
/**
* imageBoldLine function
* this function allows you to draw faaaat lines.
*
* To keep the function a bit more flexible, it's possible to change the
function which draw the lines
* @param resource $resource
* @param int $x1
* @param int $y1
* @param int $x2
* @param int $y2
* @param int $Color
* @param int $BoldNess (1 = thin, 2=bold, 1000 = extreme fat)
* @param string $func Functionname. Notice that the function must got the same
signature.
* @return void
* @author Nicolas 'keksnicoh' Heimann <www.salamipla.net>
* @date nov08
* <code><?php
* imageBoldLine($res, 0, 0, 100, 100, $col, 5);
* ?></code>
*/
function imageBoldLine($resource, $x1, $y1, $x2, $y2, $Color, $BoldNess=2, 
$func='imageLine')
{
    $x1 -= ($buf=ceil(($BoldNess-1) /2));
    $x2 -= $buf;
    for($i=0;$i < $BoldNess;++$i)
        $func($resource, $x1 +$i, $y1, $x2 +$i, $y2, $Color);
}
?>
===============================================================================

An example to draw Lissajous Curve (http://en.wikipedia.org/wiki/
Lissajous_curve):
x = a1 * cos(t/T1);
y = a2 * sin(t/T2);

You can easily modify the codes to create your own oscilloscope application!

<?php
header ("Content-type: image/png");

$T1 = 20;
$T2 = 30;

$myImage = @imagecreatetruecolor(640, 480)
      or die("Cannot Initialize new GD image stream");
$text_color = imagecolorallocate($myImage, 255, 255, 224);
$poly_color = imagecolorallocate($myImage, 124, 120, 224);

//calculate x-value and y-value point by point
$points = array();
for ($i=0; $i<1000; $i=$i+1)
{
    //define curve's function
    $x = 310*cos($i/$T1); //define x-value
    $y = 230*sin($i/$T2);//define y-value
   
    //move the coordinate, append a point's x-value and y-value
    $points[] = 320+$x; //x-value
    $points[] = 240-$y;  //y-value
}

//count points
$totalPoints = count($points)/2;

//drawing title
$title = "Final Plot ($totalPoints points)";
imagestring($myImage, 3, 5, 5,  $title, $text_color);

/** drawing points one by one, notice if there
* are 10 points, we need to draw 9 lines:
* 1) point 0 to 1;
* 2) point 1 to 2;
* ...
* ...
* 9) point 8 to 9;
*/
for ($i=0; $i<$totalPoints-1; $i++)
{
    imageLine($myImage, $points[2*$i], $points[1+2*$i], $points[2+2*$i], 
$points[3+2*$i], $poly_color);   
}

//finalizing
imagepng($myImage);
imagedestroy($myImage);
?>
===============================================================================

An example to draw Amplitude Modulation curve: y = c * sin (x/a) * sin (x/b) .
You can easily modify the codes to create your own oscilloscope application!

<?php
header ("Content-type: image/png");
$myImage = @imagecreatetruecolor(640, 480)
      or die("Cannot Initialize new GD image stream");
$text_color = imagecolorallocate($myImage, 255, 255, 224);
$poly_color = imagecolorallocate($myImage, 124, 120, 224);

//calculate x-value and y-value point by point
$points = array();
for ($i=1; $i<640; $i=$i+1)
{
    //define curve's function
    $x = $i; //define x-value, which is $i itself
    $y = 150*sin($x/80)*sin($x/5);//define y-value
   
    //append a point's x-value and y-value
    $points[] = $x; //x-value
    $points[] = 240-$y;  //y-value
}

//count points
$totalPoints = count($points)/2;

//drawing title
$title = "Final Plot ($totalPoints points)";
imagestring($myImage, 3, 5, 5,  $title, $text_color);

/** drawing points one by one, notice if there
* are 10 points, we need to draw 9 lines:
* 1) point 0 to 1;
* 2) point 1 to 2;
* ...
* ...
* 9) point 8 to 9;
*/
for ($i=0; $i<$totalPoints-1; $i++)
{
    imageLine($myImage, $points[2*$i], $points[1+2*$i], $points[2+2*$i], 
$points[3+2*$i], $poly_color);   
}

//finalizing
imagepng($myImage);
imagedestroy($myImage);
?>
===============================================================================

example of a Simple grid...
bool imagegrid ( resource $image, int $width, int $Height, int $size, mixed
$color )

<?php
Header("Content-type: image/png");
$Width=450;
$Height=450;

$img = ImageCreateTrueColor($Width, $Height);

$bg = imagecolorallocate($img, 255, 255, 255);
imagefill($img, 0, 0, $bg);

$grid = imagecolorallocate($img, 225, 245, 249);

imagesetstyle($img, array($bg, $grid));
imagegrid($img, $Width, $Height, 10, IMG_COLOR_STYLED);
//makegrid($img, $Width, $Height, 10, $grid);

ImagePNG($img);
ImageDestroy($img);

function imagegrid($image, $w, $h, $s, $color)
{
    for($iw=1; $iw<$w/$s; $iw++){imageline($image, $iw*$s, 0, $iw*$s, $w, 
$color);}
    for($ih=1; $ih<$h/$s; $ih++){imageline($image, 0, $ih*$s, $w, $ih*$s, 
$color);}
}
?>
===============================================================================

I've modified the previous entry for drawing on a polar coordinate system to
better represent angles based on a 360º whole circle bearing.

<?php

function imagepolarline($image,$x1,$y1,$length,$angle,$color)
{
    $x2 = $x1 + sin( deg2rad($angle) ) * $length;
    $y2 = $y1 + cos( deg2rad($angle+180) ) * $length;

    imageline($image,$x1,$y1,$x2,$y2,$color);
}

?>
===============================================================================

// Here's a function for drawing a rotated gradient Rectangle (based on a
previous note)

// Create An Image 255x255
$img = ImageCreateTrueColor(255, 255);

GradientRect($img,50,50,80,80,30);

ImagePng($img,"test.png");
ImageDestroy($img);
echo "<br><img src=\"test.png\">";

function GradientRect($img, $x1, $y1, $x2, $y2, $wdt) {
  $alpha = atan2($y2-$y1,$x2-$x1);
  $real_wdt = $wdt*sin($alpha);
  $real_hgt = $wdt*cos($alpha);
  echo "real wdt:".$real_wdt;
  echo "<br>real hgt:".$real_hgt;
  echo "<br>angle: ".($angle*180/pi());
  $plotD = 0;
  $i=0;

  $dy = $real_hgt/$wdt;
  $dx = $real_wdt/$wdt;
  $drgb= 256/$wdt;
  while($i++ < $wdt) {
    // Draw a line and move it down and make it lighter to get the gradient
effect
    ImageLine($img, $x1-$i*$dx, $y1+$i*$dy, $x2-$i*$dx, $y2+$i*$dy,
ImageColorAllocate($img, $i*$drgb, 0, 0));
    ImageLine($img, $x1-$i*$dx+1, $y1+$i*$dy, $x2-$i*$dx+1, $y2+$i*$dy,
ImageColorAllocate($img, $i*$drgb, 0, 0));

  }
}
===============================================================================

This code is used to draw a board of hexagons (for games, classes, etc.)

<?php
//Draws a hexagonal board

// User-defined values
$maxTiles = 7;                    //The number of tiles at the center (widest
part) of the board
$minTiles = 4;                    //The number of tiles at the edges of the
board
$side = 30;                        //The length of the sides of the tiles in
pixels
$bgColor = array(0, 0, 0);        //The background color in RGB format
$fgColor = array(255, 255, 255);//The foreground color in RGB format

//Calculated values
$widthInTiles = range($maxTiles, $minTiles);            //In our example: 7, 6,
5, 4
$rowsInTiles = count($widthInTiles)*2-1;                //the total number of
rows on our board
$xSide = $side*sin(deg2rad(60));                        //the length of the
x-part of the angled sides
$ySide = $side*sin(deg2rad(30));                        //the length of the
y-part of the angled sides
$boardWidth = $xSide*$widthInTiles[0]*2;                //The entire width of
the board
$boardHeight = $rowsInTiles*($side + $ySide) + $ySide;    //The entire height
of the board

// create a blank image and allocate the foreground, background colors
$image = imagecreate($boardWidth, $boardHeight);
$bg = imagecolorallocate($image, $bgColor[0], $bgColor[1], $bgColor[2]);
$fg = imagecolorallocate($image, $fgColor[0], $fgColor[1], $fgColor[2]);

// draw the board
$row = 0;
foreach($widthInTiles as $tiles)
{
    for ($i = 0; $i < $tiles+1; $i++)
    {
        $x1 = $row*$xSide + $i*$xSide*2;
        $y1 = $boardHeight/2;
        $y1Dif = ($side/2) + $row*($side+$ySide);

        $x2 = $x1 + $xSide;
        $y2 = $y1;
        $y2Dif = $ySide;

        $x3 = $x2 + $xSide;

        if ($i < $tiles)
        {
            imageline($image, $x1, $y1 - $y1Dif, $x2, $y2 - $y1Dif - $y2Dif, 
$fg);
            imageline($image,  $x1, $y1 + $y1Dif, $x2, $y2 + $y1Dif + $y2Dif, 
$fg);
            imageline($image, $x2, $y2 - $y1Dif - $y2Dif, $x3, $y1 - $y1Dif, 
$fg);
            imageline($image, $x2, $y2 + $y1Dif + $y2Dif, $x3, $y1 + $y1Dif, 
$fg);
        }
               
        imageline($image, $x1, $y1 - $y1Dif, $x1, $y1 - $y1Dif + $side, $fg); 
         
        imageline($image, $x1, $y1 + $y1Dif, $x1, $y1 + $y1Dif - $side, $fg); 
         
    }
    $row++;
}

// output the picture
header("Content-type: image/png");
imagepng($image);
imagedestroy($image);
?>
===============================================================================

This function draws arrow.

function arrow($im, $x1, $y1, $x2, $y2, $alength, $awidth, $color) {

    $distance = sqrt(pow($x1 - $x2, 2) + pow($y1 - $y2, 2));

    $dx = $x2 + ($x1 - $x2) * $alength / $distance;
    $dy = $y2 + ($y1 - $y2) * $alength / $distance;

    $k = $awidth / $alength;

    $x2o = $x2 - $dx;
    $y2o = $dy - $y2;

    $x3 = $y2o * $k + $dx;
    $y3 = $x2o * $k + $dy;

    $x4 = $dx - $y2o * $k;
    $y4 = $dy - $x2o * $k;

    imageline($im, $x1, $y1, $dx, $dy, $color);
    imageline($im, $x3, $y3, $x4, $y4, $color);
    imageline($im, $x3, $y3, $x2, $y2, $color);
    imageline($im, $x2, $y2, $x4, $y4, $color);

}
===============================================================================

here is a code to draw a "degraded" ... :
<?
header("Content-type : image/jpeg");

$image = @ImageCreate(200, 100)
  or die ("Erreur de cr ation de l'image");

$lignes_colorees = 1;
$couleur_fond = ImageColorAllocate($image, 255, 255, 255);

$rouge_depart = 100;
$vert_depart = 255;
$bleu_depart = 0;

$rouge_fin = 0;
$vert_fin = 100;
$bleu_fin = 0;

$lignes = 100; //nb de lignes de l'image

$vert_diff = $vert_fin - $vert_depart;
$vert1 = $vert_diff / $lignes;

$bleu_diff = $bleu_fin - $bleu_depart;
$bleu1 = $bleu_diff / $lignes;

$rouge_diff = $rouge_fin - $rouge_depart;
$rouge1 = $rouge_diff / $lignes;

while ($lignes_colorees <= 100)
{
    $rouge2 = $lignes_colorees * $rouge1;    $rouge3 = $rouge_depart + $rouge2;
    $rouge = round($rouge3);
   
    $vert2 = $lignes_colorees * $vert1;
    $vert3 = $vert_depart + $vert2;
    $vert = round($vert2);
   
    $bleu2 = $lignes_colorees * $bleu1;
    $bleu3 = $bleu_depart + $bleu2;
    $bleu = round($bleu2);
   
    $y1 = $lignes_colorees;
    $y2 = $lignes_colorees;
    $x1 = 1;    $x2 = 200;
   
    $couleur = ImageColorAllocate($image, $rouge, $vert, $bleu);
    //dessine la ligne
    ImageLine($image, $x1, $y1, $x2, $y2, $couleur);    $lignes_colorees ++;
}

//dessine l'image
ImageJpeg($image);
?>
===============================================================================

Simple function to create border for jpg-images:

function createImageBorder($imgName){

     $img     =  substr($imgName, 0, -4); // remove fileExtension
     $ext     = ".jpg";
     $quality = 95;
     $borderColor = 255;  // 255 = white
    
    /*
     a                         b
     +-------------------------+
     |                         
     |          IMAGE          
     |                         
     +-------------------------+
     c                         d  
    */
   
    $scr_img = imagecreatefromjpeg($img.$ext);
    $width   = imagesx($scr_img);
    $height  = imagesy($scr_img);
             
        // line a - b
        $abX  = 0;
        $abY  = 0;
        $abX1 = $width;
        $abY1 = 0;
       
        // line a - c
        $acX  = 0;
        $acY  = 0;
        $acX1 = 0;
        $acY1 = $height;
       
        // line b - d
        $bdX  = $width-1;
        $bdY  = 0;
        $bdX1 = $width-1;
        $bdY1 = $height;
       
        // line c - d
        $cdX  = 0;
        $cdY  = $height-1;
        $cdX1 = $width;
        $cdY1 = $height-1;
           
       // DRAW LINES   
        imageline($scr_img,$abX,$abY,$abX1,$abY1,$borderColor);
        imageline($scr_img,$acX,$acY,$acX1,$acY1,$borderColor);
        imageline($scr_img,$bdX,$bdY,$bdX1,$bdY1,$borderColor);
        imageline($scr_img,$cdX,$cdY,$cdX1,$cdY1,$borderColor);
       
      // create copy from image   
        imagejpeg($scr_img, $img."_border.jpg", $quality);
        imagedestroy($scr_img);
  }
   
    createImageBorder("myfile.jpg");
===============================================================================

an algorithm to draw a bezier spline

<?php

$segmentos =30;
$x=array(0,10,80,30);
$y=array(0,10,40,50);

function bezier($p,$steps){
    $t = 1 / $steps;
    $temp = $t * $t;
    $ret = array();
    $f = $p[0];
    $fd = 3 * ($p[1] - $p[0]) * $t;
    $fdd_per_2=3*($p[0]-2*$p[1]+$p[2])*$temp;
    $fddd_per_2=3*(3*($p[1]-$p[2])+$p[3]-$p[0])*$temp*$t;
    $fddd = $fddd_per_2 + $fddd_per_2;
    $fdd = $fdd_per_2 + $fdd_per_2;
    $fddd_per_6 = $fddd_per_2 * (1.0 / 3);
    for ($loop=0; $loop<$steps; $loop++) {
        array_push($ret,$f);
        $f = $f + $fd + $fdd_per_2 + $fddd_per_6;
        $fd = $fd + $fdd + $fddd_per_2;
        $fdd = $fdd + $fddd;
        $fdd_per_2 = $fdd_per_2 + $fddd_per_2;
    }
    return $ret;
}

$by = bezier($y,$segmentos);
$bx = bezier($x,$segmentos);
header ("Content-type: image/jpeg");
$tam = 200;
$im = imagecreate($tam,$tam);
$background_color = imagecolorallocate ($im, 200, 200, 200);
$tc = imagecolorallocate ($im, 233, 14, 91);
for($i=0;$i<$segmentos-1;$i++)
    imageline($im,$bx[$i],$tam-$by[$i],$bx[$i+1],$tam-$by[$i+1],$tc);
imagejpeg($im);
imagedestroy($im);
?>
===============================================================================

# antialiased lines with true-type-fonts !?
# yip, it works - not very good - but faster
# (below 3 sec) than other routines (~7 sec)
# i saw here.

# the antialiased effect is minimal and only
# at the top of the line - but, as better as
# nothing ;)

# here is a drawLine routine from Logan Gunthorpe
# (logang at deltatee dot com) posted by nanobot at chipx86 dot com
# on php.net and enhanced/optimized by myself :)

function drawSoftLine ($image, $x1, $y1, $x2, $y2, $r,$g,$b) {

$fontfile="arial.ttf"; # the font for the dot
$str=" " ; # the point_char for the dot
$size=12; # the point for the dot_size

$color = ImageColorAllocate ($image, $r,$g,$b);

if ($x2 == $x1) {
$tmp = $x1; $x1 = $y1; $y1 = $tmp;
$tmp = $x2; $x2 = $y2; $y2 = $tmp;
$swapx = true;
}

$m = (float)(( $y2 - $y1 ) / ( $x2 - $x1 ));
$b = (float)($y1 - $m*$x1);

$strx = min ( $x1 , $x2 );
$endx = max ( $x1 , $x2 );
$x=(int)0;

# the original loop was based on one for_loop
# with the if_swap inside. to speed up this loop
# i double it, to keep off the permanent if_call's.

if (!$swapx) {
for ($x = $strx; $x <= $endx; $x++) {
   $y = (int)($m*$x + $b); 
   imagettftext($image, $size, 0, $x, $y,
   $color, $fontfile,$str);
}
} else {
for ($x = $strx; $x <= $endx; $x++) {
   $y = (int)($m*$x + $b); 
   imagettftext($image, $size, 0, $y, $x,
   $color, $fontfile,$str);
  }
}

}
===============================================================================

Here is a function for making antialiased lines:

function imagesmoothline ( $image , $x1 , $y1 , $x2 , $y2 , $color )
{
  $colors = imagecolorsforindex ( $image , $color );
  if ( $x1 == $x2 )
  {
   imageline ( $image , $x1 , $y1 , $x2 , $y2 , $color ); // Vertical line
  }
  else
  {
   $m = ( $y2 - $y1 ) / ( $x2 - $x1 );
   $b = $y1 - $m * $x1;
   if ( abs ( $m ) <= 1 )
   {
    $x = min ( $x1 , $x2 );
    $endx = max ( $x1 , $x2 );
    while ( $x <= $endx )
    {
     $y = $m * $x + $b;
     $y == floor ( $y ) ? $ya = 1 : $ya = $y - floor ( $y );
     $yb = ceil ( $y ) - $y;
     $tempcolors = imagecolorsforindex ( $image , imagecolorat ( $image , $x ,
floor ( $y ) ) );
     $tempcolors['red'] = $tempcolors['red'] * $ya + $colors['red'] * $yb;
     $tempcolors['green'] = $tempcolors['green'] * $ya + $colors['green'] *
$yb;
     $tempcolors['blue'] = $tempcolors['blue'] * $ya + $colors['blue'] * $yb;
     if ( imagecolorexact ( $image , $tempcolors['red'] , $tempcolors['green']
, $tempcolors['blue'] ) == -1 ) imagecolorallocate ( $image , $tempcolors
['red'] , $tempcolors['green'] , $tempcolors['blue'] );
     imagesetpixel ( $image , $x , floor ( $y ) , imagecolorexact ( $image ,
$tempcolors['red'] , $tempcolors['green'] , $tempcolors['blue'] ) );
     $tempcolors = imagecolorsforindex ( $image , imagecolorat ( $image , $x ,
ceil ( $y ) ) );
     $tempcolors['red'] = $tempcolors['red'] * $yb + $colors['red'] * $ya;
      $tempcolors['green'] = $tempcolors['green'] * $yb + $colors['green'] *
$ya;
     $tempcolors['blue'] = $tempcolors['blue'] * $yb + $colors['blue'] * $ya;
     if ( imagecolorexact ( $image , $tempcolors['red'] , $tempcolors['green']
, $tempcolors['blue'] ) == -1 ) imagecolorallocate ( $image , $tempcolors
['red'] , $tempcolors['green'] , $tempcolors['blue'] );
     imagesetpixel ( $image , $x , ceil ( $y ) , imagecolorexact ( $image ,
$tempcolors['red'] , $tempcolors['green'] , $tempcolors['blue'] ) );
     $x ++;
    }
   }
   else
   {
    $y = min ( $y1 , $y2 );
    $endy = max ( $y1 , $y2 );
    while ( $y <= $endy )
    {
     $x = ( $y - $b ) / $m;
     $x == floor ( $x ) ? $xa = 1 : $xa = $x - floor ( $x );
     $xb = ceil ( $x ) - $x;
     $tempcolors = imagecolorsforindex ( $image , imagecolorat ( $image , floor
( $x ) , $y ) );
     $tempcolors['red'] = $tempcolors['red'] * $xa + $colors['red'] * $xb;
     $tempcolors['green'] = $tempcolors['green'] * $xa + $colors['green'] *
$xb;
     $tempcolors['blue'] = $tempcolors['blue'] * $xa + $colors['blue'] * $xb;
     if ( imagecolorexact ( $image , $tempcolors['red'] , $tempcolors['green']
, $tempcolors['blue'] ) == -1 ) imagecolorallocate ( $image , $tempcolors
['red'] , $tempcolors['green'] , $tempcolors['blue'] );
     imagesetpixel ( $image , floor ( $x ) , $y , imagecolorexact ( $image ,
$tempcolors['red'] , $tempcolors['green'] , $tempcolors['blue'] ) );
     $tempcolors = imagecolorsforindex ( $image , imagecolorat ( $image , ceil
( $x ) , $y ) );
     $tempcolors['red'] = $tempcolors['red'] * $xb + $colors['red'] * $xa;
     $tempcolors['green'] = $tempcolors['green'] * $xb + $colors['green'] *
$xa;
     $tempcolors['blue'] = $tempcolors['blue'] * $xb + $colors['blue'] * $xa;
     if ( imagecolorexact ( $image , $tempcolors['red'] , $tempcolors['green']
, $tempcolors['blue'] ) == -1 ) imagecolorallocate ( $image , $tempcolors
['red'] , $tempcolors['green'] , $tempcolors['blue'] );
     imagesetpixel ( $image , ceil ( $x ) , $y , imagecolorexact ( $image ,
$tempcolors['red'] , $tempcolors['green'] , $tempcolors['blue'] ) );
     $y ++;
    }
   }
  }
}

EDITOR: My previous code contained bugs. Please use this one instead.
===============================================================================

A quick function using imageline that I wrote so i could specify a starting
point, angle and length of vector.

Thought other people might find this useful.

<?php
$size = 600;
$img = imagecreatetruecolor($size, $size);

$white = imagecolorallocate($img, 255, 255, 255);
$black = imagecolorallocate($img, 0, 0, 0);

imagefilledrectangle($img,0,0,$size,$size,$white);

function Vector($palette,$startx,$starty,$angle,$length,$colour){
    $angle = deg2rad($angle);
    $endx = $startx+cos($angle)*$length;
    $endy = $starty-sin($angle)*$length;
    return(imageline($palette,$startx,$starty,$endx,$endy,$colour));
}

Vector($img,$size/2,$size/2,30,200,$black);

header("Content-type: image/png");
imagepng($img);

?>

For this script angles work in a anti-clockwise direction (modify + and - in
function to change start of 0 degrees and also direction of angle calculated)
===============================================================================

Here's another way of modifying likavcan's code to display filled arrows. This
makes use of imagefilledpolygon(...) instead of recursive function calls.

<?php
function arrow($im, $x1, $y1, $x2, $y2, $alength, $awidth, $color) {
    $distance = sqrt(pow($x1 - $x2, 2) + pow($y1 - $y2, 2));

    $dx = $x2 + ($x1 - $x2) * $alength / $distance;
    $dy = $y2 + ($y1 - $y2) * $alength / $distance;

    $k = $awidth / $alength;

    $x2o = $x2 - $dx;
    $y2o = $dy - $y2;

    $x3 = $y2o * $k + $dx;
    $y3 = $x2o * $k + $dy;

    $x4 = $dx - $y2o * $k;
    $y4 = $dy - $x2o * $k;

    imageline($im, $x1, $y1, $dx, $dy, $color);
    imagefilledpolygon($im, array($x2, $y2, $x3, $y3, $x4, $y4), 3, $color);
}
?>
===============================================================================

Here is a function which draws lines that cross at a specific point [It may
need some tweaking]:

<?php
// Image Cross by Matt Evans
// $im - image resource
// $x - x coordinate where the lines should cross
// $y - y coordinate where the lines should cross
// $size - the length of each line
// $colour - the colour of the cross

function imagecross($im, $x, $y, $size = 5, $colour) {
imageline($im, $x+$size/2, $y+$size/2, $x-$size/2, $y-$size/2, $colour);
imageline($im, $x-$size/2, $y+$size, $x+$size/2, $y-$size, $colour);
}

// Example
imagecross($im, 50, 50, 5, $crosscolour);
?>
===============================================================================

<?php
// An easy bit of code showing how you can use the ImageLine() function to
create gradients

// Create An Image 255x255
$img = ImageCreateTrueColor(255, 255);

$plotD = 0;
while($plotD < 256)
{
    // Draw a line and move it down and make it lighter to get the gradient
effect
    ImageLine($img, 0, $plotD , 255, $plotD, ImageColorAllocate($img, $plotD, 
$plotD, $plotD));
    $plotD++;
}
Header("Content-type: image/png");
ImagePng($img);
ImageDestroy($img);
?>
===============================================================================

# antialiased draw_line function 1.1 (faster)

# here is a drawLine() posted by nanobot at chipx86 dot com
# on php.net and enhanced/optimized by myself :)

# here are some changes i made:
# 1. changed for true-color images (no index_var used)
# 2. changed rgb extraction to logical shift
# 3. reducing function call's

function drawQSLine ($image,$x1,$y1,$x2,$y2,$r,$g,$b) {
$icr=$r;
$icg=$g;
$icb=$b;
$dcol = ImageColorAllocate ($image,$icr,$icg,$icb);
if ($y1 == $y2) imageline ($image,$x1,$y1,$x2,$y1,$dcol);
else if ($x1 == $x2) { 
   imageline ($image,$x1,$y1,$x1,$y2,$dcol);
} else {
$m = ($y2 - $y1) / ($x2 - $x1);
$b = $y1 - $m * $x1;

if (abs ($m) <2) {

$x = min ($x1,$x2);
$endx = max ($x1,$x2)+1;

while ($x < $endx) {
$y=$m * $x + $b;
$y == floor ($y) ? $ya = 1 : $ya = $y - floor ($y);
$yb = ceil ($y) - $y;

$trgb = ImageColorAt($image,$x,floor($y));
$tcr = ($trgb >> 16) & 0xFF;
$tcg = ($trgb >> 8) & 0xFF;
$tcb = $trgb & 0xFF;
imagesetpixel ($image,$x,floor ($y),imagecolorallocate ($image,($tcr * $ya +
$icr * $yb),
($tcg * $ya + $icg * $yb),
($tcb * $ya + $icb * $yb)));

$trgb = ImageColorAt($image,$x,ceil($y));
$tcr = ($trgb >> 16) & 0xFF;
$tcg = ($trgb >> 8) & 0xFF;
$tcb = $trgb & 0xFF;
imagesetpixel ($image,$x,ceil ($y),imagecolorallocate ($image,($tcr * $yb +
$icr * $ya),
($tcg * $yb + $icg * $ya),
($tcb * $yb + $icb * $ya)));

$x ++;
} # while_x_end
} # if_end
else { # else_abs_end

$y = min ($y1,$y2);
$endy = max ($y1,$y2)+1;

while ($y < $endy) {
$x=($y - $b) / $m;
$x == floor ($x) ? $xa = 1 : $xa = $x - floor ($x);
$xb = ceil ($x) - $x;

$trgb = ImageColorAt($image,floor($x),$y);
$tcr = ($trgb >> 16) & 0xFF;
$tcg = ($trgb >> 8) & 0xFF;
$tcb = $trgb & 0xFF;
imagesetpixel ($image,floor ($x),$y,imagecolorallocate ($image,($tcr * $xa +
$icr * $xb),
($tcg * $xa + $icg * $xb),
($tcb * $xa + $icb * $xb)));

$trgb = ImageColorAt($image,ceil($x),$y);
$tcr = ($trgb >> 16) & 0xFF;
$tcg = ($trgb >> 8) & 0xFF;
$tcb = $trgb & 0xFF;
imagesetpixel ($image,ceil ($x),$y,imagecolorallocate ($image, ($tcr * $xb +
$icr * $xa),
($tcg * $xb + $icg * $xa),
($tcb * $xb + $icb * $xa)));

$y ++;
}# while_y_end
}# else_abs_end
}# else_y=y_x=x_end
}# drawOSLine_end
===============================================================================

imageline coordinate variables are documented as int ,  a value in decimal
format will be truncated.

This may be useful when, for example, applying a non-integer scaling factor in
generating an image.

Care should be taken to ensure this does not create significant errors that
affect the quality of the image. For example :

<?php
$x=0.00000000001;$y=100;
imageline($img,0,0,0,$y+$x);
imageline($img,0,0,0,$y-$x);
?>

the first line will be straight , the second will have a step. Use round()
where appropriate.
===============================================================================

Some simple code to draw lines with specific thickness using
"imagefilledpolygon". Useful if your gdlib does not support
"imagesetthickness".

<?
function dickelinie($img,$start_x,$start_y,$end_x,$end_y,$color,$thickness)
{
    $angle=(atan2(($start_y - $end_y),($end_x - $start_x)));

    $dist_x=$thickness*(sin($angle));
    $dist_y=$thickness*(cos($angle));
   
    $p1x=ceil(($start_x + $dist_x));
    $p1y=ceil(($start_y + $dist_y));
    $p2x=ceil(($end_x + $dist_x));
    $p2y=ceil(($end_y + $dist_y));
    $p3x=ceil(($end_x - $dist_x));
    $p3y=ceil(($end_y - $dist_y));
    $p4x=ceil(($start_x - $dist_x));
    $p4y=ceil(($start_y - $dist_y));
   
    $array=array(0=>$p1x,$p1y,$p2x,$p2y,$p3x,$p3y,$p4x,$p4y);
    imagefilledpolygon ( $img, $array, (count($array)/2), $color );
}
// Example:
header ("Content-type: image/jpeg");
$img = ImageCreate (210, 210) or die("Cannot Initialize new GD image stream ");
$backgroundcolor = ImageColorAllocate ($img, 255, 255, 255);
$orange = ImageColorAllocate($img, 252, 102, 4);
dickelinie($img, 10, 10, 10, 200,$orange,2);
dickelinie($img, 10, 200, 200, 10,$orange,2);   
dickelinie($img, 200, 10, 200, 200,$orange,2);
imagejpeg($img);  
ImageDestroy($img);

?>
===============================================================================

Script to draw a grid of lines, which make the entire side of the picture look
like a quarter circle.. very cool :)
<?php
$img_disp = imagecreate(1000,1000);
$backcolor = imagecolorallocate($img_disp,0,0,0);
imagefill($img_disp,0,0,$backcolor);
$textcolor = imagecolorallocate($img_disp,255,0,0);
$x1 = 0;
$y1 = 0;
$x2 = 0;
$y2 = 1000;
for(;;){
$y1 = $y1 + 20;
$x2 = $x2 + 20;
imageline($img_disp,$x1,$y1,$x2,$y2,$textcolor);
if ($y1 == 1000){
break;
}
}
header("Content-type: image/png");
imagepng($img_disp); // Draw the image
imagedestroy($img_disp); // Delete the image from the server's memory
?>
===============================================================================

Function drawing of a line by a brush uses midpoint circle algorithm..., if
dullness I agree to remove :)))

<?php
//function drawLine(resource$image,int $x0,int $y0,int $x1,int $y1,int
$lineWidth,int $color)
function drawLine($image,$x0, $y0,$x1, $y1,$radius,$color)
{
  $f = 1 - $radius;
  $ddF_x= 1;
  $ddF_y = -2 * $radius;
  $x= 0;
  $y = $radius;
    imageline($image,$x0, $y0 + $radius,$x1, $y1 + $radius,$color);
     imageline($image,$x0, $y0 - $radius,$x1, $y1 - $radius,$color);
    imageline($image,$x0 + $radius, $y0,$x1 + $radius, $y1,$color);
    imageline($image,$x0 - $radius, $y0,$x1 - $radius, $y1,$color);

  while($x< $y)
  {
    if($f >= 0)
    {
      $y--;
      $ddF_y += 2;
      $f += $ddF_y;
    }
    $x++;
    $ddF_x+= 2;
    $f += $ddF_x;
    imageline($image,$x0 + $x, $y0 + $y,$x1 + $x, $y1+ $y,$color);
       imageline($image,$x0 - $x, $y0 + $y,$x1 - $x, $y1 + $y,$color);
       imageline($image,$x0 + $x, $y0 - $y,$x1 + $x, $y1 - $y,$color);
       imageline($image,$x0 - $x, $y0 - $y,$x1 - $x, $y1 - $y,$color);
       imageline($image,$x0 + $y, $y0 + $x,$x1 + $y, $y1 + $x,$color);
       imageline($image,$x0 - $y, $y0 + $x,$x1 - $y, $y1 + $x,$color);
       imageline($image,$x0 + $y, $y0 - $x,$x1 + $y, $y1 - $x,$color);
       imageline($image,$x0 - $y, $y0 - $x,$x1 - $y, $y1 - $x,$color);

  }
}
header ('Content-type: image/png');
$img = imagecreatetruecolor(600,600);
$col = imagecolorallocate($img,0,255,252);
//use the function
rasterCircle($img,50, 50,540,540,40,$col);
imagepng($img);
imagedestroy($img);
?>
===============================================================================

I've modified the Arrow function of likavcan.

This arrowFunction draws the arrow filled :

<?php
function arrow($im, $x1, $y1, $x2, $y2, $alength, $awidth, $color) {

    if( $alength > 1 )
        arrow( $im, $x1, $y1, $x2, $y2, $alength - 1, $awidth - 1, $color );

    $distance = sqrt(pow($x1 - $x2, 2) + pow($y1 - $y2, 2));

    $dx = $x2 + ($x1 - $x2) * $alength / $distance;
    $dy = $y2 + ($y1 - $y2) * $alength / $distance;

    $k = $awidth / $alength;

    $x2o = $x2 - $dx;
    $y2o = $dy - $y2;

    $x3 = $y2o * $k + $dx;
    $y3 = $x2o * $k + $dy;

    $x4 = $dx - $y2o * $k;
    $y4 = $dy - $x2o * $k;

    imageline($im, $x1, $y1, $dx, $dy, $color);
    imageline($im, $x3, $y3, $x4, $y4, $color);
    imageline($im, $x3, $y3, $x2, $y2, $color);
    imageline($im, $x2, $y2, $x4, $y4, $color);

}
?>
===============================================================================

It does work (With a bit of editing)
save the following as graph.php (You dont need any directorys)

<?php
Header("Content-type: image/png");
$picWidth=360*2;
$picHeight=200;
$pic=ImageCreate($picWidth+1,$picHeight+1);
$cWhite=ImageColorAllocate($pic,255,255,255);
ImageFilledRectangle($pic,0,0,$picWidth+1,$picHeight+1,$cWhite);
$cRed=ImageColorAllocate($pic,255,0,0);
$cBlue=ImageColorAllocate($pic,0,0,255);
$curX=0;
$curY=$picHeight;
for($pt=0;$pt<$picWidth;$pt++){
$newX=$curX+1;
$newY=($picHeight/2)+(cos(deg2rad($newX))*($picHeight/2));
ImageLine($pic,$curX,$curY,$newX,$newY,$cRed);
$curX=$newX;
$curY=$newY;
}
$curX=0;
$curY=$picHeight/2;
for($pt=0;$pt<$picWidth;$pt++){
$newX=$curX+1;
$newY=($picHeight/2)+(sin(deg2rad($newX))*($picHeight/2));
ImageLine($pic,$curX,$curY,$newX,$newY,$cBlue);
$curX=$newX;
$curY=$newY;
}
$cBlack=ImageColorAllocate($pic,0,0,0);
ImageLine($pic,0,0,0,$picHeight,$cBlack);
ImageLine($pic,0,$picHeight/2,$picWidth,$picHeight/2,$cBlack);
ImagePNG($pic);
ImageDestroy($pic);
?>
