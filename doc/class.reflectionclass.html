
ReflectionClass 类

(PHP 5, PHP 7)

简介

ReflectionClass 类报告了一个类的有关信息。

类摘要

ReflectionClass implements Reflector {
/* 常量 */
const integer IS_IMPLICIT_ABSTRACT = 16 ;
const integer IS_EXPLICIT_ABSTRACT = 32 ;
const integer IS_FINAL = 64 ;
/* 属性 */
public $name ;
/* 方法 */
public __construct ( mixed $argument )
public static string export ( mixed $argument [, bool $return = false ] )
public mixed getConstant ( string $name )
public array getConstants ( void )
public ReflectionMethod getConstructor ( void )
public array getDefaultProperties ( void )
public string getDocComment ( void )
public int getEndLine ( void )
public ReflectionExtension getExtension ( void )
public string getExtensionName ( void )
public string getFileName ( void )
public array getInterfaceNames ( void )
public array getInterfaces ( void )
public ReflectionMethod getMethod ( string $name )
public array getMethods ([ int $filter ] )
public int getModifiers ( void )
public string getName ( void )
public string getNamespaceName ( void )
public object getParentClass ( void )
public array getProperties ([ int $filter ] )
public ReflectionProperty getProperty ( string $name )
public string getShortName ( void )
public int getStartLine ( void )
public array getStaticProperties ( void )
public mixed getStaticPropertyValue ( string $name [, mixed &$def_value ] )
public array getTraitAliases ( void )
public array getTraitNames ( void )
public array getTraits ( void )
public bool hasConstant ( string $name )
public bool hasMethod ( string $name )
public bool hasProperty ( string $name )
public bool implementsInterface ( string $interface )
public bool inNamespace ( void )
public bool isAbstract ( void )
public bool isAnonymous ( void )
public bool isCloneable ( void )
public bool isFinal ( void )
public bool isInstance ( object $object )
public bool isInstantiable ( void )
public bool isInterface ( void )
public bool isInternal ( void )
public bool isIterateable ( void )
public bool isSubclassOf ( string $class )
public bool isTrait ( void )
public bool isUserDefined ( void )
public object newInstance ( mixed $args [, mixed $... ] )
public object newInstanceArgs ([ array $args ] )
public object newInstanceWithoutConstructor ( void )
public void setStaticPropertyValue ( string $name , string $value )
public string __toString ( void )
}

属性

name

    类的名称。只读，并在尝试赋值的时候会抛出 ReflectionException。

预定义常量

ReflectionClass 修饰符

ReflectionClass::IS_IMPLICIT_ABSTRACT

    指示了类是一个抽象类（abstract），因为它有抽象（abstract）方法。

ReflectionClass::IS_EXPLICIT_ABSTRACT

    指示了类是一个抽象类（abstract），因为它已明确定义。

ReflectionClass::IS_FINAL

    指示这是一个 final 类。

Table of Contents

  • ReflectionClass::__construct — 构造一个 ReflectionClass 类
  • ReflectionClass::export — 导出一个类
  • ReflectionClass::getConstant — 获取定义过的一个常量
  • ReflectionClass::getConstants — 获取一组常量
  • ReflectionClass::getConstructor — 获取类的构造函数
  • ReflectionClass::getDefaultProperties — 获取默认属性
  • ReflectionClass::getDocComment — 获取文档注释
  • ReflectionClass::getEndLine — 获取最后一行的行数
  • ReflectionClass::getExtension — 根据已定义的类获取所在扩展的
    ReflectionExtension 对象
  • ReflectionClass::getExtensionName — 获取定义的类所在的扩展的名称
  • ReflectionClass::getFileName — 获取定义类的文件名
  • ReflectionClass::getInterfaceNames — 获取接口（interface）名称
  • ReflectionClass::getInterfaces — 获取接口
  • ReflectionClass::getMethod — 获取一个类方法的 ReflectionMethod。
  • ReflectionClass::getMethods — 获取方法的数组
  • ReflectionClass::getModifiers — 获取修饰符
  • ReflectionClass::getName — 获取类名
  • ReflectionClass::getNamespaceName — 获取命名空间的名称
  • ReflectionClass::getParentClass — 获取父类
  • ReflectionClass::getProperties — 获取一组属性
  • ReflectionClass::getProperty — 获取类的一个属性的 ReflectionProperty
  • ReflectionClass::getShortName — 获取短名
  • ReflectionClass::getStartLine — 获取起始行号
  • ReflectionClass::getStaticProperties — 获取静态（static）属性
  • ReflectionClass::getStaticPropertyValue — 获取静态（static）属性的值
  • ReflectionClass::getTraitAliases — 返回 trait 别名的一个数组
  • ReflectionClass::getTraitNames — 返回这个类所使用 traits 的名称的数组
  • ReflectionClass::getTraits — 返回这个类所使用的 traits 数组
  • ReflectionClass::hasConstant — 检查常量是否已经定义
  • ReflectionClass::hasMethod — 检查方法是否已定义
  • ReflectionClass::hasProperty — 检查属性是否已定义
  • ReflectionClass::implementsInterface — 接口的实现
  • ReflectionClass::inNamespace — 检查是否位于命名空间中
  • ReflectionClass::isAbstract — 检查类是否是抽象类（abstract）
  • ReflectionClass::isAnonymous — 检查类是否是匿名类
  • ReflectionClass::isCloneable — 返回了一个类是否可复制
  • ReflectionClass::isFinal — 检查类是否声明为 final
  • ReflectionClass::isInstance — 检查类的实例
  • ReflectionClass::isInstantiable — 检查类是否可实例化
  • ReflectionClass::isInterface — 检查类是否是一个接口（interface）
  • ReflectionClass::isInternal — 检查类是否由扩展或核心在内部定义
  • ReflectionClass::isIterateable — 检查是否可迭代（iterateable）
  • ReflectionClass::isSubclassOf — 检查是否为一个子类
  • ReflectionClass::isTrait — 返回了是否为一个 trait
  • ReflectionClass::isUserDefined — 检查是否由用户定义的
  • ReflectionClass::newInstance — 从指定的参数创建一个新的类实例
  • ReflectionClass::newInstanceArgs — 从给出的参数创建一个新的类实例。
  • ReflectionClass::newInstanceWithoutConstructor — 创建一个新的类实例而不调用
    它的构造函数
  • ReflectionClass::setStaticPropertyValue — 设置静态属性的值
  • ReflectionClass::__toString — 返回 ReflectionClass 对象字符串的表示形式。


User Contributed Notes 4 notes

===============================================================================

To reflect on a namespaced class in PHP 5.3, you must always specify the fully
qualified name of the class - even if you've aliased the containing namespace
using a "use" statement.

So instead of:

<?php
use App\Core as Core;
$oReflectionClass = new ReflectionClass('Core\Singleton');
?>

You would type:

<?php
use App\Core as Core;
$oReflectionClass = new ReflectionClass('App\Core\Singleton');
?>
===============================================================================

Reflecting an alias will give you a reflection of the resolved class.

<?php

class X {
   
}

class_alias('X','Y');
class_alias('Y','Z');
$z = new ReflectionClass('Z');
echo $z->getName(); // X

?>
===============================================================================

Unserialized reflection class cause error.

<?php
/**
* abc
*/
class a{}

$ref = new ReflectionClass('a');
$ref = unserialize(serialize($ref));
var_dump($ref);
var_dump($ref->getDocComment());

// object(ReflectionClass)#2 (1) {
//   ["name"]=>
//   string(1) "a"
// }
// PHP Fatal error:  ReflectionClass::getDocComment(): Internal error: Failed
to retrieve the reflection object
?>
===============================================================================

It is also possible to do reflection from within the class and get the methods
for instance.

<?php

class test
{
    private $test = "";

    public function setTest($test)
    {
        $this->test = $test;
        return $this;
    }

    public function getTest()
    {
        return $this->test;
    }
   
    public function run(){
        $class = new ReflectionClass('test');
        $methods = $class->getMethods();
        var_dump($methods);
    }
}

Called from another php file you get the proper result:
array(3) {
  [0]=>
  &object(ReflectionMethod)#3 (2) {
    ["name"]=>
    string(8) "setTest"
    ["class"]=>
    string(4) "test"
  }
  [1]=>
  &object(ReflectionMethod)#4 (2) {
    ["name"]=>
    string(8) "getTest"
    ["class"]=>
    string(4) "test"
  }
  [2]=>
  &object(ReflectionMethod)#5 (2) {
    ["name"]=>
    string(3) "run"
    ["class"]=>
    string(4) "test"
  }
}
