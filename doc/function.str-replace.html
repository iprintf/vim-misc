
str_replace

(PHP 4, PHP 5, PHP 7)

str_replace — 子字符串替换

说明

mixed str_replace ( mixed $search , mixed $replace , mixed $subject [, int &
$count ] )

该函数返回一个字符串或者数组。该字符串或数组是将 subject 中全部的 search 都被
replace 替换之后的结果。

如果没有一些特殊的替换需求（比如正则表达式），你应该使用该函数替换 ereg_replace
() 和 preg_replace()。

参数

如果 search 和 replace 为数组，那么 str_replace() 将对 subject 做二者的映射替换
。如果 replace 的值的个数少于 search 的个数，多余的替换将使用空字符串来进行。如
果 search 是一个数组而 replace 是一个字符串，那么 search 中每个元素的替换将始终
使用这个字符串。该转换不会改变大小写。

如果 search 和 replace 都是数组，它们的值将会被依次处理。

search

    查找的目标值，也就是 needle。一个数组可以指定多个目标。

replace

    search 的替换值。一个数组可以被用来指定多重替换。

subject

    执行替换的数组或者字符串。也就是 haystack。

    如果 subject 是一个数组，替换操作将遍历整个 subject，返回值也将是一个数组。

count

    如果被指定，它的值将被设置为替换发生的次数。

返回值

该函数返回替换后的数组或者字符串。

范例

Example #1 str_replace() 基本范例

<?php
// 赋值: <body text='black'>
$bodytag = str_replace("%body%", "black", "<body text='%body%'>");

// 赋值: Hll Wrld f PHP
$vowels = array("a", "e", "i", "o", "u", "A", "E", "I", "O", "U");
$onlyconsonants = str_replace($vowels, "", "Hello World of PHP");

// 赋值: You should eat pizza, beer, and ice cream every day
$phrase  = "You should eat fruits, vegetables, and fiber every day.";
$healthy = array("fruits", "vegetables", "fiber");
$yummy   = array("pizza", "beer", "ice cream");

$newphrase = str_replace($healthy, $yummy, $phrase);

// 赋值: 2
$str = str_replace("ll", "", "good golly miss molly!", $count);
echo $count;
?>

Example #2 可能的 str_replace() 替换范例

<?php
// 替换顺序
$str     = "Line 1\nLine 2\rLine 3\r\nLine 4\n";
$order   = array("\r\n", "\n", "\r");
$replace = '<br />';

// 首先替换 \r\n 字符，因此它们不会被两次转换
$newstr = str_replace($order, $replace, $str);

// 输出 F ，因为 A 被 B 替换，B 又被 C 替换，以此类推...
// 由于从左到右依次替换，最终 E 被 F 替换
$search  = array('A', 'B', 'C', 'D', 'E');
$replace = array('B', 'C', 'D', 'E', 'F');
$subject = 'A';
echo str_replace($search, $replace, $subject);

// 输出: apearpearle pear
// 由于上面提到的原因
$letters = array('a', 'p');
$fruit   = array('apple', 'pear');
$text    = 'a p';
$output  = str_replace($letters, $fruit, $text);
echo $output;
?>

注释

    Note: 此函数可安全用于二进制对象。

Caution

了解替换顺序

由于 str_replace() 的替换时从左到右依次进行的，进行多重替换的时候可能会替换掉之
前插入的值。参见该文档的范例。

    Note:

    该函数区分大小写。使用 str_ireplace() 可以进行不区分大小写的替换。

参见

  • str_ireplace() - str_replace 的忽略大小写版本
  • substr_replace() - 替换字符串的子串
  • preg_replace() - 执行一个正则表达式的搜索和替换
  • strtr() - 转换指定字符


User Contributed Notes 41 notes

===============================================================================

A faster way to replace the strings in multidimensional array is to json_encode
() it, do the str_replace() and then json_decode() it, like this:

<?php
function str_replace_json($search, $replace, $subject){
     return json_decode(str_replace($search, $replace,  json_encode($subject
)));

}
?>

This method is almost 3x faster (in 10000 runs.) than using recursive calling
and looping method, and 10x simpler in coding.

Compared to:

<?php
function str_replace_deep($search, $replace, $subject)
{
    if (is_array($subject))
    {
        foreach($subject as &$oneSubject)
            $oneSubject = str_replace_deep($search, $replace, $oneSubject);
        unset($oneSubject);
        return $subject;
    } else {
        return str_replace($search, $replace, $subject);
    }
}
?>
===============================================================================

jSON Turkish Characters Problem - (PHP < 5.4 for example)

<?php
function json_decode_tr($json){
       $json_char = array("u00e7","u0131","u00fc","u011f","u00f6","u015f",
"u0130","u011e","u00dc","u00d6","u015e","u00c7");
       $turkish = array("ç","ı","ü","ğ","ö","ş","İ","Ğ","Ü","Ö","Ş","Ç");
       $result = str_replace($json_char, $turkish, $json);
       return json_decode($json);
    }
?>
===============================================================================

Feel free to optimize this using the while/for or anything else, but this is a
bit of code that allows you to replace strings found in an associative array.

For example:
<?php
$replace = array(
'dog' => 'cat',
'apple' => 'orange'
'chevy' => 'ford'
);

$string = 'I like to eat an apple with my dog in my chevy';

echo str_replace_assoc($replace,$string);

// Echo: I like to eat an orange with my cat in my ford
?>

Here is the function:

<?php
function strReplaceAssoc(array $replace, $subject) {
   return str_replace(array_keys($replace), array_values($replace), $subject); 
 
}
?>

[Jun 1st, 2010 - EDIT BY thiago AT php DOT net: Function has been replaced with
an updated version sent by ljelinek AT gmail DOT com]
===============================================================================

Be careful when replacing characters (or repeated patterns in the FROM and TO
arrays):

For example:

<?php
$arrFrom = array("1","2","3","B");
$arrTo = array("A","B","C","D");
$word = "ZBB2";
echo str_replace($arrFrom, $arrTo, $word);
?>

I would expect as result: "ZDDB"
However, this return: "ZDDD"
(Because B = D according to our array)

To make this work, use "strtr" instead:

<?php
$arr = array("1" => "A","2" => "B","3" => "C","B" => "D");
$word = "ZBB2";
echo strtr($word,$arr);
?>

This returns: "ZDDB"
===============================================================================

Note that this does not replace strings that become part of replacement
strings. This may be a problem when you want to remove multiple instances of
the same repetative pattern, several times in a row.

If you want to remove all dashes but one from the string
'-aaa----b-c-----d--e---f' resulting in '-aaa-b-c-d-e-f', you cannot use
str_replace. Instead, use preg_replace:

<?php
$challenge = '-aaa----b-c-----d--e---f';
echo str_replace('--', '-', $challenge).'<br>';
echo preg_replace('/--+/', '-', $challenge).'<br>';
?>

This outputs the following:
-aaa--b-c---d-e--f
-aaa-b-c-d-e-f
===============================================================================

This strips out horrible MS word characters.

Just keep fine tuning it until you get what you need, you'll see ive commented
some out which caused problems for me.

There could be some that need adding in, but its a start to anyone who wishes
to make their own custom function.

<?php

function msword_conversion($str)
{
$str = str_replace(chr(130), ',', $str);    // baseline single quote
$str = str_replace(chr(131), 'NLG', $str);  // florin
$str = str_replace(chr(132), '"', $str);    // baseline double quote
$str = str_replace(chr(133), '...', $str);  // ellipsis
$str = str_replace(chr(134), '**', $str);   // dagger (a second footnote)
$str = str_replace(chr(135), '***', $str);  // double dagger (a third footnote)
$str = str_replace(chr(136), '^', $str);    // circumflex accent
$str = str_replace(chr(137), 'o/oo', $str); // permile
$str = str_replace(chr(138), 'Sh', $str);   // S Hacek
$str = str_replace(chr(139), '<', $str);    // left single guillemet
// $str = str_replace(chr(140), 'OE', $str);   // OE ligature
$str = str_replace(chr(145), "'", $str);    // left single quote
$str = str_replace(chr(146), "'", $str);    // right single quote
// $str = str_replace(chr(147), '"', $str);    // left double quote
// $str = str_replace(chr(148), '"', $str);    // right double quote
$str = str_replace(chr(149), '-', $str);    // bullet
$str = str_replace(chr(150), '-–', $str);    // endash
$str = str_replace(chr(151), '--', $str);   // emdash
// $str = str_replace(chr(152), '~', $str);    // tilde accent
// $str = str_replace(chr(153), '(TM)', $str); // trademark ligature
$str = str_replace(chr(154), 'sh', $str);   // s Hacek
$str = str_replace(chr(155), '>', $str);    // right single guillemet
// $str = str_replace(chr(156), 'oe', $str);   // oe ligature
$str = str_replace(chr(159), 'Y', $str);    // Y Dieresis
$str = str_replace('°C', '&deg;C', $str);    // Celcius is used quite a lot so
it makes sense to add this in
$str = str_replace('£', '&pound;', $str);
$str = str_replace("'", "'", $str);
$str = str_replace('"', '"', $str);
$str = str_replace('–', '&ndash;', $str);

return $str;
}

?>
===============================================================================

Might be worth mentioning that a SIMPLE way to accomplish Example 2 (potential
gotchas) is to simply start your "replacements" in reverse.

So instead of starting from "A" and ending with "E":

<?php
$search  = array('A', 'B', 'C', 'D', 'E');
$replace = array('B', 'C', 'D', 'E', 'F');
// replaces A to B, B to C, C to D, D to E, E to F (makes them all F)
// start from "E" and end with "A":

$search  = array('E', 'D', 'C', 'B', 'A');
$replace = array('F', 'E', 'D', 'C', 'B');
// replaces E to F, D to E, C to D, B to C, A to B (prevents from
// multiple replacements of already replaced values)
?>

So basically start from the "end" and put the replacements in an order where
the "replaced value" won't equal a value that exists later in the "search
array".
===============================================================================

I was working with MySQL and displaying the title to things on the web page. 
I'd written a script to ensure single and double quotes were removed from the
title.  I used

    $title = str_replace( "'", "", $title );

and

     $title = str_replace( '"', "", $title );

But still the single and double quotes continued.  So I wrote a bit of code to
print out each character separated by a dash.  Like so:

     for( $i=0; $i<strlen($title); $i++ ){
         echo "$i-";
         }

     echo "<br>\n";

This displayed:

     m-y-c-o-m-p-a-n-y- b-b-&-#-3-9-;-s

Which made me go "Oh!  I get it."

The MySQL function real_escape_string modifies the single quotes to be &#39;
and double quotes as &#34;  These still show up as single and double quotes
under HTML and most importantly -

     JAVASCRIPT sees the &#34; and &#39; as actual single or double
     quotes.  So if you are passing arguments to a function you have
     to get rid of them or else you will get an error on trying to call
     a given function.  Example:

     <a href="javascript:func1('mycompany bbs&#39;s")'">

     becomes

     <a href="javascript:func1('mycompany bbs's');">

Which then will give you an error because there is a single quote inside of the
single quoted string.  HOWEVER, the

     $title = str_replace( "'", "", $title );

WILL NOT FIND a single quote.  Instead, you have to do this:

     $title = str_replace( "&#39;", "'", $title );
and
     $title = str_relace( "&#34;", '"', $title );

(Or you could just get rid of them.)

So remember!  If you are trying to remove single and double quotes and are
using MySQL and MySQL's real_escape_string() function that you might be having
single and double quotes hanging around which are defined as &#39; and &#34;
but which show up as single and double quotes as well as causing problems in
your Javascripts.
===============================================================================

Here's a deep replace function allowing multi-dimensional arrays in $search,
$replace and $subject. The keys and other structure of $subject are preserved.

<?php
// Auxiliary function:
function _replaceWithAnything($search,$replace,$subject){
  if(!is_array($search) || !is_array($replace)){
    $search=array($search);
    $replace=array($replace);
  }
  $match=array_search($subject,$search,true);
  if($match!==false && array_key_exists($match,$replace))
    $subject=$replace[$match];
  return $subject;
}

// Main function:
function deepReplace($search,$replace,$subject){
  if(!is_array($subject))
    return _replaceWithAnything($search,$replace,$subject);
  foreach($subject as &$val){
    if(is_array($val)){
      $val=deepReplace($search,$replace,$val);
      continue;
    }
    $val=_replaceWithAnything($search,$replace,$val);
  }
  return $subject;
}
?>
===============================================================================

<?php

/**
* Convert foreign 8859-1 characters into HTML entities.
*
* @param string $str
*   The string being parsed.
*
* @return string
*   The converted string.
*/
public static function convert_chars_to_entities( $str )
{
    $str = str_replace( 'À', '&#192;', $str );
    $str = str_replace( 'Á', '&#193;', $str );
    $str = str_replace( 'Â', '&#194;', $str );
    $str = str_replace( 'Ã', '&#195;', $str );
    $str = str_replace( 'Ä', '&#196;', $str );
    $str = str_replace( 'Å', '&#197;', $str );
    $str = str_replace( 'Æ', '&#198;', $str );
    $str = str_replace( 'Ç', '&#199;', $str );
    $str = str_replace( 'È', '&#200;', $str );
    $str = str_replace( 'É', '&#201;', $str );
    $str = str_replace( 'Ê', '&#202;', $str );
    $str = str_replace( 'Ë', '&#203;', $str );
    $str = str_replace( 'Ì', '&#204;', $str );
    $str = str_replace( 'Í', '&#205;', $str );
    $str = str_replace( 'Î', '&#206;', $str );
    $str = str_replace( 'Ï', '&#207;', $str );
    $str = str_replace( 'Ð', '&#208;', $str );
    $str = str_replace( 'Ñ', '&#209;', $str );
    $str = str_replace( 'Ò', '&#210;', $str );
    $str = str_replace( 'Ó', '&#211;', $str );
    $str = str_replace( 'Ô', '&#212;', $str );
    $str = str_replace( 'Õ', '&#213;', $str );
    $str = str_replace( 'Ö', '&#214;', $str );
    $str = str_replace( '×', '&#215;', $str );  // Yeah, I know.  But otherwise
the gap is confusing.  --Kris
    $str = str_replace( 'Ø', '&#216;', $str );
    $str = str_replace( 'Ù', '&#217;', $str );
    $str = str_replace( 'Ú', '&#218;', $str );
    $str = str_replace( 'Û', '&#219;', $str );
    $str = str_replace( 'Ü', '&#220;', $str );
    $str = str_replace( 'Ý', '&#221;', $str );
    $str = str_replace( 'Þ', '&#222;', $str );
    $str = str_replace( 'ß', '&#223;', $str );
    $str = str_replace( 'à', '&#224;', $str );
    $str = str_replace( 'á', '&#225;', $str );
    $str = str_replace( 'â', '&#226;', $str );
    $str = str_replace( 'ã', '&#227;', $str );
    $str = str_replace( 'ä', '&#228;', $str );
    $str = str_replace( 'å', '&#229;', $str );
    $str = str_replace( 'æ', '&#230;', $str );
    $str = str_replace( 'ç', '&#231;', $str );
    $str = str_replace( 'è', '&#232;', $str );
    $str = str_replace( 'é', '&#233;', $str );
    $str = str_replace( 'ê', '&#234;', $str );
    $str = str_replace( 'ë', '&#235;', $str );
    $str = str_replace( 'ì', '&#236;', $str );
    $str = str_replace( 'í', '&#237;', $str );
    $str = str_replace( 'î', '&#238;', $str );
    $str = str_replace( 'ï', '&#239;', $str );
    $str = str_replace( 'ð', '&#240;', $str );
    $str = str_replace( 'ñ', '&#241;', $str );
    $str = str_replace( 'ò', '&#242;', $str );
    $str = str_replace( 'ó', '&#243;', $str );
    $str = str_replace( 'ô', '&#244;', $str );
    $str = str_replace( 'õ', '&#245;', $str );
    $str = str_replace( 'ö', '&#246;', $str );
    $str = str_replace( '÷', '&#247;', $str );  // Yeah, I know.  But otherwise
the gap is confusing.  --Kris
    $str = str_replace( 'ø', '&#248;', $str );
    $str = str_replace( 'ù', '&#249;', $str );
    $str = str_replace( 'ú', '&#250;', $str );
    $str = str_replace( 'û', '&#251;', $str );
    $str = str_replace( 'ü', '&#252;', $str );
    $str = str_replace( 'ý', '&#253;', $str );
    $str = str_replace( 'þ', '&#254;', $str );
    $str = str_replace( 'ÿ', '&#255;', $str );
   
    return $str;
}
?>
===============================================================================

As an effort to remove those Word copy and paste smart quotes, I've found that
this works with UTF8 encoded strings (where $text in the following example is
UTF8). Also the elipsis and em and en dashes are replaced.

There is an "invisible" character after the â€ for the right side double smart
quote that doesn't seem to display here. It is chr(157).

<?php
  $find[] = 'â€œ';  // left side double smart quote
  $find[] = 'â€ ';  // right side double smart quote
  $find[] = 'â€˜';  // left side single smart quote
  $find[] = 'â€™';  // right side single smart quote
  $find[] = 'â€¦';  // elipsis
  $find[] = 'â€”';  // em dash
  $find[] = 'â€“';  // en dash

  $replace[] = '"';
  $replace[] = '"';
  $replace[] = "'";
  $replace[] = "'";
  $replace[] = "...";
  $replace[] = "-";
  $replace[] = "-";

  $text = str_replace($find, $replace, $text);
?>
===============================================================================

Maybe obvious to veteran PHP programmers but less so to novice PHP programmers
is the fact that this is invalid:
<?php
str_replace($search, $replace, $subject, 1);
?>
At a glance it appears to be a reasonable request, until you realize that the
fourth parameter must be a variable in order to be passed as a reference. A
replacement:
<?php
str_replace($search, $replace, $subject, $temp = 1);
// or
$temp = 1;
str_replace($search, $replace, $subject, $temp);
?>
===============================================================================

In many countries the numeric format is 1.000,33 in english it is 1,000.33

This function converts numeric arguments always into the PHP confirm numeric
format. If only one seperator is into the numericstring so it is interpreted as
the decimalpoint.

function dp($zahl)
{
  if ((strpos($zahl,".") > "-1") | (strpos($zahl,",") > "-1")) {
    if ((strpos($zahl,".") > "-1") & (strpos($zahl,",") > "-1")) {
      if (strpos($zahl,".") > strpos($zahl,",")){
          return str_replace(",","",$zahl);
    } else {
          return str_replace(",",".",str_replace(".","",$zahl));
      }
  } else {
      if (strpos($zahl,".") > "-1") {
        if (strpos($zahl,".") == strrpos($zahl,".")) {
            return $zahl;
      } else {
          return str_replace(".","",$zahl);         
        }
    } else {
        if (strpos($zahl,",") == strrpos($zahl,",")) {
          return str_replace(",",".",$zahl);
      } else {
          return str_replace(",","",$zahl);         
        }
    } }
} else {
    return $zahl;
} }
===============================================================================

Be aware that if you use this for filtering & sanitizing some form of user
input, or remove ALL instances of a string, there's another gotcha to watch out
for:

// Remove all double characters
$string="1001011010";
$string=str_replace(array("11","00"),"",$string);
// Output: "110010"

$string="<ht<html>ml> Malicious code </<html>html> etc";
$string=str_replace(array("<html>","</html>"),"",$string);
// Output: "<html> Malicious code </html> etc"
===============================================================================

Insert space after comma.

If you have a form that stores results in a database field as comma separated
values, when you display this data you can use the following to insert a space
after each comma:

<?php
$find[] = ',';
$replace[] = '&#44;&nbsp;';
$text = str_replace($find, $replace, $row_rsRecordset['Field']);
print_r($text);
?>

Notes:
1) To get round the Replacement Order Gotcha, the comma is also replaced with
its code equivalent: &#44;
2) You can adapt the $replace section to suit your needs: swap out the &nbsp;
code with <br/> or replace comma and space with &nbsp;&middot;&nbsp; etc.
===============================================================================

nikolaz dot tang at hotmail dot com's solution of using json_encode/decode is
interesting, but a couple of issues to be aware of with it.

<?php
// From: nikolaz dot tang at hotmail dot com's post
function str_replace_json($search, $replace, $subject){
     return json_decode(str_replace($search, $replace,  json_encode($subject
)));
}
?>

json_decode will return objects, where arrays are probably expected.  This is
easily remedied by adding 2nd parameter 'true' to json_decode.

$search and $replace could contain strings that match json encoding, which will
either change the structure returned by this method, or break the json.

ie:
<?php
var_dump(str_replace_json('":"', '","', ['this' => 'stuff']));
var_dump(str_replace_json('this":"', 'this" : "thing", "with":"', ['this' => 
'stuff']));
?>
===============================================================================

$myString = “It was the best of mine it was the worst of mine,”;
// Displays “It was the best of bananas, it was the worst of bananas,”
echo str_replace( “mine”, “bananas”, $myString );
If you want to know how many times the search string was replaced, pass in a
variable as an optional
fourth argument. After the function runs, this variable holds the number of
replacements:
$myString = “It was the best of mine, it was the worst of mine,”;
// Displays “It was the best of bananas, it was the worst of bananas,”
echo str_replace( “mine”, “bananas”, $myString, $num ) . “ < br/ > ”;
// Displays “The text was replaced 2 times.”
echo “The text was replaced $num times. < br/ > ”;
===============================================================================

I came across requirement to replace some occurrences of a letter with other
letter in a word:

<?php

$a =    'ctl00_ContentPlaceHolder1_Rpt_data_ctl01_lnk_name';
$b =    'ctl00$ContentPlaceHolder1$Rpt_data$ctl01$lnk_name';

echo "db has $a\n";
echo "we want $b\n";

//Make replacement array
$replacement = array(
    array('_','$'),
    array('_','$'),
    array('_','_'),
    array('_','$'),
    array('_','$'),
    array('_','$'),
);

//call function
echo replaceByArray($a,$replacement);

function replaceByArray($a, $replacement){
    $j=0;
    for($i=0; $i<strlen($a); $i++){
        if($a[$i]==$replacement[$j][0]){
            $a[$i] = $replacement[$j][1];    //make replacement
            $j++;        //increment index of replacement array
            if($j == (count($replacement)-1)) break;    //break out of loop if
replacement array processed
        }
    }

    return $a;
}
?>
===============================================================================

Before spending hours searching your application why it makes UTF-8 encoding
into some malformed something with str_replace, make sure you save your PHP
file in UTF-8 (NO BOM).

This was at least one of my problems.
===============================================================================

As previous commentators mentioned, when $search contains values that occur
earlier in $replace, str_replace will factor those previous replacements into
the process rather than operating solely on the original string.  This may
produce unexpected output.

Example:

<?php
$search = array('A', 'B', 'C', 'D', 'E');
$replace = array('B', 'C', 'D', 'E', 'F');
$subject = 'ABCDE';

echo str_replace($search, $replace, $subject); // output: 'FFFFFF'
?>

In the above code, the $search and $replace should replace each occurrence in
the $subject with the next letter in the alphabet.  The expected output for
this sample is 'BCDEF'; however, the actual output is 'FFFFF'.

To more clearly illustrate this, consider the following example:

<?php
$search = array('A', 'B', 'C', 'D', 'E');
$replace = array('B', 'C', 'D', 'E', 'F');
$subject = 'A';

echo str_replace($search, $replace, $subject); // output: 'F'
?>

Since 'A' is the only letter in the $search array that appears in $subject, one
would expect the result to be 'B'; however, replacement number $n does *not*
operate on $subject, it operates on $subject after the previous $n-1
replacements have been completed.

The following function utilizes array_combine and strtr to produce the expected
output, and I believe it is the most efficient way to perform the desired
string replacement without prior replacements affecting the final result.

<?php
/**
* When using str_replace(...), values that did not exist in the original string
(but were put there by previous
* replacements) will be replaced continuously.  This string replacement
function is designed replace the values
* in $search with those in $replace while not factoring in prior replacements. 
Note that this function will
* always look for the longest possible match first and then work its way down
to individual characters.
*
* The "o" in "stro_replace" represents "original", indicating that the function
operates only on the original string.
*
* @param array $search list of strings or characters that need to be replaced
* @param array $replace list of strings or characters that will replace the
corresponding values in $search
* @param string $subject the string on which this operation is being performed
*
* @return string $subject with all substrings in the $search array replaced by
the values in the $replace array
*/
function stro_replace($search, $replace, $subject)
{
    return strtr( $subject, array_combine($search, $replace) );
}

$search = array('A', 'B', 'C', 'D', 'E');
$replace = array('B', 'C', 'D', 'E', 'F');
$subject = 'ABCDE';

echo stro_replace($search, $replace, $subject); // output: 'BCDEF'
?>

Some other examples:

<?php
$search = array(' ', '&');
$replace = array('&nbsp;', '&amp;');
$subject = 'Hello & goodbye!';

// We want to replace the spaces with &nbsp; and the ampersand with &amp;
echo str_replace($search, $replace, $subject); // output: "Hello&amp;nbsp&amp;&
amp;nbspgoodbye!" - wrong!

echo stro_replace($search, $replace, $subject); // output: "Hello&nbsp;&amp;&
nbsp;goodbye!" - correct!

/*
    Note:  Run the above code in the CLI or view source on your web browser -
the replacement strings for stro_replace are HTML entities which the browser
interprets.
*/
?>

<?php
$search = array('ERICA', 'AMERICA');
$replace = array('JON', 'PHP');
$subject = 'MIKE AND ERICA LIKE AMERICA';

// We want to replace the name "ERICA" with "JON" and the word "AMERICA" with
"PHP"
echo str_replace($search, $replace, $subject); // output: "MIKE AND JON LIKE
AMJON", which is not correct

echo stro_replace($search, $replace, $subject); // output: "MIKE AND JON LIKE
PHP", which is correct
?>
===============================================================================

My input is MS Excel file but I want to save ‘,’,“,” as ',',",".

    $badchr        = array(
        "\xc2", // prefix 1
        "\x80", // prefix 2
        "\x98", // single quote opening
        "\x99", // single quote closing
        "\x8c", // double quote opening
        "\x9d"  // double quote closing
    );
       
    $goodchr    = array('', '', '\'', '\'', '"', '"');
       
    str_replace($badchr, $goodchr, $strFromExcelFile);

Works for me.
===============================================================================

I found a pretty low tech solution to avoid the "gotcha" without worrying about
the array order of how things are replaced. I could not "order" the replacement
array easily because it was being read from a database table.

Anyway if you add an identifiable token to each replaced word, then just filter
this out at the very end, no nested search terms are found. I just dynamically
add the %% after the first char of each word before pumping it into the
str_ireplace function.

$find = array("as1", "as2", "as3", "flex");
$replace = array("<a href = \"#as1\">A%%uto S%%entry R%%ev. A%%</a>", "<a href
= \"#as2\">A%%uto S%%entry E%%xp</a>", "<a href = \"#as3\">A%%uto S%%entry
f%%lex</a>", "<a style = \"color: red;\" href = \"#flex\">f%%lex</a>");
$text = str_ireplace($find, $replace, $text);
echo str_ireplace("%%", "", $text);

In this case I am using %% as my token as this is an unlikely char combo for
me.
===============================================================================

If we have a html template that contains placeholders in curly braces that need
to be replaced in runtime, the following function will do it using str_replace:

<?php

function parse_template($filename, $data) {
// example template variables {a} and {bc}
// example $data array
// $data = Array("a" => 'one', "bc" => 'two');
    $q = file_get_contents($filename);
    foreach ($data as $key => $value) {
        $q = str_replace('{'.$key.'}', $value, $q);
    }
    return $q;
}

?>
===============================================================================

"If search is an array and replace is a string, then this replacement string is
used for every value of search. The converse would not make sense, though. "

I think one important (and not at all vaguely theoretical) use-case is
completely ignored here. Take, for example, the way the PDO handles parameter
replacement.

If we have the following query:
"SELECT * FROM my_table WHERE (id = ? AND my_column = ? AND other_column = ?);"
The "?"s should be replaced by each successive variable in a $parameters array.
That is EXACTLY the use case for "search" being a value and "replace" being an
array.

Considering that this is not only a real-world example but also part of a core
PHP functionality I find it very strange that it's dismissed so easily here.
===============================================================================

I tried max at efoxdesigns dot com solution for str_replace_once but it didn't
work quite right so I came up with this solution (all params must be strings):

<?php
function str_replace_once($search, $replace, $subject) {
    $firstChar = strpos($subject, $search);
    if($firstChar !== false) {
        $beforeStr = substr($subject,0,$firstChar);
        $afterStr = substr($subject, $firstChar + strlen($search));
        return $beforeStr.$replace.$afterStr;
    } else {
        return $subject;
    }
}
?>
===============================================================================

To collapse multiple consecutive space characters to a single one, don't use
str_replace() inside a loop--use preg_replace() instead for clarity and better
performance:

<?php

$str = ' This is    a    test   ';
$str = preg_replace('/ +/', ' ', $str);

?>
===============================================================================

If you need to replace a string in another, but only once but still in all
possible combinations (f.e. to replace "a" with "x" in "aba" to get array
("xba", "abx")) you can use this function:
<?php
function getSingleReplaceCombinations($replace, $with, $inHaystack)
{
    $splits = explode($replace, $inHaystack);
    $result = array();
    for ($i = 1, $ix = count($splits); $i < $ix; ++$i) {
        $previous = array_slice($splits, 0, $i);
        $next     = array_slice($splits, $i);
       
        $combine  = array_pop($previous) . $with . array_shift($next);
        $result[] = implode($replace, array_merge($previous, array($combine), 
$next));
    }
    return $result;
}
var_dump(getSingleReplaceCombinations("a", "x", "aba")); // result as mentioned
above
?>
It may not be the best in performance, but it works.
===============================================================================

say you want every "a" replaced by "abba" and every "b" replaced by "baab" in
the string "ab" you do:

<?php
$search = array("a","b");
$replace = array("abba","baab");
echo str_replace($search,$replace,"ab");
?>

that results in "abaabbaababaab" and not the expected "abbabaab"

I wrote this little snippet to solve the replacements-in-replacement problem:

<?php
function search_replace($s,$r,$sql)
{ $e = '/('.implode('|',array_map('preg_quote', $s)).')/';
  $r = array_combine($s,$r);
  return preg_replace_callback($e, function($v) use ($s,$r) { return $r[$v[1]];
},$sql);
}

echo search_replace($search,$replace,"ab");
?>

that results in the expected "abbabaab"
===============================================================================

Yet another deep replace function:

<?php
    function str_replace_deep( $search, $replace, $subject)
    {
        $subject = str_replace( $search, $replace, $subject);

        foreach ($subject as &$value)
            is_array( $value) and $value =str_replace_deep( $search, $replace, 
$value);
           
        return $subject;
    }
?>
===============================================================================

With PHP 4.3.1, at least, str_replace works fine when working with single
arrays but mess it all with two or more dimension arrays.

<?php
$subject = array("You should eat this","this","and this every day.");
$search  = "this";
$replace = "that";
$new     = str_replace($search, $replace, $subject);

print_r($new); // Array ( [0] => You should eat that [1] => that [2] => and
that every day. )

echo "<hr />";

$subject = array(array("first", "You should eat this")
                ,array("second","this")
                ,array("third", "and this every day."));
$search  = "this";
$replace = "that";
$new     = str_replace($search, $replace, $subject);

print_r($new); // Array ( [0] => Array [1] => Array [2] => Array )

?>
===============================================================================

<?php
/*
This is a function for made recursive str_replaces in an array
*/
function recursive_array_replace($find, $replace, &$data) {
    if (is_array($data)) {
        foreach ($data as $key => $value) {
            if (is_array($value)) {
                recursive_array_replace($find, $replace, $data[$key]);
            } else {
                $data[$key] = str_replace($find, $replace, $value);
            }
        }
    } else {
        $data = str_replace($find, $replace, $data);
    }
}

$a = array();
$a['a'] = "a";
$a['b']['a'] = "ba";
$a['b']['b'] = "bb";
$a['c'] = "c";
$a['d']['a'] = "da";
$a['d']['b'] = "db";
$a['d']['c'] = "dc";
$a['d']['d'] = "dd";

echo "Before Replaces";
print_r($a);

recursive_array_replace("a", "XXXX", $a);

echo "After Replaces";
print_r($a);
?>
===============================================================================

@moostende at gmail dot com
If you want to remove all dashes but one from the string
'-aaa----b-c-----d--e---f' resulting in '-aaa-b-c-d-e-f', you CAN use
str_replace !

<?php
function foo($str)
{
    do {
        $str = str_replace("--", "-", $str, $count);
    } while ($count > 0);
    return $str;
}
echo foo("-aaa----b-c-----d--e---f");
?>

This outputs the following:
-aaa-b-c-d-e-f
===============================================================================

I was looking for a str_replace function supporting callbacks. As I didn't
found one I wrote one my own. Works exactly like str_replace, but the replace
parameter is a callback or an array of callbacks (instead of string/strings in
str_replace). The callback function accepts two arguments, the string that is
being replaced and the count of the replacement being done.

<?php
/**
* str_ureplace
*
* str_replace like function with callback
*
* @param string|array search
* @param callback|array $replace
* @param string|array $subject
* @param int $replace_count
* @return string|array subject with replaces, FALSE on error.
*/
function str_ureplace($search, $replace, $subject, &$replace_count = null) {
    $replace_count = 0;
   
    // validate input
    $search = array_values((array) $search);
    $searchCount = count($search);
    if (!$searchCount) {
        return $subject;
    }
    foreach($search as &$v) {
        $v = (string) $v;
    }
    unset($v);
    $replaceSingle = is_callable($replace);   
    $replace = $replaceSingle ? array($replace) : array_values((array) $replace
);
    foreach($replace as $index=>$callback) {
        if (!is_callable($callback)) {
            throw new Exception(sprintf('Unable to use %s (#%d) as a callback',
gettype($callback), $index));
        }
    }
   
    // search and replace
    $subjectIsString = is_string($subject);
    $subject = (array) $subject;
    foreach($subject as &$haystack) {
        if (!is_string($haystack)) continue;
        foreach($search as $key => $needle) {
            if (!$len = strlen($needle))
                continue;           
            $replaceSingle && $key = 0;           
            $pos = 0;
            while(false !== $pos = strpos($haystack, $needle, $pos)) {
                $replaceWith = isset($replace[$key]) ? call_user_func($replace[
$key], $needle, ++$replace_count) : '';
                $haystack = substr_replace($haystack, $replaceWith, $pos, $len
);
            }
        }
    }
    unset($haystack);
   
    return $subjectIsString ? reset($subject) : $subject;
}
?>
===============================================================================

<?php
// a very beatiful way to do multiple replacements is this one, using just one
array
$replaceThis = Array(
'old word' => 'new word',
'was' => 'it',
'past' => 'future',
);

$originalText = "every old word was a thing of the past...";
$replacedText = str_replace(array_keys($replaceThis), $replaceThis, 
$originalText);
echo $replacedText;
?>
===============================================================================

As mentioned earlier you should take the order into account when substituting
multiple values.

However it is worth noticing that str_replace doesn't seem to re-read the
string when doing single replacements. Take the following example.

<?php
  $s = '/a/a/';
  $s = str_replace('/a/', '/', $s);
?>

You would expect the following.

First replacement '/a/a/' -> '/a/'
Second replacement '/a/'->'/'

This is not the case, the actual result will be '/a/'.

To fix this, you will have to put str_replace in a while-loop.

<?php
  $s = '/a/a/';
  while(strpos($s, '/a/') !== false)
    $s = str_replace('/a/', '/', $s); //eventually $s will == '/'
?>
===============================================================================

This function implements $limit for str_replace(); is 100% backward compatible
with str_replace(); uses str_replace() whenever possible (for performance
reasons); supports arrays for $search, $replace, and $subject; and is fully
commented.

<?php
/**
* Replace $limit occurences of the search string with the replacement
* @param mixed $search The value being searched for. An array may be used to
* designate multiple needles.
* @param mixed $replace The replacement value that replaces found search
* values. An array may be used to designate multiple replacements.
* @param mixed $subject The string or array being searched and replaced on. If
* subject is an array, then the search and replace is performed with every
* entry of subject, and the return value is an array as well.
* @param string $count If passed, this will be set to the number of
* replacements performed.
* @param int $limit The maximum possible replacements for each pattern in each
* subject string. Defaults to -1 (no limit).
* @return string This function returns a string with the replaced values.
*/
function str_replace_limit($search, $replace, $subject, &$count, $limit = -1){
$count = 0;
// Invalid $limit provided
if(!($limit===strval(intval(strval($limit))))){
  trigger_error('Invalid $limit `'.$limit.'` provided. Expecting an '.
    'integer', E_USER_WARNING);
  return $subject;
}
// Invalid $limit provided
if($limit<-1){
  trigger_error('Invalid $limit `'.$limit.'` provided. Expecting -1 or '.
    'a positive integer', E_USER_WARNING);
  return $subject;
}
// No replacements necessary
if($limit===0){
  trigger_error('Invalid $limit `'.$limit.'` provided. Expecting -1 or '.
    'a positive integer', E_USER_NOTICE);
  return $subject;
}
// Use str_replace() when possible
if($limit===-1){
  return str_replace($search, $replace, $subject, $count);
}
if(is_array($subject)){
  // Loop through $subject values
  foreach($subject as $key => $this_subject){
   // Skip values that are arrays
   if(!is_array($this_subject)){
    // Call this function again
    $this_function = __FUNCTION__;
    $subject[$key] = $this_function($search, $replace, $this_subject, 
$this_count, $limit);
    // Adjust $count
    $count += $this_count;
    // Adjust $limit
    if($limit!=-1){
     $limit -= $this_count;
    }
    // Reached $limit
    if($limit===0){
     return $subject;
    }
   }
  }
  return $subject;
} elseif(is_array($search)){
  // Clear keys of $search
  $search = array_values($search);
  // Clear keys of $replace
  if(is_array($replace)){
   $replace = array_values($replace);
  }
  // Loop through $search
  foreach($search as $key => $this_search){
   // Don't support multi-dimensional arrays
   $this_search = strval($this_search);
   // If $replace is an array, use $replace[$key] if exists, else ''
   if(is_array($replace)){
    if(array_key_exists($key, $replace)){
     $this_replace = strval($replace[$key]);
    } else {
     $this_replace = '';
    }
   } else {
    $this_replace = strval($replace);
   }
   // Call this function again for
   $this_function = __FUNCTION__;
   $subject = $this_function($this_search, $this_replace, $subject, $this_count
, $limit);
   // Adjust $count
   $count += $this_count;
   // Adjust $limit
   if($limit!=-1){
    $limit -= $this_count;
   }
   // Reached $limit
   if($limit===0){
    return $subject;
   }
  }
  return $subject;
} else {
  $search = strval($search);
  $replace = strval($replace);
  // Get position of first $search
  $pos = strpos($subject, $search);
  // Return $subject if $search cannot be found
  if($pos===false){
   return $subject;
  }
  // Get length of $search
  $search_len = strlen($search);
  // Loop until $search cannot be found or $limit is reached
  for($i=0;(($i<$limit)||($limit===-1));$i++){
   $subject = substr_replace($subject, $replace, $pos, $search_len);
   // Increase $count
   $count++;
   // Get location of next $search
   $pos = strpos($subject, $search);
   // Break out of loop
   if($pos===false){
    break;
   }
  }
  return $subject;
}
}
?>
===============================================================================

I have:

<?php
function lacz_bd()
{ 
  $db = new mysqli('localhost', '_admin', 'pass', 'db');
 
  if (! $db)
      return false;
   $db->autocommit(TRUE);
   return $db;
}
// dane do ramy pliku .xml
$kanalRSS = '<?xml version="1.0" encoding="ISO-8859-2"?>';
$kanalRSS .= '<trovit>';
$kanalRSS .= '<ad>';

// połaczenie z bazą danych
$db = lacz_bd();
//zapytanie określające dane ktore powinny byc pobrane z tabeli
// teraz pobierzmy wszystkie dane spelniajace warunek category_id=140
$zapytanie = "SELECT * FROM announcements WHERE category_id in
(140,141,142,143,144)";
$wynik = $db->query($zapytanie);
$ile_znalezionych = $wynik->num_rows;

for ($i=0; $i <$ile_znalezionych; $i++)
        {
        $wiersz = $wynik->fetch_assoc();
       
        //usuwamy znaczniki html ze wszystkich danych z tabeli, polskie znaki,
duze litery
        $string_title = $wiersz['annoucement_title'];
        $string_url = $wiersz['annoucement_title'];
        $pattern = array(' ', ',', '.', '/ą/', '/Ą/', '/ć/', '/Ć/', '/ę/', '/Ę/
', '/ł/', '/Ł/' ,'/ń/', '/Ń/', '/ó/', '/Ó/', '/ś/', '/Ś/', '/ź/', '/Ź/', '/ż/',
'/Ż/',);
        $replacement = array('-', '', '',     'a', 'A', 'c', 'C', 'e', 'E', 'l'
, 'L', 'n', 'N', 'o', 'O', 's', 'S', 'z', 'Z', 'z', 'Z',);
        $string_url = strtolower(str_replace($pattern, $replacement, 
$string_url));
           
        $wiersz['annoucement_content'] = strip_tags($wiersz[
'annoucement_content']);
        //dodajemy nazwy rodzajow ogloszenia
        $string_type = $wiersz['annoucement_type'];
        $_type = array('1', '2', '3', '4');
        $_new_type = array('Buy', 'Replace', 'For Rent', 'For Sale');
        $wiersz['annoucement_type'] = str_replace($_type, $_new_type, 
$string_type);
               
//tutaj generujemy zawartosc pliku .xml, ktora pobierana jest z tabeli
announcements
        $kanalRSS .= '<item>';
    $kanalRSS .= '<id><![CDATA['.$wiersz['annoucement_id'].']]></id>';
    $kanalRSS .= '<url><![CDATA[http://oglaszajtu.pl/ogloszenia/'.$wiersz[
'annoucement_id'].'/'.$string_url.']]></url>';
    $kanalRSS .= '<title><![CDATA['.$string_title.']]></title>';
    $kanalRSS .= '<type><![CDATA['.$wiersz['annoucement_type'].']]></type>';
    $kanalRSS .= '<content><![CDATA['.$wiersz['annoucement_content'].']]></
content>';
    $kanalRSS .= '<date><![CDATA['.$wiersz['annoucement_date_added'].']]></
date>';
        $kanalRSS .= '</item>';
                }
    $kanalRSS .= ' </ad>';
$kanalRSS .= '</trovit>';

//Zapisujemy wygenerowany kod XML do pliku moj_rss.xml
$fp = fopen('trovit_oglaszajtu.xml','w');
fwrite($fp,$kanalRSS);
fclose($fp);
?>

And one problem - ą,ó,ś, etc - don't delete

oglaszajtu.pl/moj_rss.php
oglaszajtu.pl/trovit_oglaszajtu.xml

:-(
Can anyone help me?
Thx
rel
===============================================================================

Fast function to replace new lines from a given string. This is interesting to
replace all new lines from e. g. a text formatted in HTML retrieved from
database and printing it without the unnecessary new lines. This results in
slightly faster rendering in the Web browser.

<?php

/**
* Replace all linebreaks with one whitespace.
*
* @access public
* @param string $string
*   The text to be processed.
* @return string
*   The given text without any linebreaks.
*/
function replace_newline($string) {
  return (string)str_replace(array("\r", "\r\n", "\n"), '', $string);
}

?>
===============================================================================

For PHP 4 < 4.4.5 and PHP 5 < 5.2.1 you may occur (like me) in this bug:

http://www.php-security.org/MOPB/MOPB-39-2007.html
===============================================================================

If you wish to get around the 'gotcha', you could do something like this:

<?php

$find=array('a', 'p', '^', '*');
$replace = array('^', '*', 'apple', 'pear');
str_replace($find, $replace, 'a p');

?>

The idea here is that you first replace the items you want with unique
identifiers (that you are unlikely to find in the subject) and then search for
those identifiers and then replace them.
===============================================================================

Replacement for str_replace in which a multiarray of numerically keyed data can
be properly evaluated with the given template without having a search for 11 be
mistaken for two 1's next to each other

<?php

function data_template($input, $template) {
  if ($template) { // template string
    if ($split = str_split($template)) { // each char as array member
      foreach ($split as $char) { // each character
        if (is_numeric($char)) { // test for digit
          if ($s != 1) { // new digit sequence
            $i++;
            $s = 1;
          }
          $digits[$i] .= $char; // store digit
        } else { // not a digit
          if ($s != 2) { // new non-digit sequence
            $i++;
            $s = 2;
          }
          $strings[$i] .= $char; // store string
        }
      }
      if ($i && $input && is_array($input)) { // input data
        foreach ($input as $sub) { // each subarray
          if (is_array($sub)) {
            $out = ''; // reset output
            for ($j = 0; $j <= $i; $j++) { // each number/string member
              if ($number = $digits[$j]) { // number
                $out .= $sub[$number]; // add value from subarray to output
              } else { // string
                $out .= $strings[$j]; // add to output
              }
            }
            $a[] = $out;
          }
        }
        return $a;
      } // input
    } // split
  } // template
}

$input = array(array(1=>'yellow', 2=>'banana', 11=>'fruit'), array(1=>'green', 
2=>'spinach', 11=>'vegetable'), array(1=>'pink', 2=>'salmon', 11=>'fish'));

print_r (data_template($input, '2: a 1, healthy 11'));

/*
Array
(
    [0] => banana: a yellow, healthy fruit
    [1] => spinach: a green, healthy vegetable
    [2] => salmon: a pink, healthy fish
)
*/

// str_replace would have wanted to output 'banana: a yellow, healthy
yellowyellow

?>

Not sure if this will help anyone but I wrote it for my application and thought
I would share just in case
