
sort

(PHP 4, PHP 5, PHP 7)

sort — 对数组排序

说明

bool sort ( array &$array [, int $sort_flags = SORT_REGULAR ] )

本函数对数组进行排序。当本函数结束时数组单元将被从最低到最高重新安排。

参数

array

    要排序的数组。

sort_flags

    可选的第二个参数 sort_flags 可以用以下值改变排序的行为：

    排序类型标记：
      □ SORT_REGULAR - 正常比较单元（不改变类型）
      □ SORT_NUMERIC - 单元被作为数字来比较
      □ SORT_STRING - 单元被作为字符串来比较
      □ SORT_LOCALE_STRING - 根据当前的区域（locale）设置来把单元当作字符串比较
        ，可以用 setlocale() 来改变。
      □ SORT_NATURAL - 和 natsort() 类似对每个单元以“自然的顺序”对字符串进行排
        序。 PHP 5.4.0 中新增的。
      □ SORT_FLAG_CASE - 能够与 SORT_STRING 或 SORT_NATURAL 合并（OR 位运算），
        不区分大小写排序字符串。

返回值

成功时返回 TRUE，或者在失败时返回 FALSE。

更新日志

版本                              说明
5.4.0 添加了 sort_flags 内 SORT_NATURAL 和 SORT_FLAG_CASE 的支持。
5.0.2 添加了 SORT_LOCALE_STRING。

范例

Example #1 sort() 例子

<?php

$fruits = array("lemon", "orange", "banana", "apple");
sort($fruits);
foreach ($fruits as $key => $val) {
    echo "fruits[" . $key . "] = " . $val . "\n";
}

?>

以上例程会输出：

fruits[0] = apple
fruits[1] = banana
fruits[2] = lemon
fruits[3] = orange

fruits 被按照字母顺序排序。

Example #2 使用不区分大小写自然排序的 sort() 例子

<?php

$fruits = array(
    "Orange1", "orange2", "Orange3", "orange20"
);
sort($fruits, SORT_NATURAL | SORT_FLAG_CASE);
foreach ($fruits as $key => $val) {
    echo "fruits[" . $key . "] = " . $val . "\n";
}

?>

以上例程会输出：

fruits[0] = Orange1
fruits[1] = orange2
fruits[2] = Orange3
fruits[3] = orange20

fruits 排序得像 natcasesort() 的结果。

注释

    Note: 此函数为 array 中的元素赋与新的键名。这将删除原有的键名，而不是仅仅将
    键名重新排序。

    Note: 和大多数 PHP 排序函数一样，sort() 使用了 » Quicksort 实现的。

Warning

在对含有混合类型值的数组排序时要小心，因为 sort() 可能会产生不可预知的结果。

参见

  • asort() - 对数组进行排序并保持索引关系
  • 数组排序函数对比


User Contributed Notes 47 notes

===============================================================================

Simple function to sort an array by a specific key. Maintains index
association.

<?php

function array_sort($array, $on, $order=SORT_ASC)
{
    $new_array = array();
    $sortable_array = array();

    if (count($array) > 0) {
        foreach ($array as $k => $v) {
            if (is_array($v)) {
                foreach ($v as $k2 => $v2) {
                    if ($k2 == $on) {
                        $sortable_array[$k] = $v2;
                    }
                }
            } else {
                $sortable_array[$k] = $v;
            }
        }

        switch ($order) {
            case SORT_ASC:
                asort($sortable_array);
            break;
            case SORT_DESC:
                arsort($sortable_array);
            break;
        }

        foreach ($sortable_array as $k => $v) {
            $new_array[$k] = $array[$k];
        }
    }

    return $new_array;
}

$people = array(
    12345 => array(
        'id' => 12345,
        'first_name' => 'Joe',
        'surname' => 'Bloggs',
        'age' => 23,
        'sex' => 'm'
    ),
    12346 => array(
        'id' => 12346,
        'first_name' => 'Adam',
        'surname' => 'Smith',
        'age' => 18,
        'sex' => 'm'
    ),
    12347 => array(
        'id' => 12347,
        'first_name' => 'Amy',
        'surname' => 'Jones',
        'age' => 21,
        'sex' => 'f'
    )
);

print_r(array_sort($people, 'age', SORT_DESC)); // Sort by oldest first
print_r(array_sort($people, 'surname', SORT_ASC)); // Sort by surname

/*
Array
(
    [12345] => Array
        (
            [id] => 12345
            [first_name] => Joe
            [surname] => Bloggs
            [age] => 23
            [sex] => m
        )

    [12347] => Array
        (
            [id] => 12347
            [first_name] => Amy
            [surname] => Jones
            [age] => 21
            [sex] => f
        )

    [12346] => Array
        (
            [id] => 12346
            [first_name] => Adam
            [surname] => Smith
            [age] => 18
            [sex] => m
        )

)
Array
(
    [12345] => Array
        (
            [id] => 12345
            [first_name] => Joe
            [surname] => Bloggs
            [age] => 23
            [sex] => m
        )

    [12347] => Array
        (
            [id] => 12347
            [first_name] => Amy
            [surname] => Jones
            [age] => 21
            [sex] => f
        )

    [12346] => Array
        (
            [id] => 12346
            [first_name] => Adam
            [surname] => Smith
            [age] => 18
            [sex] => m
        )

)
*/

?>
===============================================================================

unless you specify the second argument, "regular" comparisons will be used. I
quote from the page on comparison operators:
"If you compare a number with a string or the comparison involves numerical
strings, then each string is converted to a number and the comparison performed
numerically."
What this means is that "10" < "1a", and "1a" < "2", but "10" > "2". In other
words, regular PHP string comparisons are not transitive.
This implies that the output of sort() can in rare cases depend on the order of
the input array:
<?php
function echo_sorted($a)
{
   echo "{$a[0]} {$a[1]} {$a[2]}";
   sort($a);
   echo " => {$a[0]} {$a[1]} {$a[2]}\n";
}
// on PHP 5.2.6:
echo_sorted(array( "10", "1a", "2")); // => 10 1a 2
echo_sorted(array( "10", "2", "1a")); // => 1a 2 10
echo_sorted(array( "1a", "10", "2")); // => 2 10 1a
echo_sorted(array( "1a", "2", "10")); // => 1a 2 10
echo_sorted(array( "2", "10", "1a")); // => 2 10 1a
echo_sorted(array( "2", "1a", "10")); // => 10 1a 2
?>
===============================================================================

This will select number of unique keys from array and order them in original
order.

<?php
/*
$rows - array of records
$st - number of keys that you want to have

By Oto Brglez.

*/

$pom_k = array();
for($i=0; $i<$st;){
    $pom = array_rand($rows,1);
    if(!in_array($pom,$pom_k)){
        $pom_k[] = $pom;
        $i++;
    };
};
sort($pom_k,SORT_NUMERIC);

?>
===============================================================================

This function will sort entity letters eg:&eacute;

I hope that help someone

function sort_entity($array) {
    $total = count($array);
    for ($i=0;$i<$total;$i++) {
        if ($array[$i]{0} == '&') {
            $array[$i] = $array[$i]{1}.$array[$i];
        } else {
            $array[$i] = $array[$i]{0}.$array[$i];
        }
    }
    sort($array);
   
    for ($i=0;$i<$total;$i++) {
        $array[$i] = substr($array[$i],1);
    }
   
    return $array;
}
===============================================================================

A little shorter way to sort an array of objects; with a callback function.

<?php
function objSort(&$objArray,$indexFunction,$sort_flags=0) {
    $indices = array();
    foreach($objArray as $obj) {
        $indeces[] = $indexFunction($obj);
    }
    return array_multisort($indeces,$objArray,$sort_flags);
}

function getIndex($obj) {
    return $obj->getPosition();
}

objSort($objArray,'getIndex');
?>
===============================================================================

Commenting on note http://www.php.net/manual/en/function.sort.php#62311 :

Sorting an array of objects will not always yield the results you desire.

As pointed out correctly in the note above, sort() sorts the array by value of
the first member variable. However, you can not always assume the order of your
member variables! You must take into account your class hierarchy!

By default, PHP places the inherited member variables on top, meaning your
first member variable is NOT the first variable in your class definition!
However, if you use code analyzers or a compile cache, things can be very
different. E.g., in eAccelerator, the inherited member variables are at the
end, meaning you get different sort results with caching on or off.

Conclusion:
Never use sort on arrays with values of a type other than scalar or array.
===============================================================================

It's useful to know that if you're using this function on a multidimensional
array, php will sort the first key, then the second and so on. This is similar
to being able to use SQL to order by field1, field2 etc.

So:

Array (
[0] => Array ( [category] => work [name] => Smith )
[1] => Array ( [category] => play [name] => Johnson )
[2] => Array ( [category] => work [name] => Berger )
)

will become:

Array (
[0] => Array ( [category] => play [name] => Johnson )
[1] => Array ( [category] => work [name] => Berger )
[2] => Array ( [category] => work [name] => Smith )
)

Hope it helps someone.
===============================================================================

/*
* Name : Aditya Mehrotra
* Email: aditycse@gmail.com
*/
//Example for sorting by values for an alphanumeric array also having
case-sensitive data
$exampleArray1 = $exampleArray2 = array(
    0 => 'example1',
    1 => 'Example10',
    2 => 'example12',
    3 => 'Example2',
    4 => 'example3',
    5 => 'EXAMPLE10',
    6 => 'example10'
);

//default sorting
asort($exampleArray1);

// alphanumeric with case-sensitive data sorting by values
asort($exampleArray2, SORT_STRING | SORT_FLAG_CASE | SORT_NATURAL);

//output of defaut sorting
print_r($exampleArray1);
/*
* output of default sorting
  Array
  (
  [5] => EXAMPLE10
  [1] => Example10
  [3] => Example2
  [0] => example1
  [6] => example10
  [2] => example12
  [4] => example3
  )
*/

print_r($exampleArray2);
/*
* output of alphanumeric with case-sensitive data sorting by values
Array
(
    [0] => example1
    [3] => Example2
    [4] => example3
    [5] => EXAMPLE10
    [1] => Example10
    [6] => example10
    [2] => example12
)
*/
===============================================================================

Sorting the keys, but keep the values in order is not possible by just
ordering, because it would result in a new array. This is also the solution:
Create a new array

<?php
$a = array(9=>"a",8=>"c",5=>"d");

$keys = array_keys($a);
sort($keys);
$result = array_combine($keys, array_values($a));

//Result : array(5=>"a",8=>"c",9=>"d");
?>
===============================================================================

If you need to sort an array containing some equivalent values and you want the
equivalents to end up next to each other in the overall order (similar to a
MySQL's ORDER BY output), rather than breaking the function, do this:

<?php

sort($array, ksort($array))

?>

-When the sort() function finds two equivalents, it will sort them arbitrarily
by their key #'s as a second parameter.

-Dirk
===============================================================================

sort() used with strings doesn't sort just alphabetically. It sorts all
upper-case strings alphabetically first and then sorts lower-case strings
alphabetically second.
Just in case anyone was as confused as I was and I've never seen this mentioned
anywhere.
===============================================================================

Here is a function to sort an array by the key of his sub-array with keep key
in top level.

<?php
function sksort(&$array, $subkey="id", $sort_descending=false, 
$keep_keys_in_sub = false) {
    $temp_array = $array;

    foreach ($temp_array as $key => &$value) {
     
      $sort = array();
      foreach ($value as $index => $val) {
          $sort[$index] = $val[$subkey];
      }
     
      asort($sort);
     
      $keys = array_keys($sort);
      $newValue = array();
      foreach ($keys as $index) {
        if($keep_keys_in_sub)
            $newValue[$index] = $value[$index];
          else
            $newValue[] = $value[$index];
      }
     
      if($sort_descending)
        $value = array_reverse($newValue, $keep_keys_in_sub);
      else
        $value = $newValue;
    }
   
    $array = $temp_array;
  }
?>
===============================================================================

In order to make some multidimensional quick sort implementation, take
advantage of this stuff

<?php
        function quickSortMultiDimensional($array, $chave) {
            if( count( $array ) < 2 ) {
                return $array;
            }
            $left = $right = array( );
            reset( $array );
            $pivot_key    = key( $array );
            $pivot    = array_shift( $array );
            foreach( $array as $k => $v ) {
                if( $v[$chave] < $pivot[$chave] )
                        $left[$k][$chave] = $v[$chave];
                else
                        $right[$k][$chave] = $v[$chave];
            }
            return array_merge(
                                    quickSortMultiDimensional($left, $chave),
                                    array($pivot_key => $pivot),
                                    quickSortMultiDimensional($right, $chave)
            );           
        }
?>

I make it using the idea from pageconfig dot com

tks for viewing
===============================================================================

<?php
   
/**
* function: array_columns
* author: Brecht Cloetens
* params: $a = array() // original array
*         $c = int() // number of columns
*/
function array_columns(&$a, $c=2)
{
    $m = ceil(count($a)/$c);
    $j = 0;
    for($i=0; $i<$m; $i++) {
        for($k=0; $k<$c; $k++) {
            $key = $i+($m*$k);
            settype($key,'integer');
            if(array_key_exists($key,$a)) {
                $b[$j] = $a[$key];
                $j++;
            }
        }
    }
    $a = $b;
}

$arr = range('a','z');
array_columns($arr,4);
print_r($arr);

?>

Example:
array(1,2,3,4,5) will be converted to array(1,4,2,5,3);

This can be easy if you want to display an array into a specified number of
columns.

<table>
    <tr>
        <td>$arr[0] => 1</td>
        <td>$arr[1] => 4</td>
    </tr>
    <tr>
        <td>$arr[2] => 2</td>
        <td>$arr[3] => 5</td>
    </tr>
    <tr>
        <td>$arr[4] => 3</td>
        <td></td>
    </tr>
</table>
===============================================================================

Sorting of an array by a method of inserts.

<?

 
       function sortByField($multArray,$sortField,$desc=true){
            $tmpKey='';
            $ResArray=array();

            $maIndex=array_keys($multArray);
            $maSize=count($multArray)-1;

            for($i=0; $i < $maSize ; $i++) {

               $minElement=$i;
               $tempMin=$multArray[$maIndex[$i]][$sortField];
               $tmpKey=$maIndex[$i];

                for($j=$i+1; $j <= $maSize; $j++)
                  if($multArray[$maIndex[$j]][$sortField] < $tempMin ) {
                     $minElement=$j;
                     $tmpKey=$maIndex[$j];
                     $tempMin=$multArray[$maIndex[$j]][$sortField];

                  }
                  $maIndex[$minElement]=$maIndex[$i];
                  $maIndex[$i]=$tmpKey;
            }

           if($desc)
               for($j=0;$j<=$maSize;$j++)
                  $ResArray[$maIndex[$j]]=$multArray[$maIndex[$j]];
           else
              for($j=$maSize;$j>=0;$j--)
                  $ResArray[$maIndex[$j]]=$multArray[$maIndex[$j]];

           return $ResArray;
       }

// make array
$array['aaa']=array("name"=>"vasia","order"=>1);
$array['bbb']=array("name"=>"petia","order"=>2);
$array['ccc']=array("name"=>"kolia","order"=>3);
$array['ddd']=array("name"=>"zenia","order"=>4);

// set sort
$SortOrder=0; // desc by default , 1- asc

var_dump(sortByField($array,'order',$SortOrder));

array
  'ddd' =>
    array
      'name' => 'zenia' (length=5)
      'order' => 4
  'aaa' =>
    array
      'name' => 'vasia' (length=5)
      'order' => 1
  'bbb' =>
    array
      'name' => 'petia' (length=5)
      'order' => 2
  'ccc' =>
    array
      'name' => 'kolia' (length=5)
      'order' => 3

?>
===============================================================================

Faster, more effective function:

array_sort (array, ['asc'/'desc'])

Second parameter specifies whether to order ascending or descending. Default is
ascending.

function array_sort($array, $type='asc'){
    $result=array();
    foreach($array as $var => $val){
        $set=false;
        foreach($result as $var2 => $val2){
            if($set==false){
                if($val>$val2 && $type=='desc' || $val<$val2 && $type=='asc'){
                    $temp=array();
                    foreach($result as $var3 => $val3){
                        if($var3==$var2) $set=true;
                        if($set){
                            $temp[$var3]=$val3;
                            unset($result[$var3]);
                        }
                    }
                    $result[$var]=$val;   
                    foreach($temp as $var3 => $val3){
                        $result[$var3]=$val3;
                    }
                }
            }
        }
        if(!$set){
            $result[$var]=$val;
        }
    }
    return $result;
}

Works for ordering by integers or strings, no need to specify which.

Example:

$array=array('a' => 50, 'b' => 25, 'c' => 75);
print_r(array_sort($array));

Returns:
Array
(
[b] => 25
[a] => 50
[c] => 75
)
===============================================================================

I dig the multi_sort function(s) from above.  But, they don't work for hash
arrays.  I added a keys variable to keep track of the key value as the array
gets sorted.  Feed back welcome.

<?php
function array_qsort (&$array, $column=0, $order=SORT_ASC, $first=0, $last= -2)
{
  // $array  - the array to be sorted
  // $column - index (column) on which to sort
  //          can be a string if using an associative array
  // $order  - SORT_ASC (default) for ascending or SORT_DESC for descending
  // $first  - start index (row) for partial array sort
  // $last  - stop  index (row) for partial array sort
  // $keys  - array of key values for hash array sort
 
  $keys = array_keys($array);
  if($last == -2) $last = count($array) - 1;
  if($last > $first) {
   $alpha = $first;
   $omega = $last;
   $key_alpha = $keys[$alpha];
   $key_omega = $keys[$omega];
   $guess = $array[$key_alpha][$column];
   while($omega >= $alpha) {
     if($order == SORT_ASC) {
       while($array[$key_alpha][$column] < $guess) {$alpha++; $key_alpha = 
$keys[$alpha]; }
       while($array[$key_omega][$column] > $guess) {$omega--; $key_omega = 
$keys[$omega]; }
     } else {
       while($array[$key_alpha][$column] > $guess) {$alpha++; $key_alpha = 
$keys[$alpha]; }
       while($array[$key_omega][$column] < $guess) {$omega--; $key_omega = 
$keys[$omega]; }
     }
     if($alpha > $omega) break;
     $temporary = $array[$key_alpha];
     $array[$key_alpha] = $array[$key_omega]; $alpha++;
     $key_alpha = $keys[$alpha];
     $array[$key_omega] = $temporary; $omega--;
     $key_omega = $keys[$omega];
   }
   array_qsort ($array, $column, $order, $first, $omega);
   array_qsort ($array, $column, $order, $alpha, $last);
  }
}
?>
===============================================================================

EDIT: To the original note by "phpdotnet at m4tt dot co dot uk"
Use array_push instead of $new_array[$k] for some reason it was
giving me string indexes.

Simple function to sort an array by a specific key. Maintains index
association.

<?php

function array_sort($array, $on, $order=SORT_ASC)
{
    $new_array = array();
    $sortable_array = array();

    if (count($array) > 0) {
        foreach ($array as $k => $v) {
            if (is_array($v)) {
                foreach ($v as $k2 => $v2) {
                    if ($k2 == $on) {
                        $sortable_array[$k] = $v2;
                    }
                }
            } else {
                $sortable_array[$k] = $v;
            }
        }

        switch ($order) {
            case SORT_ASC:
                asort($sortable_array);
            break;
            case SORT_DESC:
                arsort($sortable_array);
            break;
        }

        foreach ($sortable_array as $k => $v) {
            array_push($new_array, $array[$k]);
        }
    }

    return $new_array;
}

$people = array(
    12345 => array(
        'id' => 12345,
        'first_name' => 'Joe',
        'surname' => 'Bloggs',
        'age' => 23,
        'sex' => 'm'
    ),
    12346 => array(
        'id' => 12346,
        'first_name' => 'Adam',
        'surname' => 'Smith',
        'age' => 18,
        'sex' => 'm'
    ),
    12347 => array(
        'id' => 12347,
        'first_name' => 'Amy',
        'surname' => 'Jones',
        'age' => 21,
        'sex' => 'f'
    )
);

print_r(array_sort($people, 'age', SORT_DESC)); // Sort by oldest first
print_r(array_sort($people, 'surname', SORT_ASC)); // Sort by surname

/*
Array
(
    [12345] => Array
        (
            [id] => 12345
            [first_name] => Joe
            [surname] => Bloggs
            [age] => 23
            [sex] => m
        )

    [12347] => Array
        (
            [id] => 12347
            [first_name] => Amy
            [surname] => Jones
            [age] => 21
            [sex] => f
        )

    [12346] => Array
        (
            [id] => 12346
            [first_name] => Adam
            [surname] => Smith
            [age] => 18
            [sex] => m
        )

)
Array
(
    [12345] => Array
        (
            [id] => 12345
            [first_name] => Joe
            [surname] => Bloggs
            [age] => 23
            [sex] => m
        )

    [12347] => Array
        (
            [id] => 12347
            [first_name] => Amy
            [surname] => Jones
            [age] => 21
            [sex] => f
        )

    [12346] => Array
        (
            [id] => 12346
            [first_name] => Adam
            [surname] => Smith
            [age] => 18
            [sex] => m
        )

)
*/

?>
===============================================================================

This took me longer than it should have to figure out, but if you want the
behavior of sort($array, SORT_STRING) (that is, re-indexing the array unlike
natcasesort) in a case-insensitive manner, it is a simple matter of doing usort
($array, strcasecmp).
===============================================================================

As some people have mentioned before sorting a multidimentional array can be a
bit tricky. it took me quite a while to get it going but it works as a charm:

<?php
//$order has to be either asc or desc
function sortmulti ($array, $index, $order, $natsort=FALSE, $case_sensitive=
FALSE) {
        if(is_array($array) && count($array)>0) {
            foreach(array_keys($array) as $key)
            $temp[$key]=$array[$key][$index];
            if(!$natsort) {
                if ($order=='asc')
                    asort($temp);
                else   
                    arsort($temp);
            }
            else
            {
                if ($case_sensitive===true)
                    natsort($temp);
                else
                    natcasesort($temp);
            if($order!='asc')
                $temp=array_reverse($temp,TRUE);
            }
            foreach(array_keys($temp) as $key)
                if (is_numeric($key))
                    $sorted[]=$array[$key];
                else   
                    $sorted[$key]=$array[$key];
            return $sorted;
        }
    return $sorted;
}
?>
===============================================================================

I read up on various problems re: sort() and German Umlaut chars and my head
was soon spinning - bug in sort() or not, solution via locale or not, etc. ...
(a total newbie here).

The obvious solution for me was quick and dirty: transform the Umlaut chars
(present as HTML codes in my case) to their normal equivalent ('ä' = 'ae', 'ö'
= 'oe', 'ü' = 'ue', 'ß' = 'ss' etc.), sort the array, then transform back.
However there are cases in which a 'Mueller' is really that and does NOT need
to be transformed into 'Müller' afterwards. Hence I for example replace the
Umlaut itself with it's normal equivalent plus a char not used in the string
otherwise (e.g. '_') so that the transfer back to Umlaut would only take place
on certain combinations.

Of course any other char instead of '_' can be used as additional char
(influencing the sort result). I know that my solution is rough at the edges
and may cause other sort problems but it was sufficient for my purpose.

The array '$dat' in this example was filled with German town names (I actually
worked with a multiple array ('$dat[][]') but stripped the code down to this as
it's easier to understand):

<?php
// START Pre-sorting (Umlaut -> normal letters)
$max = count($dat);
for($totcnt = 0; $totcnt < $max; $totcnt++){
   $dat[$totcnt]=str_replace('&szlig;','ss_',$dat[$totcnt]);
   $dat[$totcnt]=str_replace('&Auml;','Ae_',$dat[$totcnt]);
   $dat[$totcnt]=str_replace('&auml;','ae_',$dat[$totcnt]);
   $dat[$totcnt]=str_replace('&Ouml;','Oe_',$dat[$totcnt]);
   $dat[$totcnt]=str_replace('&ouml;','oe_',$dat[$totcnt]);
   $dat[$totcnt]=str_replace('&Uuml;','Ue_',$dat[$totcnt]);
   $dat[$totcnt]=str_replace('&uuml;','ue_',$dat[$totcnt]);
}
// END Pre-sorting (Umlaut -> normal letters)

// START Sorting //
function compare_towns($a, $b)
{
return strnatcmp($a, $b);
}
usort($dat, 'compare_towns');
// END Sorting //

// START Post-sorting (normal letters -> Umlaut)
for($totcnt = 0; $totcnt < $max; $totcnt++){
   $dat[$totcnt]=str_replace('ss_','&szlig;',$dat[$totcnt]);
   $dat[$totcnt]=str_replace('Ae_','&Auml;',$dat[$totcnt]);
   $dat[$totcnt]=str_replace('ae_','&auml;',$dat[$totcnt]);
   $dat[$totcnt]=str_replace('Oe_','&Ouml;',$dat[$totcnt]);
   $dat[$totcnt]=str_replace('oe_','&ouml;',$dat[$totcnt]);
   $dat[$totcnt]=str_replace('Ue_','&Uuml;',$dat[$totcnt]);
   $dat[$totcnt]=str_replace('ue_','&uuml;',$dat[$totcnt]);
}
// END Post-sorting (normal letters -> Umlaut)
?>
===============================================================================

sort from textfile by coloumn
example name||date||time||comments
if you want to sort by date
$column = 2
<?php
function array_sort($array,$column){
$column = $column-1;
foreach($array as $line){
$bits = explode("||",$line);
$bits ="$bits[$column]**$line";
$array1[]=$bits;
}
asort($array1);
foreach($array1 as $line){
$bit = explode("**",$line);
$bit ="$bit[1]";
$array2[]=$bit;
}
return$array2;
}
?>
===============================================================================

if you are not interested in high or low case sort

<?php
//where
$sortable_array[$k] = $v2;
//put
$sortable_array[$k] = strtolower($v2);

//and where
$sortable_array[$k] = $v;
//put
$sortable_array[$k] = strtolower($v);
?>
===============================================================================

here is little script which will merge arrays, remove duplicates and sort it by
alphabetical order:

<?php

$array1 = array('apple', 'banana','pear');
$array2 = array('grape', 'pear','orange');

function array_unique_merge_sort($array1, $array2){
$array = array_unique(array_merge($array1, $array2));
sort($array);
foreach ($array as $key => $value) {
    $new[$key] = $value;
}
return $new;
}

print_r (array_unique_merge_sort($array1, $array2));

?>

this will print out:

Array ( [0] => apple [1] => banana [2] => grape [3] => orange [4] => pear )
===============================================================================

<?php
/**
This sort function allows you to sort an associative array while "sticking"
some fields.

$sticky_fields = an array of fields that should not be re-sorted. This is a
method of achieving sub-sorts within contiguous groups of records that have
common data in some fields.

For example:

$a = array();

$a []= array(
    'name'         => 'Sam',
    'age'         => 23,
    'hire_date'    => '2004-01-01'
);
$a []= array(
    'name'        => 'Sam',
    'age'        => 44,
    'hire_date'    => '2003-03-23'
);
$a []= array(
    'name'        => 'Jenny',
    'age'        => 20,
    'hire_date' => '2000-12-31'
);
$a []= array(
    'name'        => 'Samantha',
    'age'        => 50,
    'hire_date' => '2000-12-14'
);

$sticky_fields = array( 'name' );
print_r( stickysort( $a, 'age', DESC_NUM, $sticky_fields ) );

OUTPUT:

Array
(
    [0] => Array
        (
            [name] => Sam
            [age] => 44
            [hire_date] => 2003-03-23
        )
    [1] => Array
        (
            [name] => Sam
            [age] => 23
            [hire_date] => 2004-01-01
        )
    [2] => Array
        (
            [name] => Jenny
            [age] => 20
            [hire_date] => 2000-12-31
        )
    [3] => Array
        (
            [name] => Samantha
            [age] => 50
            [hire_date] => 2000-12-14
        )
)

Here's why this is the correct output - the "name" field is sticky, so it
cannot change its sort order. Thus, the "age" field is only sorted as a
sub-sort within records where "name" is identical. Thus, the "Sam" records are
reversed, because 44 > 23, but Samantha remains at the bottom, even though her
age is 50. This is a way of achieving "sub-sorts" and "sub-sub-sorts" (and so
on) within records of identical data for specific fields.

Courtesy of the $5 Script Archive: http://www.tufat.com
**/

define( 'ASC_AZ', 1000 );
define( 'DESC_AZ', 1001 );
define( 'ASC_NUM', 1002 );
define( 'DESC_NUM', 1003 );

function stickysort( $arr, $field, $sort_type, $sticky_fields = array() ) {
    $i = 0;
    foreach ($arr as $value) {
        $is_contiguous = true;
        if(!empty($grouped_arr)) {
            $last_value = end($grouped_arr[$i]);

            if(!($sticky_fields == array())) {
                foreach ($sticky_fields as $sticky_field) {
                    if ($value[$sticky_field] <> $last_value[$sticky_field]) {
                        $is_contiguous = false;
                        break;
                    }
                }
            }
        }
        if ($is_contiguous)
            $grouped_arr[$i][] = $value;
        else
            $grouped_arr[++$i][] = $value;
    }
    $code = '';
    switch($sort_type) {
        case ASC_AZ:
            $code .= 'return strcasecmp($a["'.$field.'"], $b["'.$field.'"]);';
            break;
        case DESC_AZ:
            $code .= 'return (-1*strcasecmp($a["'.$field.'"], $b["'.$field.
'"]));';
            break;
        case ASC_NUM:
            $code .= 'return ($a["'.$field.'"] - $b["'.$field.'"]);';
            break;
        case DESC_NUM:
            $code .= 'return ($b["'.$field.'"] - $a["'.$field.'"]);';
            break;
    }

    $compare = create_function('$a, $b', $code);

    foreach($grouped_arr as $grouped_arr_key=>$grouped_arr_value)
        usort ( $grouped_arr[$grouped_arr_key], $compare );

    $arr = array();
    foreach($grouped_arr as $grouped_arr_key=>$grouped_arr_value)
        foreach($grouped_arr[$grouped_arr_key] as $grouped_arr_arr_key=>
$grouped_arr_arr_value)
            $arr[] = $grouped_arr[$grouped_arr_key][$grouped_arr_arr_key];

    return $arr;
}
?>
===============================================================================

<?php
/**
This sort function allows you to sort an associative array while "sticking"
some fields.

$sticky_fields = an array of fields that should not be re-sorted. This is a
method of achieving sub-sorts within contiguous groups of records that have
common data in some fields.

Courtesy of the $5 Script Archive: http://www.tufat.com
**/

define( 'ASC_AZ', 1000 );
define( 'DESC_AZ', 1001 );
define( 'ASC_NUM', 1002 );
define( 'DESC_NUM', 1003 );

function stickysort( $arr, $field, $sort_type, $sticky_fields = array() ) {
    $i = 0;
    foreach ($arr as $value) {
        $is_contiguous = true;
        if(!empty($grouped_arr)) {
            $last_value = end($grouped_arr[$i]);

            if(!($sticky_fields == array())) {
                foreach ($sticky_fields as $sticky_field) {
                    if ($value[$sticky_field] <> $last_value[$sticky_field]) {
                        $is_contiguous = false;
                        break;
                    }
                }
            }
        }
        if ($is_contiguous)
            $grouped_arr[$i][] = $value;
        else
            $grouped_arr[++$i][] = $value;
    }
    $code = '';
    switch($sort_type) {
        case ASC_AZ:
            $code .= 'return strcasecmp($a["'.$field.'"], $b["'.$field.'"]);';
            break;
        case DESC_AZ:
            $code .= 'return (-1*strcasecmp($a["'.$field.'"], $b["'.$field.
'"]));';
            break;
        case ASC_NUM:
            $code .= 'return ($a["'.$field.'"] - $b["'.$field.'"]);';
            break;
        case DESC_NUM:
            $code .= 'return ($b["'.$field.'"] - $a["'.$field.'"]);';
            break;
    }

    $compare = create_function('$a, $b', $code);

    foreach($grouped_arr as $grouped_arr_key=>$grouped_arr_value)
        usort ( $grouped_arr[$grouped_arr_key], $compare );

    $arr = array();
    foreach($grouped_arr as $grouped_arr_key=>$grouped_arr_value)
        foreach($grouped_arr[$grouped_arr_key] as $grouped_arr_arr_key=>
$grouped_arr_arr_value)
            $arr[] = $grouped_arr[$grouped_arr_key][$grouped_arr_arr_key];

    return $arr;
}
?>
===============================================================================

#This is a function that will sort an array...
function sort_by($array,  $keyname = null, $sortby) {
   $myarray = $inarray = array();   
   # First store the keyvalues in a seperate array
    foreach ($array as $i => $befree) {
        $myarray[$i] = $array[$i][$keyname];
    }
   # Sort the new array by
    switch ($sortby) {
    case 'asc':
    # Sort an array and maintain index association...
    asort($myarray);
    break;
    case 'arsort':
    # Sort an array in reverse order and maintain index association
    arsort($myarray);
    break;
    case 'natcasesor':
    # Sort an array using a case insensitive "natural order" algorithm
    natcasesort($myarray);
    break;
    }
    # Rebuild the old array
    foreach ( $myarray as $key=> $befree) {
       $inarray[$key] = $array[$key];
    }
    return $inarray;
}
sort_by(); example...
$info = sort_by($myarray, 'name', $use = 'asc');   
print_r($info);
===============================================================================

Ik you want to sort case insensitive, use the natcasesort()
===============================================================================

I ran into the same problem with case insensitive sorting. Actually I think
there should be a SORT_STRING_CASE flag but I tried the following:

usort($listing, 'strcasecmp');

This didn't work (why not?), but you can do a proper case insensitive sort like
this:

usort($listing, create_function('$a,$b','return strcasecmp($a,$b);'));
===============================================================================

I have discovered an interesting trick with the sort function.  Many coders are
using it to sort options for a user, because a computer will only need sorted
data in limited cases.  However, every coder wants their sorted data to be
usable.  It's very common to find any sorted data online, and to find options,
"Sort by Date," "Sort Alphabetically," etc., etc., whether you're looking at an
online catalogue or some bulletin board.

The trick is to use a combination of html commenting and str_pad's to do
definitive "sort by" functions.  Let me demonstrate with an example: consider
two arrays, Sorted_By_Date and Sorted_By_Name.  You want every element to be "
<option value=something>Option Name</option", so that you can do a simple
foreach statement that prints every option value.  But, sorting these arrays
will technically sort just sort whatever you put into "value".  So, here's a
neat trick.  Make every entry "<!-- Sort_Value --><option value=something>
Option Name</option."  That way, when you sort, it'll have to sort technically
by whatever is the Sort_Value.

The greatness of this trick is that you can make as many "sort this data by X"
fields as you want!  Just create multiple arrays, each with the same option
values and names, but with a different value put in "Sort_Value", which could
be a date, a name, a price, etc..  With numbers, you may need to use the
str_pad function, to push all of the zeros out to the left, for a proper sort. 
For instance, in my code, that looks like...

<?php

                $number_of_versions_sort_value = str_pad($number_of_versions, 
20, "0", STR_PAD_LEFT);

?>
===============================================================================

I've yet to come across a fast way to merge sorted arrays by a user value.
Merging the arrays and using PHP's usort isn't efficient, as it doesn't take
advantage of the existing sorting. So I wrote my own merge sorted arrays by
user value function. The limit parameter can be used be used to limit the
number of results (there is no point sorting more results than needed). This
sort is stable: values will be taken preferentially from the first, then
second, etc., array inside $merge_arrays.

Note that this function will fail if a user value is boolean false. It could be
adapted to hold the best value inside an array at some performance penalty. It
could also be adapted to comparing strings case-insensitively.

To give you some idea of the performance, my machine will sort out the first
1000 values of 10 sorted arrays of 1000 values each in under 40 ms, using an
integer sort field. Not fast by C standards, but a vast improvement over
usort'ing 10,000 values.

<?php
function merge_sorted_arrays_by_field ($merge_arrays, $sort_field, $sort_desc =
false, $limit = 0)
{
    $array_count = count($merge_arrays);
   
    // fast special cases...
    switch ($array_count)
    {
        case 0: return array();
        case 1: return $limit ? array_slice(reset($merge_arrays), 0, $limit) : 
reset($merge_arrays);
    }
   
    if ($limit === 0)
        $limit = PHP_INT_MAX;
   
    // rekey merge_arrays array 0->N
    $merge_arrays = array_values($merge_arrays);

    $best_array = false;
    $best_value = false;
   
    $results = array();
   
    // move sort order logic outside the inner loop to speed things up
    if ($sort_desc)
    {
        for ($i = 0; $i < $limit; ++$i)
        {
            for ($j = 0; $j < $array_count; ++$j)
            {
                // if the array $merge_arrays[$j] is empty, skip to next
                if (false === ($current_value = current($merge_arrays[$j])))
                    continue;
               
                // if we don't have a value for this round, or if the current
value is bigger...
                if ($best_value === false || $current_value[$sort_field] > 
$best_value[$sort_field])
                {
                    $best_array = $j;
                    $best_value = $current_value;
                }
            }
           
            // all arrays empty?
            if ($best_value === false)
                break;
           
            $results[] = $best_value;
            $best_value = false;
            next($merge_arrays[$best_array]);
        }
    }
    else
    {
        for ($i = 0; $i < $limit; ++$i)
        {
            for ($j = 0; $j < $array_count; ++$j)
            {
                if (false === ($current_value = current($merge_arrays[$j])))
                    continue;
               
                // if we don't have a value for this round, or if the current
value is smaller...
                if ($best_value === false || $current_value[$sort_field] < 
$best_value[$sort_field])
                {
                    $best_array = $j;
                    $best_value = $current_value;
                }
            }
           
            // all arrays empty?
            if ($best_value === false)
                break;
           
            $results[] = $best_value;
            $best_value = false;
            next($merge_arrays[$best_array]);
        }
    }
   
    return $results;
}
?>
===============================================================================

I could never find a way to sort multidimensional arrays with 5+ keys while
maintaining the data structure, but here it is:

(you can add an infinite number of keys, but it has to be added manually :\ )

<?php

$array[0]['name']  = 'Chris';
$array[0]['phone'] = '3971095';
$array[0]['year']  = '1978';
$array[0]['address'] = 'Street 1';

$array[1]['name']  = 'Breanne';
$array[1]['phone'] = '3766350';
$array[1]['year']  = '1990';
$array[1]['address'] = 'Street 2';

$array[2]['name']  = 'Dusty';
$array[2]['phone'] = '1541120';
$array[2]['year']  = '1982';
$array[2]['address'] = 'Street 3';

function multisort($array, $sort_by, $key1, $key2=NULL, $key3=NULL, $key4=NULL,
$key5=NULL, $key6=NULL){
    // sort by ?
    foreach ($array as $pos =>  $val)
        $tmp_array[$pos] = $val[$sort_by];
    asort($tmp_array);
   
    // display however you want
    foreach ($tmp_array as $pos =>  $val){
        $return_array[$pos][$sort_by] = $array[$pos][$sort_by];
        $return_array[$pos][$key1] = $array[$pos][$key1];
        if (isset($key2)){
            $return_array[$pos][$key2] = $array[$pos][$key2];
            }
        if (isset($key3)){
            $return_array[$pos][$key3] = $array[$pos][$key3];
            }
        if (isset($key4)){
            $return_array[$pos][$key4] = $array[$pos][$key4];
            }
        if (isset($key5)){
            $return_array[$pos][$key5] = $array[$pos][$key5];
            }
        if (isset($key6)){
            $return_array[$pos][$key6] = $array[$pos][$key6];
            }
        }
    return $return_array;
    }

//usage (only enter the keys you want sorted):

$sorted = multisort($array,'year','name','phone','address');
print_r($sorted);

//output:
Array ( [0] => Array ( [year] => 1978 [name] => Chris [phone] => 3971095 [
address] => Street 1 ) [2] => Array ( [year] => 1982 [name] => Dusty [phone] =>
1541120 [address] => Street 3 ) [1] => Array ( [year] => 1990 [name] => Breanne
[phone] => 3766350 [address] => Street 2 ) )
===============================================================================

In response to the msort function I find that the array_multisort function is a
lot faster.

-John
===============================================================================

Further to john dot dutcher at highmark dot com's comments - padding the name
could cause a problem if you get abnormally long names, it might be better to
rebuild the array thus:

Array (
[0] => Array ( [sortname_01] => Dutcher [sortname_02] => F [sortname_03] =>
John [name] => Dutcher, John F )
[1] => Array ( [sortname_01] => Dutch [sortname_02] => A [sortname_03] => Roger
[name] => Dutch, Roger A )
[2] => Array ( [sortname_01] => Dut [sortname_02] => H [sortname_03] => Maurice
[name] => Dut, Maurice H )
[3] => Array ( [sortname_01] => Dut [sortname_02] => S [sortname_03] => Mildred
[name] => Dut, Mildred S )
)

which should give:

Array (
[0] => Array ( [sortname_01] => Dut [sortname_02] => H [sortname_03] => Maurice
[name] => Dut, Maurice H )
[1] => Array ( [sortname_01] => Dut [sortname_02] => S [sortname_03] => Mildred
[name] => Dut, Mildred S )
[2] => Array ( [sortname_01] => Dutch [sortname_02] => A [sortname_03] => Roger
[name] => Dutch, Roger A )
[3] => Array ( [sortname_01] => Dutcher [sortname_02] => F [sortname_03] =>
John [name] => Dutcher, John F )
)
===============================================================================

this is an implementation of the complement of
Matthew Hood's objectSort (http://my.php.net/manual/en/function.sort.php#75036
), which i found very convenient for sorting objects.

this does the reverse, it sorts according to the key
selected for the object but in reverse order.
and having both sort methods allows consistency and convenience for sorting
objects, if speed isn't your major concern.

the only change ( apart form data being reworded as object )  is the use of <
instead of > in the original.
you could of couse incorporate all in one routine, but why
complicate matters.

<?php
    function objectRSort(&$object, $key)
    {
        for ($i = count($object) - 1; $i >= 0; $i--)
        {
          $swapped = false;
          for ($j = 0; $j < $i; $j++)
          {
               if ($object[$j]->$key < $object[$j + 1]->$key)
               {
                    $tmp = $object[$j];
                    $object[$j] = $object[$j + 1];      
                    $object[$j + 1] = $tmp;
                    $swapped = true;
               }
          }
          if (!$swapped) return;
        }
    }
?>
===============================================================================

To sort an array of multiple text fields alphabetically you have to make the
text lowercase before sorting the array. Otherwise PHP puts acronyms before
words. You can see this in my example code. Simply store the original text
field at the end of the array line and call it later from there. You can safely
ignore the lowercase version which is added to the start of the array line.

<?php
echo '<pre>ORIGINAL DATA:
<br />';

$data = array(
'Saturn|7|8|9|0||',
'Hello|0|1|2|3||',
'SFX|5|3|2|4||',
'HP|9|0|5|6||'
);

print_r($data);

sort($data);
reset($data);

echo '<br />RAW SORT:
<br />';

print_r($data);

for ($c = 0; $c < count($data); $c++) {
    list ($letter,$g1,$g2,$g3,$g4,$end) = explode ('|', $data[$c]);
    $lowercase = strtolower($letter);
    $data2[$c] = array($lowercase,$g1,$g2,$g3,$g4,$letter);
}

sort($data2);
reset($data2);

echo '<br />LOWERCASE SORT:
<br />';

print_r($data2);

echo '</pre>';
?>
===============================================================================

This is my way of sorting files into date modified date order. It worked for
me!

$dir='topics';
$ext='php5';
$files=scandir($dir);
foreach($files as $fs){
    if(($fs!='.')&&($fs!='..')){
        $fs1.='¬'.filemtime($dir.'/'.$fs).'#'.$fs;
    }
}
$fs2=split('[¬]',$fs1);
arsort($fs2);
foreach($fs2 as $fs3){
    if(eregi($ext,$fs3)){
        $fs4.='¬'.$fs3;
    }
}
$fs5=split('[#]',$fs4);
foreach($fs5 as $fs6){
    if(eregi($ext,$fs6)){
        $fs7.='¬'.$fs6;
    }
}
$fs8=split('[¬]',$fs7);
foreach($fs8 as $fs9){
    $file_list.=$fs9.'
</br>';
}

print $file_list;
===============================================================================

If you sort an array of objects, the first variable in the object will be used
for sorting:

<?php
class foo
{
  var $value; //First variable: Used for sorting
  var $id;

  function foo($i, $v)
  {
     $this->id = $i;
     $this->value = $v;
  }

}

for ($i = 0; $i < 10; $i++)
{
  $bar[] = new foo($i,rand(1,10));
}

// This will sort on value
sort($bar);
print_r($bar);
?>

Compare the piece of code above with the following:

<?php
class foo
{
  var $id; //First variable: Used for sorting
  var $value;

  function foo($i, $v)
  {
     $this->id = $i;
     $this->value = $v;
  }

}

for ($i = 0; $i = 10; $i++)
{
  $bar[] = new foo($i,rand(1,10));
}

// This will sort on id
sort($bar);
print_r($bar);
?>

As you can see the location of declaration of the variables matter!
If you want to sort on both or on a combination of variables, use ksort()
===============================================================================

In a brief addition to the previous poster's message, the ascending sorting
order used by PHP directly corresponds to ISO-8859-1 (ASCII). Therefore the
character \48 (numeral 0) would be placed before the character \82 (R), which
would be placed before the character \110 (n), and so forth.
===============================================================================

I had an array like this:
$arr=array (1,4,3,6,5);

which returns this:
$arr[0]=1
$arr[1]=4
$arr[2]=3
$arr[3]=6
$arr[4]=5

But lets say i remove [2] which is number 3, i get:

$arr[0]=1
$arr[1]=4
$arr[3]=6
$arr[4]=5

And i want to reindex without doing a sort because i dont want to lose the
order of the numbers (like a pop in a stack but in the middle of the list), i
do this:

$arr=array_chunk($arr,count($arr));
$arr=$arr[0];

the result is:

$arr[0]=1
$arr[1]=4
$arr[2]=6
$arr[3]=5

This can be applied mostly for tree sorting, when you only have the id and the
parent values of the node, and you want to have N levels.
===============================================================================

For those who wanna go with simple approach without hammering your head too
much... This does the job, granted might not be efficient, but is really short.
:P

Let $all be a key/value paired array...

$keys = array_keys($all);
sort($keys);
$sorted = array();
foreach($keys as $k) {
       $sorted[$k] = $all[$k];
}
$all = $sorted;
unset($sorted);
===============================================================================

I had a multidimensional array, which needed to be sorted by one of the keys.
This is what I came up with...

<?php
function msort($array, $id="id") {
        $temp_array = array();
        while(count($array)>0) {
            $lowest_id = 0;
            $index=0;
            foreach ($array as $item) {
                if ($item[$id]<$array[$lowest_id][$id]) {
                    $lowest_id = $index;
                }
                $index++;
            }
            $temp_array[] = $array[$lowest_id];
            $array = array_merge(array_slice($array, 0,$lowest_id), array_slice
($array, $lowest_id+1));
        }
        return $temp_array;
    }
?>

Ex:

<?php

//oh no, this is not in the ordered by id!!
$data[] = array("item"=>"item 4", "id"=>4);
$data[] = array("item"=>"item 1", "id"=>1);
$data[] = array("item"=>"item 3", "id"=>3);
$data[] = array("item"=>"item 2", "id"=>2);

var_dump(  msort($data)  ); //just msort it!

/* outputs

array
  0 =>
    array
      'item' => 'item 1' (length=6)
      'id' => 1
  1 =>
    array
      'item' => 'item 2' (length=6)
      'id' => 2
  2 =>
    array
      'item' => 'item 3' (length=6)
      'id' => 3
  3 =>
    array
      'item' => 'item 4' (length=6)
      'id' => 4

*/

?>
===============================================================================

when sorting an array, beware of variable type from elements you put in this
array

Example:

$a = 2; // $a is an integer
$b = 'item';
$arr = array($a, $b);
sort($arr);

print_r($arr);

this will output:
$arr[0] = 'item';
$arr[1] = 2;

$a = '2'; // $a is a string
$b = 'item';
$arr = array($a, $b);
sort($arr);

print_r($arr);

this will output:
$arr[0] = '2';
$arr[1] = 'item'

to avoid this problem use:

sort($arr, SORT_STRING)
===============================================================================

Just to show how it sorts:

<?php
$array = Array("1", "2", "3", "4", "5", "6", "7", "8", "9", "0", "a", "b", "c",
"d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s",
"t", "u", "v", "w", "x", "y", "z", "A", "B", "C", "D", "E", "F", "G", "H", "I",
"J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y",
"Z", " ", "!", "@", "#", "\\\$", "%", "^", "&", "*", "(", ")", "_", "-", "=", 
"+", "\\\\", "|", ",", "<", ".", ">", "?", "'", "\\\"", "`", "~");
sort($array);
echo implode("", $array);
?>

returns:

!"#$%&'()*+,-.0123456789<=>?
@ABCDEFGHIJKLMNOPQRSTUVWXYZ
\^_`abcdefghijklmnopqrstuvwxyz|~

note: the result begins with a space
===============================================================================

[EDIT BY danbrown AT php DOT net: The code provided by this anonymous author
contains bugfixes for and additions to code originally donated by "toenie" on
07-NOV-09.  The original author included the following note: "If you want to
sort while using an 2 dimensional array, you can use this script I just wrote
for myself. I thought it could be helpful for other people too."]

I also added the ability to sort in ascending and descending order.

$order = "ASC" will sort the array in ascending order
$order = "DESC" will sort the array in descending order

Here is the code:

<?php
    function order_array_num ($array, $key, $order = "ASC")
    {
        $tmp = array();
        foreach($array as $akey => $array2)
        {
            $tmp[$akey] = $array2[$key];
        }
       
        if($order == "DESC")
        {arsort($tmp , SORT_NUMERIC );}
        else
        {asort($tmp , SORT_NUMERIC );}

        $tmp2 = array();       
        foreach($tmp as $key => $value)
        {
            $tmp2[$key] = $array[$key];
        }       
       
        return $tmp2;
    }
?>
===============================================================================

A tip for those who like "raul at jimi dot com dot mx" need to preserve keys
after changing stuff in the middle of an array:
array_values.

Example:
<?php
$array = array(1, 2, 5, 9, 3);
unset($array[3]); // Remove index 3, which is 9.
$array = array_values($array);
?>

Hint: array_values can be fine for removing keys and reindex them by number
instead, too (applies to functions like posix_pwgetuid which returns an
associative array, unlike C and others, call array_values on it, and it'll be
the same format IIRC.)
===============================================================================

/*
Small function to Alphabetically sort Multidimensional arrays by index values
of an n dimension array.

I have only tested this for sorting an array of up to 6 dimensions by a value
within the second dimension. This code is very rough and works for my purposes,
but has not been tested beyond my needs.

Although a little clunky and not a mathematical type algorithm, it get's the
job done. It theoretically overcomes many of the problems I have seen with
multidimensional arrays in that it is possible to specify within the function,
not by reference :-(, which index you wish to sort by, no matter how many
dimensions down.

call function by assigning it to a new / existing array:

$row_array = multidimsort($row_array);
*/

function multidimsort($array_in) {
     $multiarray = array();
    $array_out = array();
    $loopvalue = 0;
   
    /* -1 as traversal of array starts from 0, count() starts from 1 */
    $multicount = count($array_in) - 1;

    /* add the indexes you wish to sort array by to a new array in this case
index is two levels down, but shouldn't make a difference if it goes further
indexes down. (Not tested!) */
    for($i = 0; $i <= $multicount; $i++) {
        array_push($multiarray, $array_in[$i][2]);
        //array_push($multiarray, $array_in[$i][2][4]);
        //array_push($multiarray, $array_in[$i][1][3][7]);
    }
   
    /* alphabetically sort the new array (Ascending in this case) can chage
sort to whatever type you like. Even apply user-defined sort. */
    asort($multiarray);
   
    /* reset internal pointer to beginning of array after above sort */
    reset($multiarray);
   
    /* traverse new array of index values and add the corresponding element of
the input array to the correct position in the output array */
    while (list ($key, $val) = each ($multiarray)) {
       
        $array_out[$loopvalue] = $array_in[$key];
       
        $loopvalue++;
    }

    /* return the output array which is all nicely sorted by the index you
wanted! */
    return $array_out;
}
