
The APCIterator class

(PECL apc >= 3.1.1)

简介

APCIterator 类使得遍历大容量APC缓存更容易，这是很有帮助的因为它允许同时获取已经
定义的每个被锁定实例的条目数，因此它释放的其他活动的缓存锁，而不是阻碍整个缓存
以完成获取100（默认）个缓存数据的迭代，在大缓存条目。此外，使用正则匹配效率更高
，因为它被改为C级别的实现。

类摘要

APCIterator implements Iterator , Traversable {
/* Methods */
public __construct ( string $cache [, mixed $search = null [, int $format [, 
int $chunk_size = 100 [, int $list ]]]] )
public mixed current ( void )
public int getTotalCount ( void )
public int getTotalHits ( void )
public int getTotalSize ( void )
public string key ( void )
public void next ( void )
public void rewind ( void )
public void valid ( void )
}

Table of Contents

  • APCIterator::__construct — 构造一个 APCIterator 迭代器对象
  • APCIterator::current — 获取当前项
  • APCIterator::getTotalCount — 获取总数
  • APCIterator::getTotalHits — 获取缓存命中数
  • APCIterator::getTotalSize — 获取所有缓存的尺寸大小
  • APCIterator::key — Get iterator key获取迭代器的键
  • APCIterator::next — 移到下一项
  • APCIterator::rewind — 倒退迭代器
  • APCIterator::valid — 检查当前位置是否有效


User Contributed Notes 1 note

===============================================================================

This class will NOT EXIST if the APC extension is installed but disabled in
your php.ini.

This is an important difference to functions like apc_store(), which will still
exist and be callable even when APC is disabled. In many installations, the
default settings are

   apc.enabled = on
   apc.enable_cli = off

which means that APCIterator exists for HTTP requests, but not with the "cli"
SAPI. The solution is to either set "apc.enable_cli" to "on" (with the
resultant startup penalty for CLI scripts), or to check the relevant ini
settings before your script tries to access APCIterator.
