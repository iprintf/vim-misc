
DOMDocument::loadHTMLFile

(PHP 5, PHP 7)

DOMDocument::loadHTMLFile — Load HTML from a file

说明

public bool DOMDocument::loadHTMLFile ( string $filename [, int $options = 0 ]
)

The function parses the HTML document in the file named filename. Unlike
loading XML, HTML does not have to be well-formed to load.

参数

filename

    The path to the HTML file.

options

    Since PHP 5.4.0 and Libxml 2.6.0, you may also use the options parameter to
    specify additional Libxml parameters.

返回值

成功时返回 TRUE，或者在失败时返回 FALSE。 If called statically, returns a
DOMDocument 或者在失败时返回 FALSE.

错误／异常

If an empty string is passed as the filename or an empty file is named, a
warning will be generated. This warning is not generated by libxml and cannot
be handled using libxml's error handling functions.

此方法可以被静态调用,但会抛出一个 E_STRICT 错误。

尽管非正确格式化的 HTML 仍应该被成功调入，但此函数会在遇到错误标记时产生
E_WARNING 错误。libxml 错误处理函数可以用来处理这类错误。

范例

Example #1 Creating a Document

<?php
$doc = new DOMDocument();
$doc->loadHTMLFile("filename.html");
echo $doc->saveHTML();
?>

更新日志

版本            说明
5.4.0 Added options parameter.

参见

  • DOMDocument::loadHTML() - Load HTML from a string
  • DOMDocument::saveHTML() - Dumps the internal document into a string using
    HTML formatting
  • DOMDocument::saveHTMLFile() - Dumps the internal document into a file using
    HTML formatting


User Contributed Notes 6 notes

===============================================================================

<?php
// try this html listing example for all nodes / includes a few
getElementsByTagName options:

$file = $DOCUMENT_ROOT. "test.html";
$doc = new DOMDocument();
$doc->loadHTMLFile($file);

// example 1:
$elements = $doc->getElementsByTagName('*');
// example 2:
$elements = $doc->getElementsByTagName('html');
// example 3:
//$elements = $doc->getElementsByTagName('body');
// example 4:
//$elements = $doc->getElementsByTagName('table');
// example 5:
//$elements = $doc->getElementsByTagName('div');

if (!is_null($elements)) {
  foreach ($elements as $element) {
    echo "<br/>". $element->nodeName. ": ";

    $nodes = $element->childNodes;
    foreach ($nodes as $node) {
      echo $node->nodeValue. "\n";
    }
  }
}
?>
===============================================================================

The options for surpressing errors and warnings will not work with this as they
do for loadXML()
e.g.
<?php
$doc->loadHTMLFile($file, LIBXML_NOWARNING | LIBXML_NOERROR);
?>
will not work.
you must use:
<?php
libxml_use_internal_errors(true);
$doc->loadHTMLFile($file);
?>
and handle the exceptions as neccesarry.
===============================================================================

In this post http://softontherocks.blogspot.com/2014/11/
descargar-el-contenido-de-una-url_11.html I found a simple way to get the
content of a URL with DOMDocument, loadHTMLFile and saveHTML().

function getURLContent($url){
    $doc = new DOMDocument;
    $doc->preserveWhiteSpace = FALSE;
    @$doc->loadHTMLFile($url);
    return $doc->saveHTML();
}
===============================================================================

This puts the HTML into a DOM object which can be parsed by individual tags,
attributes, etc..  Here is an example of getting all the 'href' attributes and
corresponding node values out of the 'a' tag. Very cool....

<?php
$myhtml = <<<EOF
<html>
<head>
<title>My Page</title>
</head>
<body>
<p><a href="/mypage1">Hello World!</a></p>
<p><a href="/mypage2">Another Hello World!</a></p>
</body>
</html>
EOF;

$doc = new DOMDocument();
$doc->loadHTML($myhtml);

$tags = $doc->getElementsByTagName('a');

foreach ($tags as $tag) {
       echo $tag->getAttribute('href').' | '.$tag->nodeValue."\n";
}
?>

This should output:

/mypage1 | Hello World!
/mypage2 | Another Hello World!
===============================================================================

If you want to suppress output warnings from loadHTMLFile($url), put an @ sign
in front. This even works in:
<?php
$load = @$dom->loadHTMLFile($url);
?>
===============================================================================

Note that this function doesn't parse the individual tags WITHIN the html file
- it's all loaded as a "black box", and you end up with an XML widget that
comprises nothing but the complete chunk of HTML.

I was hoping it would function as a sort of HTML-validator/parser, but that
doesn't seem to be the case.
