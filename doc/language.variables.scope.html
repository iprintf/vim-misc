
变量范围

变量的范围即它定义的上下文背景（也就是它的生效范围）。大部分的 PHP 变量只有一个
单独的范围。这个单独的范围跨度同样包含了 include 和 require 引入的文件。例如：

<?php
$a = 1;
include 'b.inc';
?>

这里变量 $a 将会在包含文件 b.inc 中生效。但是，在用户自定义函数中，一个局部函数
范围将被引入。任何用于函数内部的变量按缺省情况将被限制在局部函数范围内。例如：

<?php
$a = 1; /* global scope */

function Test()
{
    echo $a; /* reference to local scope variable */
}

Test();
?>

这个脚本不会有任何输出，因为 echo 语句引用了一个局部版本的变量 $a，而且在这个范
围内，它并没有被赋值。你可能注意到 PHP 的全局变量和 C 语言有一点点不同，在 C 语
言中，全局变量在函数中自动生效，除非被局部变量覆盖。这可能引起一些问题，有些人
可能不小心就改变了一个全局变量。PHP 中全局变量在函数中使用时必须声明为 global。

global 关键字

首先，一个使用 global 的例子：

Example #1 使用 global

<?php
$a = 1;
$b = 2;

function Sum()
{
    global $a, $b;

    $b = $a + $b;
}

Sum();
echo $b;
?>

以上脚本的输出将是“3”。在函数中声明了全局变量 $a 和 $b 之后，对任一变量的所有引
用都会指向其全局版本。对于一个函数能够声明的全局变量的最大个数，PHP 没有限制。

在全局范围内访问变量的第二个办法，是用特殊的 PHP 自定义 $GLOBALS 数组。前面的例
子可以写成：

Example #2 使用 $GLOBALS 替代 global

<?php
$a = 1;
$b = 2;

function Sum()
{
    $GLOBALS['b'] = $GLOBALS['a'] + $GLOBALS['b'];
}

Sum();
echo $b;
?>

$GLOBALS 是一个关联数组，每一个变量为一个元素，键名对应变量名，值对应变量的内容
。$GLOBALS 之所以在全局范围内存在，是因为 $GLOBALS 是一个超全局变量。以下范例显
示了超全局变量的用处：

Example #3 演示超全局变量和作用域的例子

<?php
function test_global()
{
    // 大多数的预定义变量并不 "super"，它们需要用 'global' 关键字来使它们在函数
的本地区域中有效。
    global $HTTP_POST_VARS;

    echo $HTTP_POST_VARS['name'];

    // Superglobals 在任何范围内都有效，它们并不需要 'global' 声明。
Superglobals 是在 PHP 4.1.0 引入的。
    echo $_POST['name'];
}
?>

使用静态变量

变量范围的另一个重要特性是静态变量（static variable）。静态变量仅在局部函数域中
存在，但当程序执行离开此作用域时，其值并不丢失。看看下面的例子：

Example #4 演示需要静态变量的例子

<?php
function Test()
{
    $a = 0;
    echo $a;
    $a++;
}
?>

本函数没什么用处，因为每次调用时都会将 $a 的值设为 0 并输出 0。将变量加一的
$a++ 没有作用，因为一旦退出本函数则变量 $a 就不存在了。要写一个不会丢失本次计数
值的计数函数，要将变量 $a 定义为静态的：

Example #5 使用静态变量的例子

<?php
function test()
{
    static $a = 0;
    echo $a;
    $a++;
}
?>

现在，变量 $a 仅在第一次调用 test() 函数时被初始化，之后每次调用 test() 函数都
会输出 $a 的值并加一。

静态变量也提供了一种处理递归函数的方法。递归函数是一种调用自己的函数。写递归函
数时要小心，因为可能会无穷递归下去。必须确保有充分的方法来中止递归。以下这个简
单的函数递归计数到 10，使用静态变量 $count 来判断何时停止：

Example #6 静态变量与递归函数

<?php
function test()
{
    static $count = 0;

    $count++;
    echo $count;
    if ($count < 10) {
        test();
    }
    $count--;
}
?>

    Note:

    静态变量可以按照上面的例子声明。如果在声明中用表达式的结果对其赋值会导致解
    析错误。

    Example #7 声明静态变量

    <?php
    function foo(){
        static $int = 0;          // correct
        static $int = 1+2;        // wrong  (as it is an expression)
        static $int = sqrt(121);  // wrong  (as it is an expression too)

        $int++;
        echo $int;
    }
    ?>

静态声明是在编译时解析的。

    Note:

    在函数之外使用 global 关键字不算错。可以用于在一个函数之内包含文件时。

全局和静态变量的引用

在 Zend 引擎 1 代，它驱动了 PHP4，对于变量的 static 和 global 定义是以引用的方
式实现的。例如，在一个函数域内部用 global 语句导入的一个真正的全局变量实际上是
建立了一个到全局变量的引用。这有可能导致预料之外的行为，如以下例子所演示的：

<?php
function test_global_ref() {
    global $obj;
    $obj = &new stdclass;
}

function test_global_noref() {
    global $obj;
    $obj = new stdclass;
}

test_global_ref();
var_dump($obj);
test_global_noref();
var_dump($obj);
?>

以上例程会输出：


NULL
object(stdClass)(0) {
}

类似的行为也适用于 static 语句。引用并不是静态地存储的：

<?php
function &get_instance_ref() {
    static $obj;

    echo 'Static object: ';
    var_dump($obj);
    if (!isset($obj)) {
        // 将一个引用赋值给静态变量
        $obj = &new stdclass;
    }
    $obj->property++;
    return $obj;
}

function &get_instance_noref() {
    static $obj;

    echo 'Static object: ';
    var_dump($obj);
    if (!isset($obj)) {
        // 将一个对象赋值给静态变量
        $obj = new stdclass;
    }
    $obj->property++;
    return $obj;
}

$obj1 = get_instance_ref();
$still_obj1 = get_instance_ref();
echo "\n";
$obj2 = get_instance_noref();
$still_obj2 = get_instance_noref();
?>

以上例程会输出：


Static object: NULL
Static object: NULL

Static object: NULL
Static object: object(stdClass)(1) {
["property"]=>
int(1)
}

上例演示了当把一个引用赋值给一个静态变量时，第二次调用 &get_instance_ref() 函数
时其值并没有被记住。


User Contributed Notes 65 notes

===============================================================================

Some interesting behavior (tested with PHP5), using the static-scope-keyword
inside of class-methods.

<?php

class sample_class
{
  public function func_having_static_var($x = NULL)
  {
    static $var = 0;
    if ($x === NULL)
    { return $var; }
    $var = $x;
  }
}

$a = new sample_class();
$b = new sample_class();

echo $a->func_having_static_var()."\n";
echo $b->func_having_static_var()."\n";
// this will output (as expected):
//  0
//  0

$a->func_having_static_var(3);

echo $a->func_having_static_var()."\n";
echo $b->func_having_static_var()."\n";
// this will output:
//  3
//  3
// maybe you expected:
//  3
//  0

?>

One could expect "3 0" to be outputted, as you might think that $a->
func_having_static_var(3); only alters the value of the static $var of the
function "in" $a - but as the name says, these are class-methods. Having an
object is just a collection of properties, the functions remain at the class.
So if you declare a variable as static inside a function, it's static for the
whole class and all of its instances, not for each object.

Maybe it's senseless to post that.. cause if you want to have the behaviour
that I expected, you can simply use a variable of the object itself:

<?php
class sample_class
{ protected $var = 0;
  function func($x = NULL)
  { $this->var = $x; }
} ?>

I believe that all normal-thinking people would never even try to make this
work with the static-keyword, for those who try (like me), this note maybe
helpfull.
===============================================================================

Note that unlike Java and C++, variables declared inside blocks such as loops
or if's, will also be recognized and accessible outside of the block, so:
<?php
for($j=0; $j<3; $j++)
{
     if($j == 1)
        $a = 4;
}
echo $a;
?>

Would print 4.
===============================================================================

Please note for using global variable in child functions:

This won't work correctly...

<?php
function foo(){
    $f_a = 'a';
   
    function bar(){
        global $f_a;
        echo '"f_a" in BAR is: ' . $f_a . '<br />';  // doesn't work, var is
empty!
    }
   
    bar();
    echo '"f_a" in FOO is: ' . $f_a . '<br />';
}
?>

This will...

<?php
function foo(){
    global $f_a;   // <- Notice to this
    $f_a = 'a';
   
    function bar(){
        global $f_a;
        echo '"f_a" in BAR is: ' . $f_a . '<br />';  // work!, var is 'a'
    }
   
    bar();
    echo '"f_a" in FOO is: ' . $f_a . '<br />';
}
?>
===============================================================================

For nested functions:

This is probably obvious to most people, but global always refers to the
variable in the global (top level) variable of that name, not just a variable
in a higher-level scope. So this will not work:
<?php

// $var1 is not declared in the global scope

function a($var1){

    function b(){
        global $var1;
        echo $var1; // there is no var1 in the global scope so nothing to echo
   
    }

    b();
}

a('hello');

?>
===============================================================================

Take to heart this hard-won rule:
        Declare AT THE TOP any variable that is to be global.
        Both at the top of the FILE
        AND at the top of any FUNCTION where it appears.

Why AT THE TOP? So it is sure to be declared before use. Otherwise a non-global
version of the variable will be created and your code will fail.

Why at the top of a FUNCTION? Because otherwise the function will refer only to
its local version of the variable and your code will fail.

Why at the top of the FILE? Because someday--a day that you cannot now
imagine--you will want to "include" the file. And when you do, instances of the
variable outside functions will not go in the global scope and your code will
fail. (When the "include" is inside a calling function, variables in the
included file go into the scope of the calling function.)

Example file where variable $x is used outside and inside functions:
    |<!DOCTYPE html ...>
    |<html xmlns ...>
    |    <?php global $x; ?>
    |<head>
    |    Some html headers
    |    <?php
    |        $x = 1;
    |        function bump_x() {
    |            global $x;
    |            $x += 1;
    |        }
    |    ?>
    |</head>
    |<body>
    |    More html
    |    <?php echo $x; bump_x(); ?>
    |    Yet more html.
    |</body>
</html>
===============================================================================

Static variables do not hold through inheritance.  Let class A have a function
Z with a static variable.  Let class B extend class A in which function Z is
not overwritten.  Two static variables will be created, one for class A and one
for class B.

Look at this example:

<?php
class A {
    function Z() {
        static $count = 0;       
        printf("%s: %d\n", get_class($this), ++$count);
    }
}

class B extends A {}

$a = new A();
$b = new B();
$a->Z();
$a->Z();
$b->Z();
$a->Z();
?>

This code returns:

A: 1
A: 2
B: 1
A: 3

As you can see, class A and B are using different static variables even though
the same function was being used.
===============================================================================

More on static variables:

A static variable does not retain it's value after the script's execution.
Don't count on it being available from one page request to the next; you'll
have to use a database for that.

Second, here's a good pattern to use for declaring a static variable based on
some complex logic:

<?php
  function buildStaticVariable()
  {
      $foo = null;
      // some complex expression or set of
      // expressions/statements to build
      // the return variable.
      return $foo;
  }

  function functionWhichUsesStaticVar()
  {
      static $foo = null;
      if($foo === null) $foo = buildStaticVariable();
      // the rest of your code goes here.
  }
?>

Using such a pattern allows you to separate the code that creates your default
static variable value from the function that uses it. Easier to maintain code
is good. :)
===============================================================================

Sometimes a variable available in global scope is not accessible via the
'global' keyword or the $GLOBALS superglobal array. I have not been able to
replicate it in original code, but it occurs when a script is run under
PHPUnit.

PHPUnit provides a variable "$filename" that reflects the name of the file
loaded on its command line. This is available in global scope, but not in
object scope. For example, the following phpUnit script (call it
GlobalScope.php):

<?php
print "Global scope FILENAME [$filename]\n";
class MyTestClass extends PHPUnit_Framework_TestCase {
  function testMyTest() {
    global $filename;
    print "Method scope global FILENAME [$filename]\n";
    print "Method scope GLOBALS[FILENAME] [".$GLOBALS["filename"]."]\n";
  }
}
?>

If you run this script via "phpunit GlobalScope.php", you will get:

Global scope FILENAME [/home/ktyler/GlobalScope.php]
PHPUnit 3.4.5 by Sebastian Bergmann.

Method scope global FILENAME []
Method scope GLOBALS[FILENAME] []
.

You have to -- strange as it seems -- do the following:

<?php
$GLOBALS["filename"]=$filename;
print "Global scope FILENAME [$filename]\n";
class MyTestClass extends PHPUnit_Framework_TestCase {
  function testMyTest() {
    global $filename;
    print "Method scope global FILENAME [$filename]\n";
    print "Method scope GLOBALS[FILENAME] [".$GLOBALS["filename"]."]\n";
  }
}
?>

By doing this, both "global" and $GLOBALS work!

I don't know what it is that PHPUnit does (I know it uses Reflection) that
causes a globally available variable to be implicitly unavailable via "global"
or $GLOBALS. But there it is.
===============================================================================

Took me longer than I expected to figure this out, and thought others might
find it useful.

I created a function (safeinclude), which I use to include files; it does
processing before the file is actually included (determine full path, check it
exists, etc).

Problem: Because the include was occurring inside the function, all of the
variables inside the included file were inheriting the variable scope of the
function; since the included files may or may not require global variables that
are declared else where, it creates a problem.

Most places (including here) seem to address this issue by something such as:
<?php
//declare this before include
global $myVar;
//or declare this inside the include file
$nowglobal = $GLOBALS['myVar'];
?>

But, to make this work in this situation (where a standard PHP file is included
within a function, being called from another PHP script; where it is important
to have access to whatever global variables there may be)... it is not
practical to employ the above method for EVERY variable in every PHP file being
included by 'safeinclude', nor is it practical to staticly name every possible
variable in the "global $this" approach. (namely because the code is modulized,
and 'safeinclude' is meant to be generic)

My solution: Thus, to make all my global variables available to the files
included with my safeinclude function, I had to add the following code to my
safeinclude function (before variables are used or file is included)

<?php
foreach ($GLOBALS as $key => $val) { global $$key; }
?>

Thus, complete code looks something like the following (very basic model):

<?php
function safeinclude($filename)
{
    //This line takes all the global variables, and sets their scope within the
function:
    foreach ($GLOBALS as $key => $val) { global $$key; }
    /* Pre-Processing here: validate filename input, determine full path
        of file, check that file exists, etc. This is obviously not
        necessary, but steps I found useful. */
    if ($exists==true) { include("$file"); }
    return $exists;
}
?>

In the above, 'exists' & 'file' are determined in the pre-processing. File is
the full server path to the file, and exists is set to true if the file exists.
This basic model can be expanded of course.  In my own, I added additional
optional parameters so that I can call safeinclude to see if a file exists
without actually including it (to take advantage of my path/etc preprocessing,
verses just calling the file exists function).

Pretty simple approach that I could not find anywhere online; only other
approach I could find was using PHP's eval().
===============================================================================

I was pondering a little something regarding caching classes within a function
in order to prevent the need to initiate them multiple times and not clutter
the caching function's class properties with more values.

I came here because I remembered something about references being lost. So I
made a test to see if I could pull what I wanted to off anyway. Here's and
example of how to get around the references lost issue. I hope it is helpful to
someone else!

<?php
class test1{}
class test2{}
class test3{}

function cache( $class )
{
    static $loaders = array();
   
    $loaders[ $class ] = new $class();

    var_dump( $loaders );
}
print '<pre>';
cache( 'test1' );
cache( 'test2' );
cache( 'test3' );

?>
===============================================================================

It will be obvious for most of you: changing value of a static in one instance
changes value in all instances.

<?php

    class example {
        public static $s = 'unchanged';
       
        public function set() {
            $this::$s = 'changed';
        }
    }

    $o = new example;
    $p = new example;

    $o->set();

    print "$o static: {$o::$i}\n$p static: {$p::$i}";

?>

Output will be:

$o static: changed
$p static: changed
===============================================================================

There're times when global variables comes in handy, like universal read only
resources you just need to create once in your application and share to the
rest of your scripts. But it may become quite hard to track with "variables".
===============================================================================

Just a note about static properties declared at class level:

class Test_Class {
  static $a = 0;
  public function ReturnVar(){
    return $this->a;
  }
  }
  $b = new Test_Class();
  echo $b->ReturnVar();

Will not output "0"  because $a is declared static. Changing "static" to
"public" or "private" will produce the output "0".
===============================================================================

Be careful with "require", "require_once" and "include" inside functions. Even
if the included file seems to define global variables, they might not be
defined as such.

consider those two files:

---index.php------------------------------
<?php
function foo() {
require_once("class_person.inc");

$person= new Person();
echo $person->my_flag; // should be true, but is undefined
}

foo();
?>

---class_person.inc----------------------------
<?php
$seems_global=true;

class Person {
  public $my_flag;

public function  __construct() {
   global $seems_global;
   $my_flag= $seems_global
}
}
?>

---------------------------------

The reason for this behavior is quiet obvious, once you figured it out. Sadly
this might not be always as easy as in this example. A solution  would be to
add the line...

<?php global $seems_global; ?>

at the beginning of "class_person.inc". That makes sure you set the global-var.

   best regards
    tom

ps: bug search time approx. 1 hour.
===============================================================================

WARNING!  If you create a local variable in a function and then within that
function assign it to a global variable by reference the object will be
destroyed when the function exits and the global var will contain NOTHING! 
This main sound obvious but it can be quite tricky you have a large script
(like a phpgtk-based gui app ;-) ).

example:

<?php
function foo ()
{
   global $testvar;

   $localvar = new Object ();
   $testvar = &$localvar;
}

foo ();
print_r ($testvar);   // produces NOTHING!!!!
?>

hope this helps someone before they lose all their hair
===============================================================================

Quick tip for beginners just to speed things up:
If you have a bunch of global variables to import into a function, it's best to
put them into a named array like $variables[stuff].
When it's time to import them you just so the following;

<?php
function here() {
  $vars = $GLOBALS['variables'];
  print $vars[stuff];

}
?>

This really helps with big ugly form submissions.
===============================================================================

Variable "Visibility" in PHP Object Oriented Programming is documented here:
http://php.net/manual/en/language.oop5.visibility.php
===============================================================================

Note that if you declare a variable in a function, then set it as global in
that function, its value will not be retained outside of that function.  This
was tripping me up for a while so I thought it would be worth noting.

<?PHP

foo();
echo $a; // echoes nothing

bar();
echo $b; //echoes "b";

function foo() {
  $a = "a";
  global $a;
}

function bar() {
  global $b;
  $b = "b";
}

?>
===============================================================================

Another way of working with a large ammount of global variables could be the
following.

<?php

$var = "3";
$smarty = new Smarty();

function headers_set_404() {
extract($globals);

echo $var . "<br />";
print_r($smarty);

return;

}

?>

Regards,
Droope
===============================================================================

Use the superglobal array $GLOBALS is faster than the global keyword. See:

<?php
//Using the keyword global
$a=1;
$b=2;
function sum() {
    global $a, $b;
    $a += $b;
}

$t = microtime(true);
for($i=0; $i<1000; $i++) {
     sum();
}
echo microtime(true)-$t;
echo " -- ".$a."<br>";

//Using the superglobal array
$a=1;
$b=2;
function sum2() {
    $GLOBALS['a'] += $GLOBALS['b'];
}

  $t = microtime(true);
for($i=0; $i<1000; $i++) {
     sum2();
}
echo microtime(true)-$t;
echo " -- ".$a."<br>";
?>
===============================================================================

About more complex situation using global variables..

Let's say we have two files:
a.php
<?php
    function a() {
        include("b.php");
    }
    a();
?>

b.php
<?php
    $b = "something";
    function b() {
        global $b;
        $b = "something new";
    }
    b();
    echo $b;
?>

You could expect that this script will return "something new" but no, it will
return "something". To make it working properly, you must add global keyword in
$b definition, in above example it will be:

global $b;
$b = "something";
===============================================================================

Pay attention while unsetting variables inside functions:

<?php
$a = "1234";
echo "<pre>";
echo "outer: $a\n";
function testa()
{
    global $a;
    echo "   inner testa: $a\n";
    unset ($a);
    echo "   inner testa: $a\n";
}
function testb()
{
    global $a;
    echo "   inner testb: $a\n";
    $a = null;
    echo "   inner testb: $a\n";
}
testa();
echo "outer: $a\n";
testb();
echo "outer: $a\n";
echo "</pre>";
?>

/***** Result:
outer: 1234
   inner testa: 1234
   inner testa:
outer: 1234
   inner testb: 1234
   inner testb:
outer:
******/

Took me 1 hour to find out why my variable was still there after unsetting it
...

Thomas Candrian
===============================================================================

Becareful where you define your global variables:

This will work:
<?php
  $MyArray = array("Dog");

  function SeeArray(){
    global $MyArray;
    if (in_array("Dog",$MyArray)){
      foreach ($MyArray as $Element){
        echo "$Element <hr/>";
      }
    }
  }

  SeeArray();
?>

while this will not:
<?php
  SeeArray();
  $MyArray = array("Dog");

  function SeeArray(){
    global $MyArray;
    if (in_array("Dog",$MyArray)){ // an error will generate here
      foreach ($MyArray as $Element){
        echo "$Element <hr/>";
      }
    }
  }

?>
===============================================================================

If you use __autoload function to load classes' definitons, beware that "static
local variables are resolved at compile time" (whatever it really means) and
the order in which autoloads occur may impact the semantic.

For example if you have:
<?php
class Singleton{
  static public function get_instance(){
     static $instance = null;
     if($instance === null){
        $instance = new static();
     }
     return $instance;
  }
}
?>

and two separate files A.php and B.php:
class A extends Singleton{}
class B extends A{}

then depending on the order in which you access those two classes, and
consequently, the order in which __autoload includes them, you can get strange
results of calling B::get_instance() and A::get_instance().

It seems that static local variables are alocated in as many copies as there
are classes that inherit a method at the time of inclusion of parsing
Singleton.
===============================================================================

Like functions, if you declare a variable in a class, then set it as global in
that class, its value will not be retained outside of that class either.

<?php
class global_reference
{
    public $val;
   
    public function __construct () {
        global $var;
        $this->val = $var;
    }
   
    public function dump_it ()
    {
        debug_zval_dump($this->val);
    }
   
    public function type_cast ()
    {
        $this->val = (int) $this->val;
    }
}
$var = "x";
$obj = new global_reference();
$obj->dump_it();
$obj->type_cast();
echo "after change ";
$obj->dump_it();
echo "original $var\n";
?>

The work-around is of course changing the assignment in the constructor to a
reference assignment as such:

<?php
    //....
        $this->val = &var;
    //....
?>

If the global you're setting is an object then no reference is necessary
because of the way PHP deals with objects. If you don't want to reference to
the same object however you can use the clone keyword.

<?php
//...
    global $Obj;
    $this->obj_copy = clone $Obj;
//...
?>

[EDIT BY danbrown AT php DOT net:  Merged all thoughts and notes by this author
into a single note.]
===============================================================================

In fact all variables represent pointers that hold address of memory area with
data that was assigned to this variable. When you assign some variable value by
reference you in fact write address of source variable to recepient variable.
Same happens when you declare some variable as global in function, it receives
same address as global variable outside of function. If you consider
forementioned explanation it's obvious that mixing usage of same variable
declared with keyword global and via superglobal array at the same time is very
bad idea. In some cases they can point to different memory areas, giving you
headache. Consider code below:

<?php

error_reporting(E_ALL);

$GLOB = 0;

function test_references() {
    global $GLOB; // get reference to global variable using keyword global, at
this point local variable $GLOB points to same address as global variable $GLOB
    $test = 1; // declare some local var
    $GLOBALS['GLOB'] = &$test; // make global variable reference to this local
variable using superglobal array, at this point global variable $GLOB points to
new memory address, same as local variable $test

    $GLOB = 2; // set new value to global variable via earlier set local
representation, write to old address

    echo "Value of global variable (via local representation set by keyword
global): $GLOB <hr>";
    // check global variable via local representation => 2 (OK, got value that
was just written to it, cause old address was used to get value)

    echo "Value of global variable (via superglobal array GLOBALS): $GLOBALS[
GLOB] <hr>";
    // check global variable using superglobal array => 1 (got value of local
variable $test, new address was used)
   
    echo "Value ol local variable \$test: $test <hr>";
    // check local variable that was linked with global using superglobal array
=> 1 (its value was not affected)
   
    global $GLOB; // update reference to global variable using keyword global,
at this point we update address that held in local variable $GLOB and it gets
same address as local variable $test
    echo "Value of global variable (via updated local representation set by
keyword global): $GLOB <hr>";
    // check global variable via local representation => 1 (also value of local
variable $test, new address was used)
}

test_references();
echo "Value of global variable outside of function: $GLOB <hr>";
// check global variable outside function => 1 (equal to value of local
variable $test from function, global variable also points to new address)
?>
===============================================================================

<?php
$var = 1;
function foo() {
    $var = &$GLOBALS['var'];
    var_dump($var);
}
function bar() {
    global $var; // they are the same.
    var_dump($var);
}
foo();
bar();
var_dump($var);
?>

In a function, 'global $var;' is to declare a local variant, and the local $var
has the same reference to the global $var.

<?php
$var = 1;
function foo() {
    global $var;
    unset($var);               // unset local $a, the global $a is still there.
    var_dump($var);            // Undefined variable: var
    var_dump($GLOBALS['var']); // this is ok.
}
foo();
var_dump($var);                // this is ok.
?>

<?php
$var = 1;
function bar() {
    global $var;
    unset($GLOBALS['var']);    // unset global $a, the local $a is still here.
    var_dump($var);            // this is ok.
    var_dump($GLOBALS['var']); // Undefined index: var
}
foo();
var_dump($var);                // Undefined variable: var
?>

'unset($var);' is like 'var = NULL;'(var is a pointer) in the C language,
instead of 'free(var);'
===============================================================================

Be careful when using autoloaders:
Any variables that are declared in autoloaded files in global context are in
fact local variables to the autoload function.
Suggestion:
Use explicit global keyword even in global context of a file.
===============================================================================

<?php

// if you really want to create a variable within its own scope
// that does not have access to variables outside its scope create a function

$var = "hello";

$func = function(){

      // declare variables here that will only last throughout this scope

     if( !isset($var) ) // var will not be set in this scope
     {
        $var = "i was out of scope";
     }
     
      echo $var;

};

echo "$var<br />";

$func(); // invoke the function

echo "<br />".'$var'." never changed from $var";

?>

outputs :

hello
i was out of scope
$var never changed from hello
===============================================================================

Interesting behavior in PHP 5.6.12 and PHP 7 RC3:

<?php
class Foo {
    public function Bar() {
        static $var = 0;
       
        return ++$var;
    }
}

$Foo_instance = new Foo;

print $Foo_instance->Bar(); // prints 1
print PHP_EOL;

unset($Foo_instance);

$Foo_instance2 = new Foo;

print $Foo_instance2->Bar(); // prints 2
print PHP_EOL;
?>

How can a 2 be printed, since we unseted the whole instance before?

Consider a similar example:

<?php
class Foo {
    public static $var = 0;
   
    public static function Bar() {
        return ++self::$var;
    }
}

$Foo_instance = new Foo;

print $Foo_instance->Bar(); // prints 1
print PHP_EOL;

unset($Foo_instance);

$Foo_instance2 = new Foo;

print $Foo_instance2->Bar(); // prints 2
print PHP_EOL;
?>

No idea why is this happening.
===============================================================================

If you are used to include files which declare global variables, and if you now
need to include these files in a function, you will see that those globals are
declared in the function's scope and so they will be lost at the end of the
function.

You may use something like this to solve this problem:

main_file.php :
<?php

//Some innocent variables which exist before the problem
$a = 42;
$b = 33;
$c = 56;

function some_function() {
    //Some variables that we don't want out of the function
    $saucisse = "saucisse";
    $jambon = "jambon";
   
    //Let's include another file
    $evalt = "require_once 'anothertest_include.php';";
    $before_eval_vars = get_defined_vars();
    eval($evalt);

    //Let's extract the variables that were defined AFTER the call to 'eval'
    $function_variable_names = array("function_variable_names" => 0, 
"before_eval_vars" => 0, "created" => 0);
    //We can generate a list of the newly created variables by substracting the
list of the variables of the function and the list of the variables which
existed before the call to the list of current variables at this point
    $created = array_diff_key(get_defined_vars(), $GLOBALS, 
$function_variable_names, $before_eval_vars);
    //Now we globalize them
    foreach ($created as $created_name => $on_sen_fiche)
        global $$created_name;
    //And we affect them
    extract($created);
   
}

some_function();
print_r(get_defined_vars());

?>

included_file.php :
<?php

//Some variables that we want in the global scope of main_file.php
$included_var_one = 123;
$included_var_two = 465;
$included_var_three = 789;

?>
===============================================================================

i found out that on any (still not found) reason the <?php static $val =NULL; 
?> is not working when trying to extract the data form the $var with a while
statment
e.g.:
<?php
funktion get_data() {
static $myarray = null;
   if($myarray == NULL) {
     //get some info in an array();
     $myarray = array('one','two');
   }
   while(list($key,$val) = each( $myarray ) ) {
   // do something
   echo "x: $key , y: $val";
   }
}
?>
when using foreach($myarray AS $key => $val) { .... instad of while then i see
the result!
===============================================================================

External variables in a function

I needed to access dynamically-created variables from an included file within a
helper function. Because the list of $path_* variables I needed to access from
the other file is itself dynamic, I didn't want to have to declare all possible
variables within the function, and I was concerned at the overhead of declaring
=all= members of $GLOBALS[] as global. However the following code worked for
me:

<?php
  function makePath($root, $atom) {
    $pos = strrpos($atom, '/');
    if ($pos === false) {
      global ${'path_'.$atom}; 
      $path = ${'path_'.$atom};
    }
    else {
      global ${'path_'.substr($atom, 0, $pos)};
      $path = ${'path_'.substr($atom, 0, $pos)};
    }
    if ($path)
      return ($pos === false)
        ? $root.$path
        : $root.$path.substr($atom, $pos + 1);
    else
      return NULL;
  }
?>

Regards,

::Leigh
===============================================================================

Useful function:
<?php
function cycle($a, $b, $i=0) {
    static $switches = array();
    if (isset($switches[$i])) $switches[$i] = !$switches[$i]; else !$switches[
$i] = true;
    return ($switches[$i])?$a:$b;
}
?>

Exeample

<?php
for ($i = 1; $i<3; $i++) {
    echo $i.cycle('a', 'b').PHP_EOL;
    for ($j = 1; $j<5; $j++) {
        echo ' '.$j.cycle('a', 'b', 1).PHP_EOL;
        for ($k = 1; $k<3; $k++) {
            echo '  '.$k.cycle('c', 'd', 2).PHP_EOL;
        }
    }
}
/**
Output:
1a
1a
  1c
  2d
2b
  1c
  2d
3a
  1c
  2d
4b
  1c
  2d
2b
1a
  1c
  2d
2b
  1c
  2d
3a
  1c
  2d
4b
  1c
  2d
*/

?>
===============================================================================

Using the global keyword inside a function to define a variable is essentially
the same as passing the variable by reference as a parameter:

<?php
somefunction(){
   global $var;
}
?>

is the same as:

<?php
somefunction(& $a) {

}
?>

The advantage to using the keyword is if you have a long list of variables 
needed by the function - you dont have to pass them every time you call the
function.
===============================================================================

PHP 5.1.4 doesn't seem to care about the static keyword. It doesn't let you use
$this in a static method, but you can call class methods through an instance of
the class using regular -> notation. You can also call instance methods as
class methods through the class itself. The documentiation here is plain wrong.

<?php
class Foo {
  public static function static_fun()
  {
    return "This is a class method!\n";
  }
 
  public function not_static_fun()
  {
    return "This is an instance method!\n";
  }
}

echo '<pre>';
echo "From Foo:\n";
echo Foo::static_fun();
echo Foo::not_static_fun();
echo "\n";

echo "From \$foo = new Foo():\n";
$foo = new Foo();
echo $foo->static_fun();
echo $foo->not_static_fun();
echo '</pre>';
?>

You'll see the following output:

From Foo:
This is a class method!
This is an instance method!

From $foo = new Foo():
This is a class method!
This is an instance method!
===============================================================================

If you want to access a table row using $GLOBALS, you must do it outside string
delimiters or using curl braces :

<?php
$siteParams["siteName"] = "myweb";

function foo() {
$table = $GLOBALS["siteParams"]["siteName"]."articles";  // OK
echo $table; // output  "mywebarticles"
$table = "{$GLOBALS["siteParams"]["siteName"]}articles"; // OK
echo $table; // output  "mywebarticles"
$table = "$GLOBALS[siteParams][siteName]articles";       // Not OK
echo $table; // output  "Array[siteName]article"

$result = mysql_query("UPDATE $table ...");
}
?>

Or use global :

<?php
function foo() {
global $siteParams;
$table = "$siteParams[siteName]articles";         // OK
echo $table; // output  "mywebarticles"

$result = mysql_query("UPDATE $table ...");
}
?>
===============================================================================

Sometimes in PHP 4 you need static variabiles in class. You can do it by
referencing static variable in constructor to the class variable:

<?php
class test  {

   var $var;
   var $static_var;
    function test()
    {
        static $s;
        $this->static_var =& $s;
    }
 
}

$a=new test();

$a->static_var=4;
$a->var=4;

$b=new test();

echo $b->static_var; //this will output 4
echo $b->var; //this will output nul
?>
===============================================================================

If you need all your global variables available in a function, you can use
this:

<?php
function foo() {
  extract($GLOBALS);
  // here you have all global variables

}
?>
===============================================================================

Some times you need to access the same static in more than one function. There
is an easy way to solve this problem:

<?php
  // We need a way to get a reference of our static
  function &getStatic() {
    static $staticVar;
    return $staticVar;
  }

  // Now we can access the static in any method by using it's reference
  function fooCount() {
    $ref2static = & getStatic();
    echo $ref2static++;
  }

  fooCount(); // 0
  fooCount(); // 1
  fooCount(); // 2
?>
===============================================================================

Whats good for the goose is not always good for the iterative gander. If you
declare and initialize the static variable more than once inside a function ie.

<?php
function Test(){
   static $count = 0;
   static $count = 1;
   static $count = 2;
   echo $count;
}
?>

the variable will take the value of the last declaration. In this case $count=
2.

But! however when you make that function recursive ie.

<?php
  function Test(){
   static $count = 0;
   static $count = 1;
   static $count = 2;

   $count++;
   echo $count;
   if ($count<10){
     Test();
   }
  }
?>

Every call to the function Test() is a differenct SCOPE and therefore the
static declarations and initializations are NOT executed again. So what Im
trying to say is that its OK to declare and initialize a static variable
multiple times if you are in one function... but its NOT OK to declare and
initialize a static variable multiple times if you call that same function
multiple times. In other words the static variable is set once you LEAVE a
function (even if you go back into that very same function).
===============================================================================

Some people (including me) had a problem with defining a long GLOBAL variable
list in functions (very error prone). Here is a possible solution. My program
parses php file for functions, and compiles GLOBAL variable lists. Then you can
just remove from the list those variables which need not be global.

<?php
    //parser for GLOBAL variable list
    $pfile=file("myfile.php4");
   
    for($i=0;$i<sizeof($pfile);$i++) {
     if(eregi("function",$pfile[$i])) {
      list($part1,$part2)=sscanf($pfile[$i],"%s %s");
      echo "\n\n $part1 $part2:\nGLOBAL ";
     
      $varlist=array();
      $level=0; $end=$i;
      do {
       $lpar=explode("{",$pfile[$end]);
       $level+=sizeof($lpar)-1;
       $lpar=explode("}",$pfile[$end]);
       $level-=sizeof($lpar)-1;
       $end++;
      } while(($end<sizeof($pfile))&&($level>0));
      $pstr="";
      for($j=$i;$j<=$end;$j++) $pstr.=$pfile[$j];
      $lpar=explode("$",$pstr);
      for($j=1;$j<sizeof($lpar);$j++) {
          eregi('[a-zA-Z_][a-zA-Z0-9_]*',$lpar[$j],$cvar);
        $varlist[$cvar[0]]=1;
      }
      array_walk($varlist,'var_print');
     }
    }
function var_print ($item, $key) {
     echo "$key,";
}
?>
===============================================================================

I'm using PHP 4.1.1

While designing a database access class, I needed a static variable that will
be incremented for all instances of the class each time the class connected to
the database. The obvious solution was to declare a "connection" class variable
with static scope. Unfortunatly, php doesn't allow such a declaration.
So I went back to defining a static variable in the connect method of my class.
But it seems that the static scope is not inherited: if class "a" inherit the
"db access" class, then the "connection" variable is shared among "a"
instances, not among both "a" AND "db access" instances.
Solution is to declare the static variable out of the db access class, and
declare "global" said variable in the connect method.
===============================================================================

On confusing aspect about global scope...

If you want to access a variable such as a cookie inside a function, but theres
a chance it may not even be defined, you need to access it using he GLOBALS
array, not by defining it as global.

This wont work correctly....

<?php
function isLoggedin()
{
global $cookie_username;
if (isset($cookie_username)
echo "blah..";
}
?>

This will..

<?php
function isLoggedin()
{
if (isset($GLOBALS["cookie_username"]))
echo "blah..";
}
?>
===============================================================================

Alright, so you can't set a static variable with a reference.
However, you can set a static variable to an array with an element that is a
reference:
<?php

class myReference {
    function getOrSet($array = null) {
        static $myValue;
        if (!$array) {
            return $myValue[0];     //Return reference in array
        }
        $myValue = $array;          //Set static variable with array
        static $myValue;
    }
}

$static = "Dummy";

$dummy = new myReference;
$dummy->getOrSet(array(&$static));

$static = "Test";
print $dummy->getOrSet();

?>
===============================================================================

If you include a file from within a function using include(), the included file
inherits the function scope as its own global scope, it will not be able to see
top level globals unless they are explicit in the function.

<?php
$foo = "bar";
function baz() {
    global $foo; # NOTE THIS
    include("qux");
}
?>
===============================================================================

Be careful if your static variable is an array and you return
one of it's elements: Other than a scalar variable, elements
of an array are returned as reference (regardless if you
didn't define them to be returned by reference).

<?php
function incr(&$int) {
  return $int++;
}

function return_copyof_scalar() {
  static $v;
  if (!$v)  
    $v = 1;
  return($v);
}

function return_copyof_arrayelement() {
  static $v;
  if (!$v) {
    $v = array();
    $v[0] = 1;
  }
  return($v[0]);
}

echo "scalar: ".
     incr(return_copyof_scalar()).
     incr(return_copyof_scalar()).
     "\n";
echo "arrayelement: ".
     incr(return_copyof_arrayelement()).
     incr(return_copyof_arrayelement()).
     "\n";
?>

Should print

scalar: 11
arrayelement: 11

but it prints:

scalar: 11
arrayelement: 12

as in the second case the arrays element was returned by
reference. According to a guy from the bug reports the
explanation for this behaviour should be somewhere here in
the documentation (in 'the part with title: "References with
global and static variables"'). Unfortunately I can't find
anything about that here. As the guys from the bug reports
are surely right in every case, maybe there is something
missing in the documentation. Sadly I don't have a good
explanation why this happens, so I decided to document at
least the behaviour.
===============================================================================

It should be noted that a static variable inside a method is static across all
instances of that class, i.e., all objects of that class share the same static
variable.  For example the code:

<?php
class test {
    function z() {
        static $n = 0;
        $n++;
        return $n;
    }
}

$a =& new test();
$b =& new test();
print $a->z();  // prints 1, as it should
print $b->z();  // prints 2 because $a and $b have the same $n
?>

somewhat unexpectedly prints:
1
2
===============================================================================

<?php
/*
VARIABLE SCOPE : GLOBAL V/S STATIC

If variable $count is defined global as under, instead of static, it does not
work well as desired in repeated function calls.

$count = 1; //if not defined STATIC, in each function call, it starts countig
from one to 25.
global $count;

which gives folowing output:
0123456789101112131415161718192021222324
Total 24 numbers are printed.
So far 26 function call(s) made.

26272829303132333435363738394041424344454647484950
Total 50 numbers are printed.
So far 52 function call(s) made.
*/

function print_1to50()
{
//    $count = 1;
//    global $count;
    static $count=1; // Initial assigment of One to $count, static declarion
holds the last(previous) value of variable $count in each next function calls.
        $limit = $count+24;
        while($count<=$limit)
        {
        echo "$count";
        $count=$count+1;
        }
        $num_count= $count-1;
        echo "<br>\n". "Total $num_count numbers are printed.<br>";

        return; // return statement without parenthesis()or arguments denotes
end of a function rather than returning any values to subsequent function call
(s).
} // end of while loop

$count=0;
print_1to50();
$count=$count+1;
print "So far $count function call(s) made.<br><br>";

print_1to50();
$count=$count+1;
print "So far $count function call(s) made.<br>";
/*
Which gives following output:
12345678910111213141516171819202122232425
Now I have printed 25 numbers.
I have made 1 function call(s).
26272829303132333435363738394041424344454647484950
Now I have printed 50 numbers.
I have made 2 function call(s).
*/

?>
===============================================================================

Many Times Globality of variables will be the small issue, after long time I
decided to use super globals.

Super globals exists any where:
$_SERVER, $_GET, $_POST .....

Now for example:

<?php
$foo[] = range(0, 3);
$_POST['foo'] = $foo;
a(); //no parameters needed.
b();
$foo = $_POST['foo'];

Print_r($foo);
/* out

Array
(
    [0] => Array
        (
            [0] => 0
            [1] => 1
            [2] => 2
            [3] => 3
        )

    [1] => Array
        (
            [0] => 4
            [1] => 5
            [2] => 6
            [3] => 7
        )

    [2] => Array
        (
            [0] => 8
            [1] => 9
            [2] => 10
        )

)

*/
function a(){
    $_POST['foo'][] = range(4, 7);
}

function b(){
$_POST['foo'][] = range(8, 10);
}
?>
Note: the key must not be passed by the page via _POST method by the form, else
the value will be over written
===============================================================================

Even if an included file return a value using return(), it's still sharing the
same scope as the caller script!

<?php
$foo = 'aaa';
$bar = include('include.php');
echo($foo.' / '.$bar);
?>

where include.php is
<?php
$foo = 'bbb';
return $foo;
?>

The output is: bbb / bbb
Not: aaa / bbb
===============================================================================

Be carefull about nested functions :
<?php
// won't work :
function foo1()
{
  $who = "world";
  function bar1()
  {
    global $who;
    echo "Hello $who";
  }
}

// will work :
function foo2()
{
  $GLOBALS['who'] = "world";
  function bar2()
  {
    global $who;
    echo "Hello $who";
  }
}

// also note, of course :
function foo3()
{
  $GLOBALS['who'] = "world";

  // won't work
  echo "Hello $who";

  // will work
  global $who;
  echo "Hello $who";
}
?>
===============================================================================

I was struggling forever to figure this out and finally tried the $GLOBALS
["filename"] = $filename approach, and it worked for me.

This happens on one of my machines, on which I installed Zend AMF a few months
before my most recent machine. The globals worked fine when calling the PHP
script directly from a browser, but when I called the function from my Flash
project, which uses Zend AMF to interface with the PHP script, I was seeing
this problem, but it was fixed using this approach.
===============================================================================

If you need all your global variables available in a function, you can use
this:

<?php

function foo(parameters) {
  if(version_compare(phpversion(),"4.3.0")>=0) {
    foreach($GLOBALS as $arraykey=>$arrayvalue) {
      global $$arraykey;
    }
  }
  // now all global variables are locally available...
}

?>
===============================================================================

Can not access to global variables from destructor, if obj is not unseted at
the end:

<?php

  class A
   {
     function __destruct()
      {
        global $g_Obj;
        echo "<br>#step 2: ";
        var_dump($g_Obj);
      }

     function start()
      {
        global $g_Obj;
        echo "<br>#step 1: ";
        var_dump($g_Obj);
      }
   };

  $g_Obj = new A();        // start here
  $g_Obj->start();
  $g_Obj = NULL;        // !!! comment line and result will changed !!!

?>

Result, if line is not commented:

#step 1: object(A)#1 (0) { }
#step 2: object(A)#1 (0) { }

Result, if line is commented:

#step 1: object(A)#1 (0) { }
#step 2: NULL
===============================================================================

assign after static variable declare：

<?php
        function test() {
                static $local_var=0;
                $local_var=9;
                echo $local_var++;
            }
        test();
        test();
       
?>

output:
99

<?php
        function test() {
                static $local_var=0;
                $local_var+=3;
                echo $local_var++;
            }
        test();
        test();
       
?>

output:
37
===============================================================================

Not sure of the implications of this but...
You can create nested functions within functions but you must make sure they
aren't defined twice, e.g.:

<?php
function norm($a, $b) {
    static $first_time = true;
    if ($first_time) {
        function square($x) {
            return $x * $x;
        }
        $first_time = false;
    }
    return sqrt(square($a) + square($b));
}

print square(5); // error, not defined yet
print norm(5,4);
print "<br>";
print norm(3,2);
print square(5); // OK
?>

If you don't include the if ($first_time) you get an error saying you can't
define square() twice.  Note that square is not local to the function it just
appears there.  The last line successfully accesses square in the page scope. 
This is not terribly useful, but interesting.
===============================================================================

Exemplo #6 don't work on portuguese version.

You need to call Teste() function, not Test()
===============================================================================

It can be nice to use static variables in class member functions.
This avoids a 'class global' like $this->template.
Also, I like the system of get and set using the same function.

<?php

class my_page
{
    public function template($name=null)
    {
        static $template = 'templates/page.html';
        if ($name) $template = "templates/{$name}.html";
        else return $template;
    }
}

$p = new my_page;
$p->template('product');
include $p->template();

?>
===============================================================================

It's possible to use a variable variable when specifying a variable as global
in a function. That way your function can decide what global variable to access
in run-time.

<?php
function func($varname)
{
   global $$varname;

   echo $$varname;
}

$hello = "hello world!";
func("hello");
?>

This will print "hello world!", and is roughly the same as passing by
reference, in the case when the variable you want to pass is global. The
advantage over references is that they can't have default parameters. With the
method above, you can do the following.

<?php
function func($varname = FALSE)
{
   if ($varname === FALSE)
     echo "No variable.";
   else
   {
     global $$varname;

     echo $$varname;
   }
}

$hello = "hello world!";
func("hello");                   // prints "hello world!"
func();                          // prints "No variable."
?>
===============================================================================

Please don't forget:
values of included (or required) file variables are NOT available in the local
script if the included file resides on a remote server:

remotefile.php:

<?PHP
$paramVal=10;
?>

localfile.php:

<?PHP
include "http://example.com/remotefile.php";
echo "remote-value= $paramVal";
?>

Will not work (!!)
===============================================================================

An alternative to static variables is to use an anonymous function. Here's an
example with a simple counter which goes up on each call:

<?php

// Static version
$staticCounter = function() {
    // Make $a static, so its value is preserved
    static $a = 0;
    $a++;
    return $a;
};
echo $staticCounter();
echo $staticCounter();
echo $staticCounter();
// Output:
// 1
// 2
// 3

// Closure version
$counterFactory = function () {
    // We *assign* $a in this function
    $a = 0;
    return function() use (&$a) {  // Notice the &
        // We *use* $a in this function
        $a++;
        return $a;
    };
};
// The above is a 'counter factory'; when called it returns a counter
$closureCounter1 = $counterFactory();
echo $closureCounter1();
echo $closureCounter1();
echo $closureCounter1();
// Output:
// 1
// 2
// 3

// If we call our 'factory' again, we get another counter, independent of the
first
$closureCounter2 = $counterFactory();
echo $closureCounter1();
echo $closureCounter2();
echo $closureCounter1();
echo $closureCounter2();
// Output (notice that we're calling both counters)
// 4
// 1
// 5
// 2

// We can do it with arguments too
$makeCounterFrom = function($start) {
    return function() use (&$start) {
        $start++;
        return $start;
    };
};
$yearCounter = $makeCounterFrom(2012);
echo $yearCounter();
echo $yearCounter();
// Output
// 2013
// 2014
?>

This use of closures may be familiar from Javascript's 'one-shot' functions "
(function() {...})()". In PHP we can do this on 2 lines using a variable, or
with 'call_user_func'.

It's useful when a regular function isn't enough, but a whole class is
overkill.
===============================================================================

If you want use all globals function, you can do :

<?php
function my_function1(){
    extract($GLOBALS);
}
?>
===============================================================================

Seems as though when a cookie is saved and referenced as a variable of the same
name as the cookie, that variable is NOT global.  If you make a function ro
read the value of the cookie, the cooke variable name must be declared as a
global.

example:

<?php
function ReturnCookie()
{
        $cookieName = "Test_Cookie";
        global $$cookieName;
        if (isset($$cookieName))
        {
                echo ("$cookieName is set");
                $returnvalue = $$cookieName;
        }
        else
        {
                $newCookieValue = "Test Value";
                setcookie("$cookieName","$newCookieValue", (time() + 3153600));
                echo ("made a cookie:" . $newCookieValue ."<BR>");
                $returnvalue = $newCookieValue;
        }
        echo ("the cookie that was set is now $returnvalue <BR>");
        return $returnvalue;
}
?>
===============================================================================

When defining static variables you may use such declarations:

<?php
static $var = 1; //numbers
static $var = 'strings';
static $var = array(1,'a',3); //array construct
?>

but these ones would produce errors:

<?php
static $var = some_function('arg');
static $var = (some_function('arg'));
static $var = 2+3; //any expression
static $var = new object;
?>
