
array_unique

(PHP 4 >= 4.0.1, PHP 5, PHP 7)

array_unique — 移除数组中重复的值

说明

array array_unique ( array $array [, int $sort_flags = SORT_STRING ] )

array_unique() 接受 array 作为输入并返回没有重复值的新数组。

注意键名保留不变。array_unique() 先将值作为字符串排序，然后对每个值只保留第一个
遇到的键名，接着忽略所有后面的键名。这并不意味着在未排序的 array 中同一个值的第
一个出现的键名会被保留。

    Note: 当且仅当 (string) $elem1 === (string) $elem2 时两个单元被认为相同。就
    是说，当字符串的表达一样时。第一个单元将被保留。

参数

array

    输入的数组。

sort_flags

    The optional second parameter sort_flags may be used to modify the sorting
    behavior using these values:

    Sorting type flags:
      □ SORT_REGULAR - compare items normally (don't change types)
      □ SORT_NUMERIC - compare items numerically
      □ SORT_STRING - compare items as strings
      □ SORT_LOCALE_STRING - compare items as strings, based on the current
        locale.

返回值

Returns the filtered array.

更新日志

 版本                                    说明
5.2.10 Changed the default value of sort_flags back to SORT_STRING.
5.2.9  Added the optional sort_flags defaulting to SORT_REGULAR. Prior to
       5.2.9, this function used to sort the array with SORT_STRING internally.

范例

Example #1 array_unique() 例子

<?php
$input = array("a" => "green", "red", "b" => "green", "blue", "red");
$result = array_unique($input);
print_r($result);
?>

以上例程会输出：

Array
(
    [a] => green
    [0] => red
    [1] => blue
)

Example #2 array_unique() 和类型

<?php
$input = array(4, "4", "3", 4, 3, "3");
$result = array_unique($input);
var_dump($result);
?>

以上例程会输出：

array(2) {
  [0] => int(4)
  [2] => string(1) "3"
}

参见

  • array_count_values() - 统计数组中所有的值出现的次数

注释

    Note: Note that array_unique() is not intended to work on multi dimensional
    arrays.


User Contributed Notes 63 notes

===============================================================================

It's often faster to use a foreache and array_keys than array_unique:

    <?php

    $max = 1000000;
    $arr = range(1,$max,3);
    $arr2 = range(1,$max,2);
    $arr = array_merge($arr,$arr2);

    $time = -microtime(true);
    $res1 = array_unique($arr);
    $time += microtime(true);
    echo "deduped to ".count($res1)." in ".$time;
    // deduped to 666667 in 32.300781965256

    $time = -microtime(true);
    $res2 = array();
    foreach($arr as $key=>$val) {   
        $res2[$val] = true;
    }
    $res2 = array_keys($res2);
    $time += microtime(true);
    echo "<br />deduped to ".count($res2)." in ".$time;
    // deduped to 666667 in 0.84372591972351

    ?>
===============================================================================

Create multidimensional array unique for any single key index.
e.g I want to create multi dimentional unique array for specific code

Code :
My array is like this,

<?php
$details = array(
    0 => array("id"=>"1", "name"=>"Mike",    "num"=>"9876543210"),
    1 => array("id"=>"2", "name"=>"Carissa", "num"=>"08548596258"),
    2 => array("id"=>"1", "name"=>"Mathew",  "num"=>"784581254"),
);
?>

You can make it unique for any field like id, name or num.

I have develop this function for same :
<?php
function unique_multidim_array($array, $key) {
    $temp_array = array();
    $i = 0;
    $key_array = array();
   
    foreach($array as $val) {
        if (!in_array($val[$key], $key_array)) {
            $key_array[$i] = $val[$key];
            $temp_array[$i] = $val;
        }
        $i++;
    }
    return $temp_array;
}
?>

Now, call this function anywhere from your code,

something like this,
<?php
$details = unique_multidim_array($details,'id');
?>

Output will be like this :
<?php
$details = array(
    0 => array("id"=>"1","name"=>"Mike","num"=>"9876543210"),
    1 => array("id"=>"2","name"=>"Carissa","num"=>"08548596258"),
);
?>
===============================================================================

For people looking at the flip flip method for getting unique values in a
simple array. This is the absolute fastest method:

<?php
$unique = array_keys(array_flip($array));
?>

It's marginally faster as:
<?php
$unique = array_merge(array_flip(array_flip($array)));
?>

And it's marginally slower as:
<?php
$unique array_flip(array_flip($array)); // leaves gaps
?>

It's still about twice as fast or fast as array_unique.

This tested on several different machines with 100000 random arrays. All
machines used a version of PHP5.
===============================================================================

If you find the need to get a sorted array without it preserving the keys, use
this code which has worked for me:

<?php

$array = array("hello", "fine", "good", "fine", "hello", "bye");

$get_sorted_unique_array = array_values(array_unique($array));

?>

The above code returns an array which is both unique and sorted from zero.
===============================================================================

recursive array unique for multiarrays

<?php
function super_unique($array)
{
  $result = array_map("unserialize", array_unique(array_map("serialize", $array
)));

  foreach ($result as $key => $value)
  {
    if ( is_array($value) )
    {
      $result[$key] = super_unique($value);
    }
  }

  return $result;
}
?>
===============================================================================

Case insensitive; will keep first encountered value.

<?php

function array_iunique($array) {
    $lowered = array_map('strtolower', $array);
    return array_intersect_key($array, array_unique($lowered));
}

?>
===============================================================================

This is a fast solution to remove duplicate values from an array when it
contains only strings or only integers:

<?php

$array = array(
  0 => 'Yellow',
  1 => 'Green',
  2 => 'Yellow',
  3 => 'Blue',
  4 => 'Yellow',
);

$uniq = array_keys(array_flip($array));

var_export($uniq);

/* Output:
array (
  0 => 'Yellow',
  1 => 'Green',
  2 => 'Blue',
)
*/

?>
===============================================================================

I needed to identify email addresses in a data table that were replicated, so I
wrote the array_not_unique() function:

<?php

function array_not_unique($raw_array) {
    $dupes = array();
    natcasesort($raw_array);
    reset ($raw_array);

    $old_key    = NULL;
    $old_value    = NULL;
    foreach ($raw_array as $key => $value) {
        if ($value === NULL) { continue; }
        if ($old_value == $value) {
            $dupes[$old_key]    = $old_value;
            $dupes[$key]        = $value;
        }
        $old_value    = $value;
        $old_key    = $key;
    }
return $dupes;
}

$raw_array     = array();
$raw_array[1]    = 'abc@xyz.com';
$raw_array[2]    = 'def@xyz.com';
$raw_array[3]    = 'ghi@xyz.com';
$raw_array[4]    = 'abc@xyz.com'; // Duplicate

$common_stuff    = array_not_unique($raw_array);
var_dump($common_stuff);
?>
===============================================================================

To clarify the note above Example #1, the function appears to cast the elements
to strings for comparison and then return the type of the first unique element
encountered. 

<?php
$input = array(0, 2, "2", 3, "9", 9);
$result = array_unique($input);
var_dump($result);
?>

array(4) {
  [0]=>
  int(0)
  [1]=>
  int(2)
  [3]=>
  int(3)
  [4]=>
  string(1) "9"
}
===============================================================================

I noticed there was no way to tell array_unique() to ignore certain duplicated
keys, so I wrote the following. I imagine there's half a dozen more efficient
ways to do this, but here goes:

<?php
$array = array('foo', 'bar', 'xyzzy', '&', 'xyzzy',
               'baz', 'bat', '|', 'xyzzy', 'plugh',
               'xyzzy', 'foobar', '|', 'plonk', 'xyzzy',
               'apples', '&', 'xyzzy', 'oranges', 'xyzzy',
               'pears');

$ignore_values = array('|', '&');

print_r(make_unique($array, $ignore_values));

function make_unique($array, $ignore)
{
    while($values = each($array))
    {
        if(!in_array($values[1], $ignore))
        {
            $dupes = array_keys($array, $values[1]);
            unset($dupes[0]);
            foreach($dupes as $rmv)
            {
                unset($array[$rmv]);
            }           
        }
    }
    return $array;
}
?>
OUTPUT:
Array
(
    [0] => foo
    [1] => bar
    [2] => xyzzy
    [3] => &
    [5] => baz
    [6] => bat
    [7] => |
    [9] => plugh
    [11] => foobar
    [12] => |
    [13] => plonk
    [15] => apples
    [16] => &
    [18] => oranges
    [20] => pears
)
===============================================================================

[Editor's note: please note that this will not work well with non-scalar values
in the array. Array keys can not be arrays themselves, nor streams, resources,
etc. Flipping the array causes a change in key-name]

You can do a super fast version of array_unique directly in PHP, even faster
than the other solution posted in the comments!

Compared to the built in function it is 20x faster! (2x faster than the
solution in the comments).

<?php
function superfast_array_unique($array) {
    return array_keys(array_flip($array));
}
?>

This works faster for small and big arrays.
===============================================================================

Another way to 'unique column' an array, in this case an array of objects:
Keep the desired unique column values in a static array inside the callback
function for array_filter.

Example:
<?php
/* example object */
class myObj {
  public $id;
  public $value;
  function __construct( $id, $value ) {
    $this->id = $id;
    $this->value = $value;
  }
}

/* callback function */
function uniquecol( $obj ) {
  static $idlist = array();

  if ( in_array( $obj->id, $idlist ) )
    return false;

  $idlist[] = $obj->id;
  return true;   
}

/* a couple of arrays with second array having an element with same id as the
first */
$list  = array( new myObj( 1, 1  ), new myObj( 2, 100 ) );
$list2 = array( new myObj( 1, 10 ), new myObj( 3, 100 ) );
$list3 = array_merge( $list, $list2 );

$unique = array_filter( $list3, 'uniquecol' );
print_r( $list3 );
print_r( $unique );

?>

In addition, use array_merge( $unique ) to reindex.
===============================================================================

Here's the shortest line of code I could find/create to remove all duplicate
entries from an array and then reindex the keys.

<?php

// Fruits, vegetables, and other food:
$var = array('apple','banana','carrot','cat','dog','egg','eggplant','fish');

$var = array_values(array_unique($var));
?>
===============================================================================

A very simple way of getting rid of duplicate entries and re-indexing with key
starting at 0:

<?php

$temp = array_unique($main);
$uniq = array_values($temp);

?>
===============================================================================

This is a script for multi_dimensional arrays

<?php
function remove_dup($matriz) {
    $aux_ini=array();
    $entrega=array();
    for($n=0;$n<count($matriz);$n++)
    {
        $aux_ini[]=serialize($matriz[$n]);
    }
    $mat=array_unique($aux_ini);
    for($n=0;$n<count($matriz);$n++)
    {
       
            $entrega[]=unserialize($mat[$n]);
       
    }
    return $entrega;
}
?>
===============================================================================

another method to get unique values is :

<?php
$alpha=array('a','b','c','a','b','d','e','f','f');

$alpha= array_keys(array_count_values($alpha));

print_r($alpha);
?>

Output:
Array ( [0] => a [1] => b [2] => c [3] => d [4] => e [5] => f )
===============================================================================

Let's say you have
<?php
$v=array("blue","blue","blue","blue");
if($v[0]==$v[1] && $v[1]==$v[2] && $v[2]==$v[3])
echo "Y"; else echo "N";//Y
?>

It works but the if-statement gets a bit messy if the number of array elements
gets massive.
I find it is easier to use array_unique like so:
<?php
$v=array("blue","blue","blue","blue");
echo sizeof(array_unique($v))==1?"Y":"N";//Y
?>
===============================================================================

I searched how to show only the duplicate elements from array, but failed.
Here is my solution:

<?php
function arrayDuplicate($array)
{
return array_unique(array_diff_assoc($array1,array_unique($array1)));
};
?>

Example:
<?php
$arr1 = array('foo', 'bar', 'xyzzy', '&', 'xyzzy',
'baz', 'bat', '|', 'xyzzy', 'plugh',
'xyzzy', 'foobar', '|', 'plonk', 'xyzzy',
'apples', '&', 'xyzzy', 'oranges', 'xyzzy',
'pears','foobar');

$result=arrayDuplicate($arr1);
print_r($result);exit;
?>

Output:

Array
(
[4] => xyzzy
[12] => |
[16] => &
[21] => foobar
)
===============================================================================

This is how to merge 2 comma separated lists with unique value only.

<?php
  $list1 = "4444, 5555, 6666";
  $list2 = "4444, 5555, 7777";

  // combine both lists with unique values only
  $list3 = implode("," , array_unique(array_merge(explode(",",$list1),explode(
",", $list2))));

  echo $list3;
?>

The result is: 4444,5555,6666,7777
===============================================================================

Problem:
I have loaded an array with the results of a database
query.  The Fields are 'FirstName' and 'LastName'.

I would like to find a way to contactenate the two
fields, and then return only unique values for the
array.  For example, if the database query returns
three instances of a record with the FirstName John
and the LastName Smith in two distinct fields, I would
like to build a new array that would contain all the
original fields, but with John Smith in it only once.
Thanks for: Colin Campbell

Solution:

<?php
/**
* The same thing than implode function, but return the keys so
*
* <code>
* $_GET = array('id' => '4587','with' => 'key');
* ...
* echo shared::implode_with_key('&',$_GET,'='); // Resultado: id=4587&with=key
* ...
* </code>
*
* @param string $glue Oque colocar entre as chave => valor
* @param array $pieces Valores
* @param string $hifen Separar chave da array do valor
* @return string
* @author memandeemail at gmail dot com
*/
function implode_with_key($glue = null, $pieces, $hifen = ',') {
  $return = null;
  foreach ($pieces as $tk => $tv) $return .= $glue.$tk.$hifen.$tv;
  return substr($return,1);
}

/**
* Return unique values from a tree of values
*
* @param array $array_tree
* @return array
* @author memandeemail at gmail dot com
*/
function array_unique_tree($array_tree) {
  $will_return = array(); $vtemp = array();
  foreach ($array_tree as $tkey => $tvalue) $vtemp[$tkey] = implode_with_key('&
',$tvalue,'=');
  foreach (array_keys(array_unique($vtemp)) as $tvalue) $will_return[$tvalue] =
$array_tree[$tvalue];
  return $will_return;
}

$problem = array_fill(0,3,
array('FirstName' => 'John', 'LastName' => 'Smith')
);

$problem[] = array('FirstName' => 'Davi', 'LastName' => 'S. Mesquita');
$problem[] = array('FirstName' => 'John', 'LastName' => 'Tom');

print_r($problem);

print_r(array_unique_tree($problem));
?>
===============================================================================

I required a function that removed a specific duplicate entry from an array and
ignoring all others so came up with this:

<?php
function specified_array_unique($array, $value)
{
    $count = 0;
   
    foreach($array as $array_key => $array_value)
    {
        if ( ($count > 0) && ($array_value == $value) )
        {
            unset($array[$array_key]);
        }
       
        if ($array_value == $value) $count++;
    }
   
    return array_filter($array);
}
?>
===============================================================================

Lets say that you want to capture unique values from multidimensional arrays
and flatten them in 0 depth.

i.e.
<?php
$tmp = array( 'a' => array( 1,2,3,4 ), 'b' => array( 'c' => array( 4,5,6,7 ) )
);
?>

will return with array_flat( $tmp ) --> array( 1,2,3,4,5,6,7 );

I hope that the function will help someone

<?php
/**
* @params      : $a            array           the recursion array
*              : $s            array           storage array
*              : $l            integer         the depth level
*
*/
if( !function_exists( 'array_flat' ) )
{
    function array_flat( $a, $s = array( ), $l = 0 )
    {
        # check if this is an array
        if( !is_array( $a ) )                           return $s;
       
        # go through the array values
        foreach( $a as $k => $v )
        {
            # check if the contained values are arrays
            if( !is_array( $v ) )
            {
                # store the value
                $s[ ]       = $v;
               
                # move to the next node
                continue;
               
            }
           
            # increment depth level
            $l++;
           
            # replace the content of stored values
            $s              = array_flat( $v, $s, $l );
           
            # decrement depth level
            $l--;
           
        }
       
        # get only unique values
        if( $l == 0 ) $s = array_values( array_unique( $s ) );
       
        # return stored values
        return $s;
       
    } # end of function array_flat( ...
   
}
?>
===============================================================================

<?php

//Fn for array_unique column-wise for multi-dimensioanl array without losing
keys | Start
function array_uniquecolumn($arr)
{
    $rows   = sizeof($arr);
    $columns = sizeof($arr[0]);
   
    $columnkeys = array_keys($arr[0]);
   

    for($i=0; $i<$columns; $i++)
    {
        for($j=0;$j<$rows;$j++)
        {
            for($k = $j+1; $k<$rows; $k++)
            {
                if($arr[$j][$columnkeys[$i]] == $arr[$k][$columnkeys[$i]])
                    $arr[$k][$columnkeys[$i]] = "";       
            }
        }
   
    }

return ($arr);

}
//Fn for array_unique column-wise for multi-dimensioanl array without losing
keys | Stop

$arrUGCourse[]= array(  "CTR" => "1",

                        "UGCOURSE"=>"ABC",

                        "TSINITIATE"=>"540",

                        "COUNT"=>"34",

                        "ENTRY_DT"=>"2006-05-01",

                        "CUMULATIVE"=> 44);



$arrUGCourse[]= array(  "CTR" => "2",

                        "UGCOURSE"=>"ABC",

                        "TSINITIATE"=>"5401",

                        "COUNT"=>"341",

                        "ENTRY_DT"=>"2006-05-11",

                        "CUMULATIVE"=> 44);

print_r(array_uniquecolumn($arrUGCourse));

?>
===============================================================================

I needed a way of retaining the original array's keys in the new, unique array.
I came up with this. It works for my purposes but may need refinement.

<?php
function my_array_unique($somearray)
{
    asort($somearray);
    reset($somearray);
    $currentarrayvar = current($somearray);
    foreach ($somearray as $key=>$var)
    {
        if (next($somearray) != $currentarrayvar)
        {
            $uniquearray[$key] = $currentarrayvar;
            $currentarrayvar = current($somearray);
        }
    }
    reset($uniquearray);
    return $uniquearray;
}
?>
===============================================================================

I found the simplest way to "unique" multidimensional arrays as follows:

<?php

$array = array(
    'a' => array(1, 2),
    'b' => array(1, 2),
    'c' => array(2, 2),
    'd' => array(2, 1),
    'e' => array(1, 1),
);

$array = array_map('json_encode', $array);
$array = array_unique($array);
$array = array_map('json_decode', $array);

print_r($array);

?>

As you can see "b" will be removed without any errors or notices.
===============================================================================

I created a function for doing array_unique with a custom in_array function.
So, if elements are considered in the array passed to this function, the array
returned won't include elements that are considered equal and only return the
values from the first array that are not considered in the array:

<?php

function uniqueBy(array $array, callable $in_array_func) {
    $result = array();
    foreach ($array as $key => $item) {
        if (!$in_array_func($item, $result)) {
            $result[$key] = $item;
        }
    }
    return $result;
}

?>

Example usage:

<?php

$in_array_func = function($item, $array) {
    $fromBower = function($item) {
        $result = substr($item, strpos($item, 'bower_components'));
        return $result;
    };
    foreach ($array as $myItem) {
        if ($fromBower($item) == $fromBower($myItem)) {
            return true;
        }
    }
    return false;
};

// ...
$jss = uniqueBy($jss, $in_array_func);
?>
===============================================================================

Another form to make an array unique (manual):

This is my array

Array
(
    [0] => Array
        (
            [0] => 40665
            [1] => 40665
            [2] => 40665
            [3] => 40665
            [4] => 40666
            [5] => 40666
            [6] => 40666
            [7] => 40666
            [8] => 40667
            [9] => 40667
            [10] => 40667
            [11] => 40667
            [12] => 40667
            [13] => 40668
            [14] => 40668
            [15] => 40668
            [16] => 40668
            [17] => 40668
            [18] => 40669
            [19] => 40669
            [20] => 40670
            [21] => 40670
            [22] => 40670
            [23] => 40670
            [24] => 40671
            [25] => 40671
            [26] => 40671
            [27] => 40671
            [28] => 40671
        )

    [1] => Array
        (
            [0] => 40672
            [1] => 40672
            [2] => 40672
            [3] => 40672
        )

)

this is my script:

    $anterior = 0;
    foreach($item as $array_key => $array_value)
    {
            echo "<li>$array_key";
            echo "<ul>";
            foreach($array_value as $xarray_key => $xarray_value){
                if($xarray_value != $anterior) {
                    echo "<li>$xarray_key => $xarray_value";
                    $item_nuevo[$array_key][] = $xarray_value;    // or to use
the same key number $item_nuevo[$array_key][$xarray_key] = $xarray_value;     
         
                }
                $anterior = $xarray_value;
            }
            echo "</ul>";   
    }    

result:

0
    0 => 40665
    4 => 40666
    8 => 40667
    13 => 40668
    18 => 40669
    20 => 40670
    24 => 40671

1
    0 => 40672

saludos desde chile.
===============================================================================

My object unique function:

<?php
function object_unique( $obj ){
    $objArray = (array) $obj;

    $objArray = array_intersect_assoc( array_unique( $objArray ), $objArray );

    foreach( $obj as $n => $f ) {
        if( !array_key_exists( $n, $objArray ) ) unset( $obj->$n );
    }

    return $obj;
}
?>

And these code:

<?php
class Test{
    public $pr0 = 'string';
    public $pr1 = 'string1';
    public $pr2 = 'string';
    public $pr3 = 'string2';
}

$obj = new Test;

var_dump( object_unique( $obj ) );
?>

returns:
object(Test)[1]
  public 'pr0' => string 'string' (length=6)
  public 'pr1' => string 'string1' (length=7)
  public 'pr3' => string 'string2' (length=7)
===============================================================================

If you use SORT_NUMERIC on this kind of filtering it will be significantly
faster.
However the array_flip method still is twice as fast.
===============================================================================

Taking the advantage of array_unique, here is a simple function to check if an
array has duplicate values.

It simply compares the number of elements between the original array and the
array_uniqued array.

<?php

function array_has_duplicates(array $array)
{
    $uniq = array_unique($array);
    return count($uniq) != count($array);
}

?>
===============================================================================

Although array_unique is not intended to work with multi-dimensional arrays, it
does on 5.2.9.  However, it does not for 5.2.5.  Beware.
===============================================================================

//Remove duplicates from a text files and dump result in one file for example:
emails list, links list etc

<?php

$data1 = file("data1.txt");
$data2 = file("data2.txt");

file_put_contents('unique.txt', implode('', array_unique(array_merge($data1,
$data2))));
?>
===============================================================================

so .... my problem was multidimensional sort.

<?php
      $new = array();
      $exclude = array("");
      for ($i = 0; $i<=count($attribs)-1; $i++) {
         if (!in_array(trim($attribs[$i]["price"]) ,$exclude)) { $new[] = 
$attribs[$i]; $exclude[] = trim($attribs[$i]["price"]); }
      }

?>

Array $attribs is an array contaning arrays. Each array in the $attrib array
consists in multiple fields (ex: name, lenght, price, etc.) to be more simpler
in speech think that $attrib is the array resulted by a search sql query done
by a visitator on your online shoopping website ... (so ... each array in the
$attrib is a product :P) if you want to sort only the uniq results use the
above or use this:

<?php
 
   /* Our Array of products */
   $attribs[] = array(
                           "name"         => "Test Product 1",
                           "length"     => "42 cm",
                           "weight"     => "0,5 kg",
                           "price"     => "10 $",
                           "stock"     => "100",
                        );

   $attribs[] = array(
                           "name"         => "Test Product 2",
                           "length"     => "42 cm",
                           "weight"     => "1,5 kg",
                           "price"     => "10 $",
                           "stock"     => "200",
                        );

    /* The nice stuff */

      $new = array();
      $exclude = array("");
      for ($i = 0; $i<=count($attribs)-1; $i++) {
         if (!in_array(trim($attribs[$i]["price"]) ,$exclude)) { $new[] = 
$attribs[$i]; $exclude[] = trim($attribs[$i]["price"]); }
      }
     
      print_r($new); // $new is our sorted array

?>

Have fun tweaking this ;)) i know you will ;))

From Romania With Love
===============================================================================

I came across one limitation of array_unique: it doesn't work properly if you
have arrays inside your main array.

The reason is that to compare two values, the function tests if (string)
$value1 == (string) $value2. So if $value1 and $value2 are both arrays, the
function will evaluate the test to 'Array' == 'Array', and decide that the
$values are repeated even if the arrays are different.

So a work around is to find a better conversion of an array to a string, which
can be done with json:

<?php
print "define an array with repeated scalar '1' and repeated 'array(1)':";
$a_not_unique = array(
    'a' => 1,
    'b' => 1,
    'c' => 2,
    'd' => array(1),
    'e' => array(1),
    'f' => array(2),
);
print_r($a_not_unique);

print "try to use simply array_unique, which will not work since it exludes
'array(2)':";
$a_unique_wrong = array_unique($a_not_unique);
print_r($a_unique_wrong);

print "convert to json before applying array_unique, and convert back to array,
which will successfully keep 'array(2)':";
$a_unique_right = $a_not_unique;
array_walk($a_unique_right, create_function('&$value,$key', '$value =
json_encode($value);'));
$a_unique_right = array_unique($a_unique_right);
array_walk($a_unique_right, create_function('&$value,$key', '$value =
json_decode($value, true);'));
print_r($a_unique_right);
?>

Results:
define an array with repeated scalar '1' and repeated 'array(1)':
Array
(
    [a] => 1
    [b] => 1
    [c] => 2
    [d] => Array
        (
            [0] => 1
        )

    [e] => Array
        (
            [0] => 1
        )

    [f] => Array
        (
            [0] => 2
        )
)

try to use simply array_unique, which will not work since it exludes 'array(2)
':
Array
(
    [a] => 1
    [c] => 2
    [d] => Array
        (
            [0] => 1
        )
)

convert to json before applying array_unique, and convert back to array, which
will successfully keep 'array(2)':
Array
(
    [a] => 1
    [c] => 2
    [d] => Array
        (
            [0] => 1
        )

    [f] => Array
        (
            [0] => 2
        )
)
===============================================================================

Case insensitive for PHP v4.x and up.

<?php

function in_iarray($str, $a) {
    foreach ($a as $v) {
        if (strcasecmp($str, $v) == 0) {
            return true;
        }
    }
    return false;
}

function array_iunique($a) {
    $n = array();
    foreach ($a as $k => $v) {
        if (!in_iarray($v, $n)) {
            $n[$k]=$v;
        }
    }
    return $n;
}

$input = array("aAa","bBb","cCc","AaA","ccC","ccc","CCC","bBB","AAA","XXX");
$result = array_iunique($input);
print_r($result);

/*
Array
(
    [0] => aAa
    [1] => bBb
    [2] => cCc
    [9] => XXX
)
*/
?>
===============================================================================

This is a recursive arrayUnique function for arrays of any dimension. (tested
with 4-dimensional array)
The line '$newArray=deleteEmpty($newArray);' is optional and removes empty keys
and values
<?php
function arrayUnique($myArray)
    {
    $newArray = Array();
    if (is_array($myArray))
        {
        foreach($myArray as $key=>$val)
            {
            if (is_array($val))
                {
                $val2 = arrayUnique($val);
                }
            else
                {
                $val2 = $val;
                $newArray=array_unique($myArray);
                $newArray=deleteEmpty($newArray);
                break;
                }
            if (!empty($val2))
                {
                $newArray[$key] = $val2;
                }
            }
        }
    return ($newArray);
    }

function deleteEmpty($myArray)
    {
    $retArray= Array();
    foreach($myArray as $key=>$val)
        {
        if (($key<>"") && ($val<>""))
            {
            $retArray[$key] = $val;
            }
        }
    return $retArray;
    }
?>
===============================================================================

Here's another solution for returning an array that only includes repeated
values. There is one given below but it only works on numerically indexed
arrays; this one is more comprehensive since I used the foreach iterator. Also,
this one preserves keys--in that the returned result contains a distinct list
of repeats (storing only the first instance it encounters of each duplicate
value).

<?php

function array_repeated($array)
{
    if ( !is_array($array) ) {
        return false;
    }
   
    $duplicates = array();
    foreach ( $array as $key => $val ) {
        end($array);
        $k = key($array);
        $v = current($array);
       
        while ( $k !== $key ) {
            if ( $v === $val ) {
                $duplicates[$key] = $v;
                                break;
            }
           
            $v = prev($array);
            $k = key($array);
        }
    }
   
    return $duplicates;
}

?>
===============================================================================

I had a problem with array_unique and multidimensional arrays ... Maybe there's
a better way to do this, but this will work for any dimensional arrays.

<?php
function arrayUnique($myArray)
{
    if(!is_array($myArray))
           return $myArray;

    foreach ($myArray as &$myvalue){
        $myvalue=serialize($myvalue);
    }

    $myArray=array_unique($myArray);

    foreach ($myArray as &$myvalue){
        $myvalue=unserialize($myvalue);
    }

    return $myArray;

}
?>
===============================================================================

I quite like the following code for making multidimensional arrays unique:

<?php
foreach ($arrAddressList AS $key => $arrAddress) {
    $arrAddressList[$key] = serialize($arrAddress);
}
$arrAddressList = array_unique($arrAdressList);
foreach ($arrAddressList AS $key => $strAddress) {
    $arrAddressList[$key] = unserialize($strAddress);
}
?>

This gets me a unique array while not minding wether the the original array
contains arrays or just strings (or whatever...).
===============================================================================

Following the code copies of a little function I've wrote that actually works
with multidimensional arrays.
It also resets the array indexes.

<?php
if ( !function_exists( "arrayUnique" ) ){
    function arrayUnique ( $rArray ){
        $rReturn = array ();
        while ( list( $key, $val ) = each ( $rArray ) ){
            if ( !in_array( $val, $rReturn ) )
            array_push( $rReturn, $val );
        }
        return $rReturn;
    }
}
?>
===============================================================================

The following is an efficient, adaptable implementation of array_unique which
always retains the first key having a given value:

<?php
function array_unique2(&$aray) {
    $aHash = array();
    foreach ($aray as $key => &$val) if (@$aHash[$val]++) unset ($aray[$key]);
}
?>

It is also adaptable to multi dimensional arrays.  For example, if your array
is a sequence of (multidimensional) points, then in place of @$aHash[$val]++
you could use @$aHash[implode("X",$val)]++
If you want to not have holes in your array, you can do an array_merge($aray)
at the end.

Csaba Gabor
===============================================================================

Just to note that array_unique, treats null values as none unique values. So if
your using array_unique to detect duplicate values it will also detect multiple
null values.
===============================================================================

Before I found the mysql distinct I had to make a nicer array from the keys/
values that I got from array_unique so.

<?php
$groups=array_unique($groups);
$newgroup[0]=reset($groups);
for ($x=1;$x<sizeof($groups);$x++)
{
  $newgroup[$x]=next($groups);
}
?>
===============================================================================

One way to use array_unique() to handle the multidimensional array issue is to
use an md5 hash of the serialized array as the key. I've seen some solutions
listed here that stored the serialized string, but that requires
unserialization, and moving data back and forth between two states for little
reason is just a bad idea. Instead, you could try this method:

<?php
$values = array();

foreach($data as $d) {
    $values[md5(serialize($d))] = $d;
}

sort($values);
?>

This will serialize and hash the value, and store the value with the hash as
they key. This will ensure that each piece is only stored once, as the second
attempt to store will just overwrite the first attempt with identical data.

The sort() at the end is a bit unnecessary, but I had to use it on my project,
because the function I was passing the array to couldn't handle keys that
weren't valid XML node names (and some md5 hash strings will start with
numbers, which is invalid for XML).
===============================================================================

Try this:
array_flip(array_flip($array));

It gives the same result as the old array_unique()
===============================================================================

<?php
$truc = array("l810u00","l810u00","l810q00");
$machin = array_unique($truc);
for($i=0;$i < count($machin) ; $i++){
print $machin[$i]."
";
}
?>
result :
l810u00

This is not strange: $machin (as returned by array unique), contains "l810u00"
either in key[0] or key[1] but not both (the key depends on the ersion of PHP),
and "l810q00" in key[2].
The returned array has TWO elements so count($machin)==2.
The returned array has a hole in it, and you're not displaying its full
content. You could verify it by using this display loop instead:
foreach($machine as $key=>$value){
print '[' . $key . '] => ' . $value . '
";
}
result:
[0] => l810q00
[2] => l810u00
(the first line may display [1] instead of [0] for PHP 4.0.1p3, but you'll get
the same order of values and two lines, as expected). When calling array_values
() on the result, you're building a new array with the same values in the same
order, but with renumbered keys (without holes in numeric keys).
===============================================================================

If you're doing numeric arrays etc. I found flip-flip to work much better than
array_unique:

<?PHP
    function microtime_float(){ //timing
       list($usec, $sec) = explode(" ", microtime());
       return ((float)$usec + (float)$sec);
    }

    //make an arry and fill it up
    $final=array();
    for($i=0;$i<50000;$i++){
        $final[]=$i%13; //make sure there are some dupes
    }
    //try array unique
    $start1 = microtime_float();
    array_unique($final);
    $stop1=microtime_float();
    echo($stop1-$start1.'<br>');
    //try my flip-flip
    $start2=microtime_float();
    array_flip(array_flip($final));
    $stop2=microtime_float();
    echo($stop2-$start2);
?>

Running this with only ints in the array (as above) I get runtimes such as:
1.6195669174194 (using unique)
0.017037868499756 (using flip flip)
which is two orders of magnitude faster!

Appending a string:
($final[]='test'.$i%13;)
gives:
0.42909598350525 (using unique)
0.023258924484253 (using flip-flip)
Which is not AS great, but still 20x faster than unique.

In both cases the flip-flip seems to use less memory than the unique.

Granted the flip-flip doesn't work for all cases, but if you're doing simple
stuff like this, the flip-flip will give you better run times.

~JF
===============================================================================

It seems that array_unique creates an exact copy of the original array and then
elimitates duplicate values. It does NOT change the "internal references" of
the array. For example:

<?php
    $test_alfa = array();
    $test_alfa[0] = "aa";
    $test_alfa[1] = "aa";
    $test_alfa[2] = "aa";
    $test_alfa[3] = "bb";
    $test_alfa[4] = "aa";
    $test_alfa[5] = "bb";
    $test_alfa[6] = "cc";
    $test_alfa[7] = "bb";
  
    $test_beta= array_unique($test_alfa);
    $numValues = count($test_beta);
    for ($i = 0 ; $i <= 7 ; $i++)
       echo("test_beta[$i] = $test_beta[$i] <br>");
    echo ("Number of elements in test_beta = $numValues ");
?>
will give you the following output:

test_beta[0] =
test_beta[1] = aa
test_beta[2] =
test_beta[3] =
test_beta[4] =
test_beta[5] = bb
test_beta[6] = cc
test_beta[7] =
Number of elements in test_beta = 3

The point is that you won't get the output you'd expect if you think that the
values of the non duplicate elements are located in the first three array
locations.

<?php
    $numValues = count($test_beta);
    for ($i=0;$i<=$numValues; $i++)
       echo("test_beta[$i] = $test_beta[$i] <br>");
    echo ("Number of elements in test_beta = $numValues ");
?>

will give you:

test_beta[0] =
test_beta[1] = aa
test_beta[2] =
Number of elements in test_beta = 3

Hope that saves u some debugging time!
===============================================================================

this function will return an array with unique value and proper key increment
start from 0.

<?php
/*******************************/
function my_array_unique($somearray){
    $tmparr = array_unique($somearray);
    $i=0;
    foreach ($tmparr as $v) {
        $newarr[$i] = $v;
        $i++;
    }
    return $newarr;
}
/********************************/
?>

eg:

<?php
$foo_arr[0] ='aa'
$foo_arr[1] ='bb'
$foo_arr[2] ='cc'
$foo_arr[3] ='bb'
$foo_arr[4] ='aa'
$foo_arr[5] ='dd'
?>

normal array_unique will return:

<?php
$foo_arr[0] ='aa';
$foo_arr[1] ='bb';
$foo_arr[2] ='cc';
$foo_arr[3] ='';
$foo_arr[4] ='';
$foo_arr[5] ='dd'
?>

my_array_unique will return:

<?php
$foo_arr[0] ='aa';
$foo_arr[1] ='bb';
$foo_arr[2] ='cc';
$foo_arr[3] ='dd'
?>
===============================================================================

<?php
/**
* Removes duplicate keys from an array
*
* @param array $array
* @return array
*/
function array_unique_key($array) {
    $result = array();
    foreach (array_unique(array_keys($array)) as $tvalue) {
        $result[$tvalue] = $array[$tvalue];
    }
    return $result;
}
?>
===============================================================================

Attention!
If you use array_unique be aware of data-types! (I spent hours of debugging
because of that ...).

For example, if you've got an array containing a '3' as number and another '3'
as string it won't be eliminated by array_unique.

An Example where this can happen, without really thinking about it:

I've got an article-list with product-numbers where the third and fourth digit
is the code for the producer. So I read in the file an process it line by line
and put each producer-code into an array:
------------------------------
<?php
$i=0;
while($line = fgets($csv, 10000) {
// splitting the line, product_no is the first part:

$data = explode(";", $line);

// putting the producer_code into an array:

$producer_id[$i] = trim(substr($data[0], 2, 2));

// make a special exception:

if(trim(substr($data[0], 2, 2)) == 40) {
$producer_id[$j] = '30';
}

// in the above line if you leave the 30 without the ''
// array_unique won't work!

$i++;
}

$producer_ids = array_values(array_unique($producer_id));
?>
-------------------------------
Result is to have all producer-ID's in an array without dupes.
===============================================================================

If you need to have the keys of the duplicates in an array returned, you may
find this function useful:

<?php
function unique_events($array){
    //checks $array for duplicate values and returns an
        //array containing the keys of duplicates
    $count= array_intersect_assoc($array, array_flip( array_count_values($array
)));
    foreach($array as $key=>$value){
        if (in_array($value,$count)){
            $return[$value][]=$key;
        }
    }
    return $return;
}
?>

Example:

Input:
Array
(
    [0] => 44
    [1] => 23
    [2] => 23
    [3] => 23
    [4] => 9
    [5] => 9
    [6] => 9
    [7] => 9
    [8] => 9
    [9] => 9
    [10] => 9
    [11] => 9
)

Function returns:
Array
(
    [23] => Array
        (
            [0] => 1
            [1] => 2
            [2] => 3
        )

    [9] => Array
        (
            [0] => 4
            [1] => 5
            [2] => 6
            [3] => 7
            [4] => 8
            [5] => 9
            [6] => 10
            [7] => 11
        )

)
===============================================================================

if you wish to unique the arrays recusively(multi dimensional) no matter how
deep hope this function can help you:

function array_unique_recusive($arr){
foreach($arr as $key=>$value)
if(gettype($value)=='array')
    $arr[$key]=array_unique_recusive($value);
return array_unique($arr,SORT_REGULAR);
}
===============================================================================

Hope this can help...

<?php
function array_unique_key_group($array) {
    if(!is_array($array))
        return false;

    $temp = array_unique($array);
    foreach($array as $key => $val) {
        $i = array_search($val,$temp);
        if(!empty($i) && $key != $i) {
            $temp[$i.','.$key] = $temp[$i];
            unset($temp[$i]);
        }
    }
    return $temp;
}
?>

this function return an array that is unique, but preserve every key for the
element...
sorry for bad english I'm italian...

$array['asd'] = 'value';
$array['lol'] = 'value';
$array['foo'] = 'val';
$array['bar'] = 'val';

var_dump(array_unique_key_group($array));
// will be output
array(2) { ["asd,lol"]=> string(5) "value" ["foo,bar"]=> string(3) "val" }
===============================================================================

The shortest way i found to remove duplicate array from a column,
For example if you parse Multiple XML sources, you can remove duplicate items
that contain the same link.

<?PHP
function        remove_duplicate($array, $field)
{
  foreach ($array as $sub)
    $cmp[] = $sub[$field];
  $unique = array_unique($cmp);
  foreach ($unique as $k => $rien)
    $new[] = $array[$k];
  return $new;
}
?>
===============================================================================

To get a list of the duplicated values in an array, array_unique isn't much
help. Instead, use array_filter in conjunction with a callback function, as
below:

<?php
$checkKeysUniqueComparison = create_function('$value','if ($value > 1) return
true;');
$result = array_keys (array_filter (array_count_values($array), 
$checkKeysUniqueComparison));
?>

These two lines therefore will create $result, an array of duplicated values in
the array $array, once each. E.g. the array
$array = array ("a", "b", "a", "b", "x", "y", "z", "x");
gives the result
Array([0] => a [1] => b [2] => x)
===============================================================================

array_unique only compares with the string,
But to compare with various types of variables I used like this:

<?php
/**
* master ArrayUnique
* now compare all types
* @param array $array
* @return array
*/
function arrayUnique($array)
{
    foreach ($array as $k => $v) {
        foreach ($array as $k2 => $v2) {
            if (($v2 == $v) && ($k != $k2)) {
                unset($array[$k]);
            }
        }
    }
    return $array;
}

$a = [];

$a[] = (object)['nome' => 'Bob'];
$a[] = (object)['nome' => 'Peter'];
$a[] = (object)['nome' => 'Jhon'];
$a[] = (object)['nome' => 'James'];
$a[] = (object)['nome' => 'David'];
$a[] = (object)['nome' => 'Bob']; // repeated

if ($a[0] == $a[5]) { // true
    echo 'yes';
} else {
    echo 'not';
}

echo "\n\n";

$a = arrayUnique($a);

print_r($a);
?>
===============================================================================

I made an array_unique function to handle deep arrays:

<?php
    function array_unique_deep($array) {
        $values=array();
        //ideally there would be some is_array() testing for $array here...
        foreach ($array as $part) {
            if (is_array($part)) $values=array_merge($values,array_unique_deep(
$part));
            else $values[]=$part;
        }
        return array_unique($values);
    }
   
    $test=array(123,456,array(789,123,array(456),789),array(123));
    print_r(array_unique_deep($test));
   
?>

outputs

Array
(
    [0] => 123
    [1] => 456
    [2] => 789
)
===============================================================================

Let's implement array_unique_callback() !

Function:
<?php

function array_unique_callback(array $arr, callable $callback, $strict = false)
{
    return array_filter(
        $arr,
        function ($item) use ($strict, $callback) {
            static $haystack = array();
            $needle = $callback($item);
            if (in_array($needle, $haystack, $strict)) {
                return false;
            } else {
                $haystack[] = $needle;
                return true;
            }
        }
    );
}

?>

Usage:
<?php

$companies = array(
    0 => array(
        'name' => 'Foo - Ltd.',
        'phone' => 'XXX-YYY-ZZZ',
        'category' => 'supplyment',
    ),
    1 => array(
        'name' => 'Bar - Ltd.',
        'phone' => 'xxx-yyy-zzz',
        'category' => 'supplyment',
    ),
    2 => array(
        'name' => 'Baz - Ltd.',
        'phone' => 'AAA-BBB-CCC',
        'category' => 'alcohol',
    ),
);

$companies = array_unique_callback(
    $companies,
    function ($company) {
        return $company['category'];
    }
);

print_r($companies);

?>

Result:

Array
(
    [0] => Array
        (
            [name] => Foo - Ltd.
            [phone] => XXX-YYY-ZZZ
            [category] => supplyment
        )

    [2] => Array
        (
            [name] => Baz - Ltd.
            [phone] => AAA-BBB-CCC
            [category] => alcohol
        )

)
===============================================================================

Prior to 5.2.9 you may create a list of unique objects this way:

<?php
for (; ; ) {
  // ...
  $uniqueObjectList[spl_object_hash($myObject)] = $myObject;
}
?>
===============================================================================

Following code copies unique values from MyArray to TempArray.
Then copies non-empty elements from TempArray to UniqueArray.

Not the most elegant solution, but it works.

<?php
$TempArray = array_unique($MyArray);
while (list($index,$data)=each($TempArray)) {
      if (isempty($data)) {
          $UniqueArray[$index]=$data;
      }
}
?>
===============================================================================

I had to write a bunch of results to an array with a high probability of
duplicates.
The array was written to the file in chunks, using a for loop. It occurred to
me that I often had blank lines in my file.

Because this function preserve keys, I had gaps in my numeric keys. If you
don't want to preserve keys, like me, you can use the following function.

<?php
function array_unique_ignore_keys(&$array, $sort_flags = SORT_STRING) {
    return array_values(array_unique($array, $sort_flags));
}
?>
===============================================================================

array_unique for multidimensional arrays. similar to the DISTINCT in SQL
function.
the function can group, sum and count keys

<?PHP
/*
$array - nothing to say
$group_keys - columns which have to be grouped - can be STRING or ARRAY
(STRING, STRING[, ...])
$sum_keys - columns which have to be summed - can be STRING or ARRAY (STRING,
STRING[, ...])
$count_key - must be STRING - count the grouped keys
*/
function array_distinct ($array, $group_keys, $sum_keys = NULL, $count_key = 
NULL){
  if (!is_array ($group_keys)) $group_keys = array ($group_keys);
  if (!is_array ($sum_keys)) $sum_keys = array ($sum_keys);

  $existing_sub_keys = array ();
  $output = array ();

  foreach ($array as $key => $sub_array){
    $puffer = NULL;
    #group keys
    foreach ($group_keys as $group_key){
      $puffer .= $sub_array[$group_key];
    }
    $puffer = serialize ($puffer);
    if (!in_array ($puffer, $existing_sub_keys)){
      $existing_sub_keys[$key] = $puffer;
      $output[$key] = $sub_array;
    }
    else{
      $puffer = array_search ($puffer, $existing_sub_keys);
      #sum keys
      foreach ($sum_keys as $sum_key){
        if (is_string ($sum_key)) $output[$puffer][$sum_key] += $sub_array[
$sum_key];
      }
      #count grouped keys
      if (!array_key_exists ($count_key, $output[$puffer])) $output[$puffer][
$count_key] = 1;
      if (is_string ($count_key)) $output[$puffer][$count_key]++;
    }
  }
  return $output;
}
?>
