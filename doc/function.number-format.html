
number_format

(PHP 4, PHP 5, PHP 7)

number_format — 以千位分隔符方式格式化一个数字

说明

string number_format ( float $number [, int $decimals = 0 ] )
string number_format ( float $number , int $decimals = 0 , string $dec_point =
"." , string $thousands_sep = "," )

本函数可以接受1个、2个或者4个参数（注意：不能是3个）:

如果只提供第一个参数，number的小数部分会被去掉并且每个千位分隔符都是英文小写逗
号","

如果提供两个参数，number将保留小数点后的位数到你设定的值，其余同楼上

如果提供了四个参数，number 将保留decimals个长度的小数部分, 小数点被替换为
dec_point，千位分隔符替换为thousands_sep

参数

number

    你要格式化的数字

decimals

    要保留的小数位数

dec_point

    指定小数点显示的字符

thousands_sep

    指定千位分隔符显示的字符

返回值

格式化以后的 number.

更新日志

版本                                    说明
5.4.0 This function now supports multiple bytes in dec_point and thousands_sep.
      Only the first byte of each separator was used in older versions.

范例

Example #1 number_format() Example

For instance, French notation usually use two decimals, comma (',') as decimal
separator, and space (' ') as thousand separator. This is achieved with this
line :

<?php

$number = 1234.56;

// english notation (default)
$english_format_number = number_format($number);
// 1,235

// French notation
$nombre_format_francais = number_format($number, 2, ',', ' ');
// 1 234,56

$number = 1234.5678;

// english notation without thousands separator
$english_format_number = number_format($number, 2, '.', '');
// 1234.57

?>

参见

  • money_format() - Formats a number as a currency string
  • sprintf() - Return a formatted string
  • printf() - 输出格式化字符串
  • sscanf() - 根据指定格式解析输入的字符


User Contributed Notes 66 notes

===============================================================================

It's not explicitly documented; number_format also rounds:

<?php
$numbers = array(0.001, 0.002, 0.003, 0.004, 0.005, 0.006, 0.007, 0.008, 0.009
);
foreach ($numbers as $number)
    print $number."->".number_format($number, 2, '.', ',')."<br>";
?>

0.001->0.00
0.002->0.00
0.003->0.00
0.004->0.00
0.005->0.01
0.006->0.01
0.007->0.01
0.008->0.01
0.009->0.01
===============================================================================

Outputs a human readable number.

<?php
    #    Output easy-to-read numbers
    #    by james at bandit.co.nz
    function bd_nice_number($n) {
        // first strip any formatting;
        $n = (0+str_replace(",","",$n));
       
        // is this a number?
        if(!is_numeric($n)) return false;
       
        // now filter it;
        if($n>1000000000000) return round(($n/1000000000000),1).' trillion';
        else if($n>1000000000) return round(($n/1000000000),1).' billion';
        else if($n>1000000) return round(($n/1000000),1).' million';
        else if($n>1000) return round(($n/1000),1).' thousand';
       
        return number_format($n);
    }
?>

Outputs:

247,704,360 -> 247.7 million
866,965,260,000 -> 867 billion
===============================================================================

I ran across an issue where I wanted to keep the entered precision of a real
value, without arbitrarily rounding off what the user had submitted.

I figured it out with a quick explode on the number before formatting. I could
then format either side of the decimal.

<?php
      function number_format_unlimited_precision($number,$decimal = '.')
      {
           $broken_number = explode($decimal,$number);
           return number_format($broken_number[0]).$decimal.$broken_number[1];
      }
?>
===============================================================================

// Here is a function that produces the same output as number_format() but also
works with numbers bigger than 2^53.

function a_number_format($number_in_iso_format, $no_of_decimals=3,
$decimals_separator='.', $thousands_separator='', $digits_grouping=3){
    // Check input variables
    if (!is_numeric($number_in_iso_format)){
        error_log("Warning! Wrong parameter type supplied in my_number_format()
function. Parameter \$number_in_iso_format is not a number.");
        return false;
    }
    if (!is_numeric($no_of_decimals)){
        error_log("Warning! Wrong parameter type supplied in my_number_format()
function. Parameter \$no_of_decimals is not a number.");
        return false;
    }
    if (!is_numeric($digits_grouping)){
        error_log("Warning! Wrong parameter type supplied in my_number_format()
function. Parameter \$digits_grouping is not a number.");
        return false;
    }
   
   
    // Prepare variables
    $no_of_decimals = $no_of_decimals * 1;
   
   
    // Explode the string received after DOT sign (this is the ISO separator of
decimals)
    $aux = explode(".", $number_in_iso_format);
    // Extract decimal and integer parts
    $integer_part = $aux[0];
    $decimal_part = isset($aux[1]) ? $aux[1] : '';
   
    // Adjust decimal part (increase it, or minimize it)
    if ($no_of_decimals > 0){
        // Check actual size of decimal_part
        // If its length is smaller than number of decimals, add trailing
zeros, otherwise round it
        if (strlen($decimal_part) < $no_of_decimals){
            $decimal_part = str_pad($decimal_part, $no_of_decimals, "0");
        } else {
            $decimal_part = substr($decimal_part, 0, $no_of_decimals);
        }
    } else {
        // Completely eliminate the decimals, if there $no_of_decimals is a
negative number
        $decimals_separator = '';
        $decimal_part       = '';
    }
   
    // Format the integer part (digits grouping)
    if ($digits_grouping > 0){
        $aux = strrev($integer_part);
        $integer_part = '';
        for ($i=strlen($aux)-1; $i >= 0 ; $i--){
            if ( $i % $digits_grouping == 0 && $i != 0){
                $integer_part .= "{$aux[$i]}{$thousands_separator}";
            } else {
                $integer_part .= $aux[$i];           
            }
        }
    }
   
    $processed_number = "{$integer_part}{$decimals_separator}{$decimal_part}";
    return $processed_number;
}

$original_number= 9223372036854775805;
echo a_number_format($original_number, 4, '.',"'",3);
// Outputs: 9'223'372'036'854'775'805.1230
===============================================================================

For Zero fill - just use the sprintf() function

$pr_id = 1;
$pr_id = sprintf("%03d", $pr_id);
echo $pr_id;

//outputs 001
-----------------

$pr_id = 10;
$pr_id = sprintf("%03d", $pr_id);
echo $pr_id;

//outputs 010
-----------------

You can change %03d to %04d, etc.
===============================================================================

Just an observation:
The number_format rounds the value of the variable.

$val1 = 1.233;
$val2 = 1.235;
$val3 = 1.237;

echo number_format($val1,2,",","."); // returns: 1,23
echo number_format($val2,2,",","."); // returns: 1,24
echo number_format($val3,2,",","."); // returns: 1,24
===============================================================================

If you use space as a separator, it will break on that space in HTML tables...

Furthermore, number_format doesn't like '&nbsp;' as a fourth parameter. I wrote
the following function to display the numbers in an HTML table.

  function numberfix($number)
  {
    $number = number_format($number,0,","," ");
    return str_replace(" ", "&nbsp;", $number);
  }

For use in:
<table><tr><td><?php echo $number; ?></td></tr></table>
===============================================================================

In my function my_number_format() [shown below] there was a bug.

If a negative number which is smaller than 1 was entered (-0,...), then the
result was wrongly positive because +0 is equal to -0 (the content of $tmp[0]
which was interpretet as numeric value).

Here is the corrected version:

<?php

function my_number_format($number, $dec_point, $thousands_sep)
{
    $was_neg = $number < 0; // Because +0 == -0
    $number = abs($number);

    $tmp = explode('.', $number);
    $out = number_format($tmp[0], 0, $dec_point, $thousands_sep);
    if (isset($tmp[1])) $out .= $dec_point.$tmp[1];

    if ($was_neg) $out = "-$out";

    return $out;
}

?>

Thanks to Federico Cassinelli for the bug report.



[EDIT BY danbrown AT php DOT net: The original note follows.]

Let's say we got the number $inp = 1234.56

By using

<?php
return number_format($inp, 2, ',', '.');
?>

you can get the German format 1.234,56. (Comma as decimal separator and point
as thousand separator)

But I have a problem with that: I want to add commas as thousand separators and
change the decimal-separator (this could also be done with str_replace), but I
do not want to change the amount of fractional digits!

But since the 2nd argument of number_format is necessary to enter the 3rd and
4th argument, this cannot be done with number_format. You have to change the
fractional digits with this function.

But I want that 1234.56 changes into 1.234,56 and 1234.567890123456 changes
into 1.234,567890123456

So, I created following function, that doesn't change the amount of fractional
digits:

<?php
function my_number_format($number, $dec_point, $thousands_sep)
{
  $tmp = explode('.', $number);
  $out = number_format($tmp[0], 0, $dec_point, $thousands_sep);
  if (isset($tmp[1])) $out .= $dec_point.$tmp[1];

  return $out;
}
?>
===============================================================================

I'm not sure if this is the right place anyway, but "ben at last dot fm"'s
ordinal function can be simplified further by removing the redundant "floor"
(the result of floor is still a float, it's the "%" that's converting to int)
and outer switch.

Note that this version also returns the number with the suffix on the end, not
just the suffix.

<?php
function ordinal($num)
{
    // Special case "teenth"
    if ( ($num / 10) % 10 != 1 )
    {
        // Handle 1st, 2nd, 3rd
        switch( $num % 10 )
        {
            case 1: return $num . 'st';
            case 2: return $num . 'nd';
            case 3: return $num . 'rd'; 
        }
    }
    // Everything else is "nth"
    return $num . 'th';
}
?>
===============================================================================

To prevent the rounding that occurs when next digit after last significant
decimal is 5 (mentioned by several people below):

<?php
function fnumber_format($number, $decimals='', $sep1='', $sep2='') {

        if (($number * pow(10 , $decimals + 1) % 10 ) == 5)  //if next not
significant digit is 5
            $number -= pow(10 , -($decimals+1));

        return number_format($number, $decimals, $sep1, $sep2);

}

$t=7.15;
echo $t . " | " . number_format($t, 1, '.', ',') .  " | " . fnumber_format($t, 
1, '.', ',') . "\n\n";
//result is: 7.15 | 7.2 | 7.1

$t=7.3215;
echo $t . " | " . number_format($t, 3, '.', ',') .  " | " . fnumber_format($t, 
3, '.', ',') . "\n\n";
//result is: 7.3215 | 7.322 | 7.321
} ?>

have fun!
===============================================================================

I was looking for a SIMPLE way to format currency and account for negative
values while not losing the calculation properties of my number.  Here's my
function - it's not rocket science, but maybe can help someone along the way.

<?php
function wims_currency($number) {
   if ($number < 0) {
     $print_number = "($ " . str_replace('-', '', number_format ($number, 2, 
".", ",")) . ")";
    } else {
     $print_number = "$ " .  number_format ($number, 2, ".", ",") ;
   }
   return $print_number;
}
?>
Sample use:

<?php
$pur_po_total =  ($pur_po_total + $pur_item_total);
$print_pur_po_total = wims_currency($pur_po_total);
?>

Returns (for example)    $ 44,561.00 or, if a negative ($ 407,250.00)

This way, I use my 1st variable for calculations and my 2nd variable for
output.  I'm sure there are better ways to do it,  but this got me back on
track.
===============================================================================

To separate big numbers like the spanish language you can do this:
Tis example is based on facebook followers:

number_format ($infoF  , 0 , ' , ' ,  '.');

it will output:

//1.187.037

instead of comas.
===============================================================================

formatting numbers may be more easy if u use number_format function.

I also wrote this :
function something($number)
{
    $locale = localeconv();
    return number_format($number,
       $locale['frac_digits'],
        $locale['decimal_point'],
        $locale['thousands_sep']);
}

hope this helps =)
[]'s
===============================================================================

This function is used for reformatting already formatted numbers.
<?php
function formatNumber($number, $format=[], $oldDecimalSeparator=",.·'", 
$multiplier=1)
{
    /**
    $format — the array of formatting options, details in the example.
    $oldDecimalSeparator — decimal separator used in the $number. If the
separator can meet different characters, then you need to record them all, for
example: ',.'.
    $multiplier — typically used to adjust prices up or down.
    */
    if ($format) {
        $format += ['numOfDecimals' => 0, 'decimalSeparator' => '.', 
'thousandSeparator' => '']; # Default format
        # Find decimal separator
        # The decimal separator is the one that is the last and does not occur
more than once
        if ($letters = str_replace(' ', '', $number)) { # Replace spaces
            if ($letters = preg_replace('/^-/', '', $letters)) { # Remove minus
                if ($letters = preg_replace('/[0-9]/', '', $letters)) { # Get
all non digits
                    $lastletter = substr($letters, -1); # Returns last char
                    if (substr_count($letters, $lastletter) == 1) {
                        if (strpos($oldDecimalSeparator, $lastletter)  !== 
false)
                            $oldDecimalSep = $lastletter;
                        else
                            return $number;
                    }
                }
            }
        }
        $number = preg_replace('/[^0-9-]/', '', $number); # Remove all non
digits except 'minus'
        if ($oldDecimalSep)
            $number = str_replace($oldDecimalSep, '.', $number); # Format to
float
        if ($multiplier != 1)
            $number = $number * $multiplier;
        # Convert float to new format
        $number = number_format($number,
            $format['numOfDecimals'],
            $format['decimalSeparator'],
            $format['thousandSeparator']
        ); 
    }
    return $number;   
}

/**
Example. Formatting data in which the decimal separator can occur as the comma
and dot. Formatting into Russian format: -12 345,67
*/
echo formatNumber($number, [
    'numOfDecimals' => 2,
    'decimalSeparator' => ',',
    'thousandSeparator' => '&nbsp;'
], ',.');

?>
===============================================================================

//Cep Brasil
    function getCEP($cep){
        return number_format(substr($cep, 0, 5),0,"",".").'-'.substr($cep, 5,
3);
    }
//Saida 12.345-67
===============================================================================

I came into a need to show two decimal places, but the desire to drop the
decimal portion off if it is zero. This function is a direct replacement for
number_format:

<?PHP
function number_format_clean($number,$precision=0,$dec_point='.',$thousands_sep
=',')
    {
    RETURN trim(number_format($number,$precision,$dec_point,$thousands_sep),'0'
.$dec_point);
    }
?>

Example:

<?PHP
echo number_format_clean(25.00,2);
echo number_format_clean(25.52,2);
echo number_format_clean(50.10,2);
echo number_format_clean(05.50,2);
?>

Outputs:
25
25.52
50.1
5.5

Good for weight conversions (1 oz vs. 1.00 oz). Feels less "automated."

The above will trim all insignificant zeros from both ends of the string,
though I'm not sure I've ever seen leading zeros returned.
===============================================================================

<?php

    function convertNumberToWordsForIndia($number){
        //A function to convert numbers into Indian readable words with Cores,
Lakhs and Thousands.
        $words = array(
        '0'=> '' ,'1'=> 'one' ,'2'=> 'two' ,'3' => 'three','4' => 'four','5' =>
'five',
        '6' => 'six','7' => 'seven','8' => 'eight','9' => 'nine','10' => 'ten',
        '11' => 'eleven','12' => 'twelve','13' => 'thirteen','14' => 'fouteen',
'15' => 'fifteen',
        '16' => 'sixteen','17' => 'seventeen','18' => 'eighteen','19' => 
'nineteen','20' => 'twenty',
        '30' => 'thirty','40' => 'fourty','50' => 'fifty','60' => 'sixty','70' 
=> 'seventy',
        '80' => 'eighty','90' => 'ninty');
       
        //First find the length of the number
        $number_length = strlen($number);
        //Initialize an empty array
        $number_array = array(0,0,0,0,0,0,0,0,0);       
        $received_number_array = array();
       
        //Store all received numbers into an array
        for($i=0;$i<$number_length;$i++){    $received_number_array[$i] = 
substr($number,$i,1);    }

        //Populate the empty array with the numbers received - most critical
operation
        for($i=9-$number_length,$j=0;$i<9;$i++,$j++){ $number_array[$i] = 
$received_number_array[$j]; }
        $number_to_words_string = "";       
        //Finding out whether it is teen ? and then multiplying by 10, example
17 is seventeen, so if 1 is preceeded with 7 multiply 1 by 10 and add 7 to it.
        for($i=0,$j=1;$i<9;$i++,$j++){
            if($i==0 || $i==2 || $i==4 || $i==7){
                if($number_array[$i]=="1"){
                    $number_array[$j] = 10+$number_array[$j];
                    $number_array[$i] = 0;
                }       
            }
        }
       
        $value = "";
        for($i=0;$i<9;$i++){
            if($i==0 || $i==2 || $i==4 || $i==7){    $value = $number_array[$i]
*10; }
            else{ $value = $number_array[$i];    }           
            if($value!=0){ $number_to_words_string.= $words["$value"]." "; }
            if($i==1 && $value!=0){    $number_to_words_string.= "Crores "; }
            if($i==3 && $value!=0){    $number_to_words_string.= "Lakhs ";    }
            if($i==5 && $value!=0){    $number_to_words_string.= "Thousand "; }
            if($i==6 && $value!=0){    $number_to_words_string.= "Hundred &amp;
"; }
        }
        if($number_length>9){ $number_to_words_string = "Sorry This does not
support more than 99 Crores"; }
        return ucwords(strtolower("Indian Rupees ".$number_to_words_string)."
Only.");
    }

    echo convertNumberToWordsForIndia("987654321");
   
    //Output ==> Indian Rupees Ninty Eight Crores Seventy Six Lakhs Fifty Four
Thousand Three Hundred & Twenty One Only.
?>
===============================================================================

Here a function to filter exponential notation like 6e-06. Turn it to 0,000006
for comfortable reading. Supporting various number of decimals!

<?php
function easy_number_format($number, $dec_point, $thousands_sep)
{
    $number = rtrim(sprintf('%f', $number), "0");
    if (fmod($nummer, 1) != 0) {                     
        $array_int_dec = explode('.', $number);
    } else {
        $array_int_dec= array(strlen($nummer), 0);
    }
    (strlen($array_int_dec[1]) < 2) ? ($decimals = 2) : ($decimals = strlen(
$array_int_dec[1]));
    return number_format($number, $decimals, $dec_point, $thousands_sep);
}
?>

The maximum accuracy depends on sprintf('%f', $number). In this case 6
decimals. Expand it to 10 with '%.10f'.
===============================================================================

There has been some suggestions around on how to keep trailing zeros. Best way
is to use the example for currency provided by the php-crew in the sprintf
function help section.

That is:
<?php
$money1 = 68.75;
$money2 = 54.35;
$money = $money1 + $money2;

// echo $money will output "123.1";

$formatted = sprintf("%01.2f", $money); // << this does the trick!

// echo $formatted will output "123.10"

?>
===============================================================================

Here a function to get de size of a file in a human way using the function
number_format:

function convertFileSize($file, $size=null, $decimals=2, $dec_sep='.',
$thousands_sep=','){
if (!is_file($file)){
  return "El fichero no existe";
}
$bytes = filesize($file);
$sizes = 'BKMGTP';
if (isset($size)){
  $factor = strpos($sizes, $size[0]);
  if ($factor===false){
   return "El tamaño debe ser B, K, M, G, T o P";
  }
} else {
  $factor = floor((strlen($bytes) - 1) / 3);
  $size = $sizes[$factor];
}
return number_format($bytes / pow(1024, $factor), $decimals, $dec_sep,
$thousands_sep).' '.$size;
}

Source: http://softontherocks.blogspot.com/2014/11/
obtener-el-tamano-de-un-fichero-y.html
===============================================================================

Some programmers may have scripts that use the number_format function twice on
a variable.  However, if a number is 4 or more digits, using the function twice
with only the decimals parameter will lose part of the value that follows the
thousands separator.

<?php
$var = number_format(2234,2);
$var = number_format($var,2);
echo $var;
# Expected Output: 2,234.00
# Actual Output: 2.00
?>

To fix, remove the thousands separator by setting the decimal point and
thousands separator parameters like so:

<?php
$var = number_format(2234,2,'.','');
$var = number_format($var,2,'.','');
echo $var;
# Expected Output: 2234.00
# Actual Output: 2234.00
?>

If it's 3 digits or less, then it works normally with only the decimals
parameter since there is no thousands separator.

<?php
$var = number_format(123,2);
$var = number_format($var,2);
echo $var;
# Expected Output: 123.00
# Actual Output: 123.00
?>
===============================================================================

function to convert numbers to words
indian: thousand,lakh,crore
Note: function can only convert nos upto 99 crores

<?php
$words = array('0'=> '' ,'1'=> 'one' ,'2'=> 'two' ,'3' => 'three','4' => 'four'
,'5' => 'five','6' => 'six','7' => 'seven','8' => 'eight','9' => 'nine','10' =>
'ten','11' => 'eleven','12' => 'twelve','13' => 'thirteen','14' => 'fouteen',
'15' => 'fifteen','16' => 'sixteen','17' => 'seventeen','18' => 'eighteen','19'
=> 'nineteen','20' => 'twenty','30' => 'thirty','40' => 'fourty','50' => 
'fifty','60' => 'sixty','70' => 'seventy','80' => 'eighty','90' => 'ninty',
'100' => 'hundred &','1000' => 'thousand','100000' => 'lakh','10000000' => 
'crore');
function no_to_words($no)
{    global $words;
    if($no == 0)
        return ' ';
    else {           $novalue='';$highno=$no;$remainno=0;$value=100;$value1=
1000;       
            while($no>=100)    {
                if(($value <= $no) &&($no  < $value1))    {
                $novalue=$words["$value"];
                $highno = (int)($no/$value);
                $remainno = $no % $value;
                break;
                }
                $value= $value1;
                $value1 = $value * 100;
            }       
          if(array_key_exists("$highno",$words))
              return $words["$highno"]." ".$novalue." ".no_to_words($remainno);
          else {
             $unit=$highno%10;
             $ten =(int)($highno/10)*10;            
             return $words["$ten"]." ".$words["$unit"]." ".$novalue." ".
no_to_words($remainno);
           }
    }
}
echo no_to_words(999978987);

?>
===============================================================================

Writing a function to get English ordinals for numbers is a problem every
computer science student will face. Here's my solution - nice, short and
simple:

<?php
    function st($i) {
        switch( floor($i/10) % 10 ) {
            default:
                switch( $i % 10 ) {
                    case 1: return 'st';
                    case 2: return 'nd';
                    case 3: return 'rd';  
                }
            case 1:
        }
        return 'th';
    }
?>
===============================================================================

Simple function to show money as only dollars if no cents, but will show 2
decimals if cents exist.

The 'cents' flag can force to never or always show 2 decimals

<?php

// formats money to a whole number or with 2 decimals; includes a dollar sign
in front
function formatMoney($number, $cents = 1) { // cents: 0=never, 1=if needed, 2=
always
  if (is_numeric($number)) { // a number
    if (!$number) { // zero
      $money = ($cents == 2 ? '0.00' : '0'); // output zero
    } else { // value
      if (floor($number) == $number) { // whole number
        $money = number_format($number, ($cents == 2 ? 2 : 0)); // format
      } else { // cents
        $money = number_format(round($number, 2), ($cents == 0 ? 0 : 2)); //
format
      } // integer or decimal
    } // value
    return '$'.$money;
  } // numeric
} // formatMoney

$a = array(1, 1234, 1.5, 1.234, 2.345, 2.001, 2.100, '1.000', '1.2345', '12345'
, 0, '0.00');

// show cents if needed ($cents=1)
foreach ($a as $b) echo ('<br />'.$b.' = '.formatMoney($b, 1));
1 = $1
1234 = $1,234
1.5 = $1.50
1.234 = $1.23
2.345 = $2.35
2.001 = $2.00
2.1 = $2.10
1.000 = $1
1.2345 = $1.23
12345 = $12,345
0 = $0
0.00 = $0

// never show cents ($cents=0)
foreach ($a as $b) echo ('<br />'.$b.' = '.formatMoney($b, 0));
1 = $1
1234 = $1,234
1.5 = $2
1.234 = $1
2.345 = $2
2.001 = $2
2.1 = $2
1.000 = $1
1.2345 = $1
12345 = $12,345
0 = $0
0.00 = $0

// always show cents ($cents=2)
foreach ($a as $b) echo ('<br />'.$b.' = '.formatMoney($b, 2));
1 = $1.00
1234 = $1,234.00
1.5 = $1.50
1.234 = $1.23
2.345 = $2.35
2.001 = $2.00
2.1 = $2.10
1.000 = $1.00
1.2345 = $1.23
12345 = $12,345.00
0 = $0.00
0.00 = $0.00

?>

Cheers :)

And remember to always contribute custom functions if they might be useful to
the rest of us or future versions of the php language.
===============================================================================

Exemplo: Example:

<?php
$number = 1234567.896;
echo '1: '.number_format($number, 2, ',', '').'<br>';
echo '2: '.number_format($number, 2, '.', '').'<br>';
echo '3: '.number_format($number, 2, ',', '.').'<br>';
echo '4: '.number_format($number, 2, '.', ',').'<br>';
echo '5: '.number_format($number, 2, ',', ' ').'<br>';
echo '6: '.number_format($number, 2, ',', "'").'<br>';
echo '7: '.number_format($number, 2, '', '').'<br>';
?>

Resultado: Result:

1: 1234567,90   -> Decimal separado por ,
2: 1234567.90   -> Decimal separado por .
3: 1.234.567,90 -> Moeda Brasil, Alemanha
4: 1,234,567.90 -> Inglês, USA
5: 1 234 567,90 -> França
6: 1'234'567,90 -> Suíça
7: 123456790    -> Sem decimal
===============================================================================

here is the code to convert number to Indonesian text, this code has limitation
as is number_format function. sorry for this.
/*
* Created : Iwan Sapoetra - Jun 13, 2008
* Project : Web
* Package : cgaf
*
*/
function terbilang( $num ,$dec=4){
    $stext = array(
        "Nol",
        "Satu",
        "Dua",
        "Tiga",
        "Empat",
        "Lima",
        "Enam",
        "Tujuh",
        "Delapan",
        "Sembilan",
        "Sepuluh",
        "Sebelas"
    );
    $say  = array(
        "Ribu",
        "Juta",
        "Milyar",
        "Triliun",
        "Biliun", // remember limitation of float
        "--apaan---" ///setelah biliun namanya apa?
    );
    $w = "";

    if ($num <0 ) {
        $w  = "Minus ";
        //make positive
        $num *= -1;
    }

    $snum = number_format($num,$dec,",",".");
    die($snum);
    $strnum =  explode(".",substr($snum,0,strrpos($snum,",")));
    //parse decimalnya
    $koma = substr($snum,strrpos($snum,",")+1);

    $isone = substr($num,0,1)  ==1;
    if (count($strnum)==1) {
        $num = $strnum[0];
        switch (strlen($num)) {
            case 1:
            case 2:
                if (!isset($stext[$strnum[0]])){
                    if($num<19){
                        $w .=$stext[substr($num,1)]." Belas";
                    }else{
                        $w .= $stext[substr($num,0,1)]." Puluh ".
                            (intval(substr($num,1))==0 ? "" : $stext[substr
($num,1)]);
                    }
                }else{
                    $w .= $stext[$strnum[0]];
                }
                break;
            case 3:
                $w .=  ($isone ? "Seratus" : terbilang(substr($num,0,1)) .
                    " Ratus").
                    " ".(intval(substr($num,1))==0 ? "" : terbilang(substr
($num,1)));
                break;
            case 4:
                $w .=  ($isone ? "Seribu" : terbilang(substr($num,0,1)) .
                    " Ribu").
                    " ".(intval(substr($num,1))==0 ? "" : terbilang(substr
($num,1)));
                break;
            default:
                break;
        }
    }else{
        $text = $say[count($strnum)-2];
        $w = ($isone && strlen($strnum[0])==1 && count($strnum) <=3?
"Se".strtolower($text) : terbilang($strnum[0]).' '.$text);
        array_shift($strnum);
        $i =count($strnum)-2;
        foreach ($strnum as $k=>$v) {
            if (intval($v)) {
                $w.= ' '.terbilang($v).' '.($i >=0 ? $say[$i] : "");
            }
            $i--;
        }
    }
    $w = trim($w);
    if ($dec = intval($koma)) {
        $w .= " Koma ". terbilang($koma);
    }
    return trim($w);
}
//example
echo terbilang(999999999999)."\n";
/**
* result : Sembilan Ratus Sembilan Puluh Sembilan Milyar Sembilan Ratus
Sembilan Puluh Sembilan Juta Sembilan Ratus Sembilan Puluh Sembilan Ribu
Sembilan Ratus Sembilan Puluh Sembilan
*/
echo terbilang(9999999999999999);
/**
* todo : fix this bug pleasese
* problem : number_format(9999999999999999) <--- 10.000.000.000.000.000,0000
* Result : Sepuluh Biliun
*/
===============================================================================

Using the number_format I'm having some unexpected results.  30% of 14.95
(14.95 * .3) = 4.485.  Now 4.485 rounded to two decimal places should give me
4.49.

Example:
<?php
echo number_format(14.95 * .3, 2, '.', '') . "\n";
echo number_format(4.485, 2, '.', '') . "\n";
?>

Unexpected Results:
4.48
4.49
===============================================================================

I have to verify price data from several formats, eg:
- 12.345,67 (German)
- 12,345.67 (English)
- 12 345,67 (French)
- 12'345,67 (Swiss)

Here is a quick function which helps me out of all this format mess, but please
not the I only check for:
- positive values
- max 2 digits on the right side (.12)

function mk_price_to_float($price){
    $price = trim($price);
    if(preg_match("~^([0-9]+|(?:(?:[0-9]{1,3}([.,' ]))+[0-9]{3})+)(([.,])[0-9]
{1,2})?$~", $price, $r)){
        if(!empty($r['2'])){
            $pre = preg_replace("~[".$r['2']."]~", "", $r['1']);
        }else{
            $pre = $r['1'];
        }
        if(!empty($r['4'])){
            $post = ".".preg_replace("~[".$r['4']."]~", "", $r['3']);
        }else{
            $post = false;
        }
        $form_price = $pre.$post;
        return $form_price;
    }
    return false;
}

This code is used at http://www.produkte24.com/ and http://www.who-sells-it.com
/ and works like a charm.
===============================================================================

I use the following to get around the negative zero problem:

<?php
function currency_format($amount, $precision = 2, $use_commas = true, 
$show_currency_symbol = false, $parentheses_for_negative_amounts = false)
{
    /*
    **    An improvement to number_format.  Mainly to get rid of the annoying
behaviour of negative zero amounts.   
    */
    $amount = (float) $amount;
    // Get rid of negative zero
    $zero = round(0, $precision);
    if (round($amount, $precision) == $zero) {
        $amount = $zero;
    }
   
    if ($use_commas) {
        if ($parentheses_for_negative_amounts && ($amount < 0)) {
            $amount = '('.number_format(abs($amount), $precision).')';
        }
        else {
            $amount = number_format($amount, $precision);
        }
    }
    else {
        if ($parentheses_for_negative_amounts && ($amount < 0)) {
            $amount = '('.round(abs($amount), $precision).')';
        }
        else {
            $amount = round($amount, $precision);
        }
    }
   
    if ($show_currency_symbol) {
        $amount = '$'.$amount;  // Change this to use the organization's
country's symbol in the future
    }
    return $amount;
}
?>
===============================================================================

simpler function to convert a number in bytes, kilobytes....

<?php

function bytes($a) {
    $unim = array("B","KB","MB","GB","TB","PB");
    $c = 0;
    while ($a>=1024) {
        $c++;
        $a = $a/1024;
    }
    return number_format($a,($c ? 2 : 0),",",".")." ".$unim[$c];
}

?>

you may also add others units over PeraBytes when the hard disks will reach
1024 PB :)
===============================================================================

This is a simple and useful function to convert a byte number in a KB  or MB:

<?
function filesize_format ($bytes) {
  $bytes=(float)$bytes;
  if ($bytes<1024){
  $numero=number_format($bytes, 0, ',', '.')." Byte";
  return $numero;
  }
  if ($bytes<1048576){
      $numero=number_format($bytes/1024, 2, ',', '.')." KByte";
  return $numero;
  }
  if ($bytes>=1048576){
      $numero=number_format($bytes/1048576, 2, ',', '.')." MByte";
  return $numero;
  }
}
?>
===============================================================================

<?php
# Function to represent a number like '2nd', '10th', '101st' etc
function text_number($n)
{
    # Array holding the teen numbers. If the last 2 numbers of $n are in this
array, then we'll add 'th' to the end of $n
    $teen_array = array(11, 12, 13, 14, 15, 16, 17, 18, 19);
   
    # Array holding all the single digit numbers. If the last number of $n, or
if $n itself, is a key in this array, then we'll add that key's value to the
end of $n
    $single_array = array(1 => 'st', 2 => 'nd', 3 => 'rd', 4 => 'th', 5 => 'th'
, 6 => 'th', 7 => 'th', 8 => 'th', 9 => 'th', 0 => 'th');
   
    # Store the last 2 digits of $n in order to check if it's a teen number.
    $if_teen = substr($n, -2, 2);
   
    # Store the last digit of $n in order to check if it's a teen number. If $n
is a single digit, $single will simply equal $n.
    $single = substr($n, -1, 1);
   
    # If $if_teen is in array $teen_array, store $n with 'th' concantenated
onto the end of it into $new_n
    if ( in_array($if_teen, $teen_array) )
    {
        $new_n = $n . 'th';
    }
    # $n is not a teen, so concant the appropriate value of it's $single_array
key onto the end of $n and save it into $new_n
    elseif ( $single_array[$single] )
    {
        $new_n = $n . $single_array[$single];   
    }
   
    # Return new
    return $new_n;
}
?>
===============================================================================

If you want to display a number ending with ,- (like 200,-) when there are no
decimal characters and display the decimals when there are decimal characters i
use:

function DisplayDouble($value)
  {
  list($whole, $decimals) = split ('[.,]', $value, 2);
  if (intval($decimals) > 0)
    return number_format($value,2,".",",");
  else
    return number_format($value,0,".",",") .",-";
  }
===============================================================================

See also the documentation for localeconv, which will provide values for
decimal point and thousands separator from the C standard library.

Of course localeconv features many more locale information, like indicating to
put the negative sign behind the value for some locale settings which can't be
used to customize present number_format.
===============================================================================

To convert numbers to thier textual representations, you can use an adapted
version of the Number::Spell Perl module. The PHP conversion can be found here:
http://pear.php.net/package/Numbers_Words
===============================================================================

if you converted a number to a German format with number_format() and want to
save it in mySQL, you first have to change the number format back to an English
format.

For example
10.453,21 >>>> 10453.21

Here is an example how to do this:

    $field_array=explode(".", $field_inhalt);
    $field_inhalt=$field_array[0].$field_array[1];
    $foeld_array=explode(",", $field_inhalt);
    $field_inhalt=$field_array[0].".".$feld_array[1];
    $field_inhalt=sprintf($field_inhalt, 2);

$field_inhalt is the variable of the actual number you want to change to the
english format.
===============================================================================

About the function of j-a-n at gmx dot de: it's useful, but the argument of the
function is $number while the logic of the function requires it to be $in.
===============================================================================

The modification to number_format below does what I actually want it to do,
with currency, for example. I want it to show $1.40 and not $1.4 or $1.400 -
except in the rare case where I have $1.435 for something, in which case I
*don't* want it to round. The ugliness below serves my purpose.

function nof($number,$decimals) {
if (number_format($number,$decimals,'.',',') != $number) {
        return $number;
} else {
        return number_format($number,$decimals,'.',',');
        }
}
===============================================================================

You could use the following regular expression to divide
a number into parts:

$1-number without fractal part
$2-fractal part
$3-first 2 digits of the fractal part
$4-rest of the fractal part

the regex removes any leading and trailing symbols and leading zeros. It doesnt
validate the number, so 12 41 is considered to be correct input!

english notation:
/^.*?[0]*([\d\s]+)(([\.][\d]{0,2})([\d]*))?.*?$/

french notation:
/^.*?[0]*([\d\s]+)(([\,][\d]{0,2})([\d]*))?.*?$/

<?php
// truncate the fractal part up to 2 digits of an "english number":
$number = '01,234.50789';
$trunc = preg_replace(
    '/^.*?[0]*([\d\,]+)(([\.][\d]{0,2})([\d]*))?.*?$/',
    '$1$3',
    $number
);
echo $trunc;
?>

Outputs:
1,234.50

$number='e00012 41.100001e-4fasfd';
would output:
12 41.10
===============================================================================

A bug was issued that -0,00 is invalid output from number_format(), but the bug
was rejected since the number "-0.0000000000000000001E-999 is about -0". And
the developer felt this was correct output.

Please beware of negative numbers close to zero, as they might produce this
unusable (and in my opinion incorrect/off-description) output.
===============================================================================

A more reliable and concise way of doing what S. Rahmel was trying to do below
is as follows:

<?php
$field_inhalt = str_replace(array(".", ","), array("", "."), $field_inhalt);
?>

The str_replace() call will first replace all dots with blanks, and then
replace all commas with dots.  That way, it doesn't break down when you try a
number over one million (i.e. 1.010.453,21).

Drew
===============================================================================

enjoy the PHP!
<?php
function FormatPrice($price) {
    $price = preg_replace("/[^0-9\.]/", "", str_replace(',','.',$price));
    if (substr($price,-3,1)=='.') {
        $sents = '.'.substr($price,-2);
        $price = substr($price,0,strlen($price)-3);
    } elseif (substr($price,-2,1)=='.') {
        $sents = '.'.substr($price,-1);
        $price = substr($price,0,strlen($price)-2);
    } else {
        $sents = '.00';
    }
    $price = preg_replace("/[^0-9]/", "", $price);
    return number_format($price.$sents,2,'.','');
}
?>
===============================================================================

number_format is pretty fast. It's much slower than calculation though:
<?php

$start = microtime(true);

echo "<pre>";
for ($i=0;$i<100000;$i++)
{
    echo number_format(microtime(true)-$start,25)."\n";
}
echo "<hr />Parsetime: ".(microtime(true)-$start);

?>
This takes 1.03 seconds all the time. Without the -$start in the number_format
cmd, it takes exactly as long (I ran it about 20 times).
The simple calculation inside number_format takes relatively no time. Defining
the number before entering it into number_format also gives no change:
{
    $num = microtime(true)-$start;
    echo number_format($num,25)."\n";
}

Which concludes it takes about .01 sec to do a thousand number_format.
If you'd do the same routine without the number_format, it'd take .75 seconds
-> number_format very fast!
===============================================================================

I'd like to comment to the old notes of "stm555" and "woodynadobhar".
They wrote about "number_format_unlimited_precision()".
I guess many of us need that kind of function, which is the almost same
function as number_format but don't round a number.

Does Anyone know any new solution in a recent PHP version?

...
If no, how about the following function? (I fixed somethings like bugs of the
function in the old comment.)
<?php
function number_format_unchanged_precision($number, $dec_point='.', 
$thousands_sep=','){
    if($dec_point==$thousands_sep){
        trigger_error('2 parameters for ' . __METHOD__ . '() have the same
value, that is "' . $dec_point . '" for $dec_point and $thousands_sep', 
E_USER_WARNING);
        // It corresponds "PHP Warning:  Wrong parameter count for
number_format()", which occurs when you use $dec_point without $thousands_sep
to number_format().
    }
    if(preg_match('{\.\d+}', $number, $matches)===1){
        $decimals = strlen($matches[0]) - 1;
    }else{
        $decimals = 0;
    }
    return number_format($number, $decimals, $dec_point, $thousands_sep);
}
var_dump(number_format_unchanged_precision(1234.5678, ',', '.'));
var_dump(number_format_unchanged_precision(1234.5678, ','));
var_dump(number_format_unchanged_precision(12345678));
var_dump(number_format_unchanged_precision(-0.5678, ',', '.'));  // It occurred
a bug with the function in the old comment.
?>
output is:
    string(10) "1.234,5678"
    PHP Warning:  2 parameters for number_format_unchanged_precision() have the
same value, that is "," for $dec_point and $thousands_sep in...
    string(10) "1,234,5678"
    string(10) "12,345,678"
    string(7) "-0,5678"
===============================================================================

function formats numbers of datetime type,

<?php
$_GET["zaman"]="1983-8-28 5:5:5";

function _parseDatetimeToList($datetimeStr) { //datetime format: Y-m-d H-i-s
    $datetimeArray=explode(" ", $datetimeStr);
    $dateArray=explode("-",$datetimeArray[0]);
    $year=str_pad($dateArray[0], 2, "0", STR_PAD_LEFT);
    $month=str_pad($dateArray[1], 2, "0", STR_PAD_LEFT);
    $day=str_pad($dateArray[2], 2, "0", STR_PAD_LEFT);
    $timeArray=explode(":",$datetimeArray[1]);
    $hour=str_pad($timeArray[0], 2, "0", STR_PAD_LEFT);
    $minute=str_pad($timeArray[1], 2, "0", STR_PAD_LEFT);
    $second=str_pad($timeArray[2], 2, "0", STR_PAD_LEFT);
    return array($year, $month, $day, $hour, $minute, $second);
}

list($year, $month, $day, $hour, $minute, $second) = _parseDatetimeToList($_GET
["zaman"]);  // 1983-1-28 5:5:5
?>
===============================================================================

Maybe it is documented, but I just missed it. However, a comment is always
useful.

An array will always be converted into 1, so, if you have:

<?php
$my_array = array(55);
echo number_format($my_array,0,',','.');
// 1
var_dump(number_format($my_array,2,',','.'));
// string(4) "1,00"
?>

Since it took me a while to figure it out, I hope this will save somebody's
time.

Greetings !!
===============================================================================

When apply number_format on number with separator on thousands, result is
wrong. This function accept number of any format
<?php
function format_price($number,$decPlaces,$decSep,$thouSep){
       
    //$number - number for format
    //$decPlaces - number of decimal places
    //$decSep - separator for decimals
    //$thouSep - separator for thousands
   
    //first remove all white spaces
    $number=preg_replace('/\s+/', '',$number);
    //split string into array
    $numberArr = str_split($number);
    //reverse array and not preserve key, keys will help to find decimal place
    $numberArrRev=array_reverse($numberArr);
   
    //find first occurrence of non number character, that will be a decimal
place
    //store $key into variable $decPointIsHere
    foreach ($numberArrRev as $key => $value) {
        if(!is_numeric($value)){
            if($decPointIsHere==""){
                $decPointIsHere=$key;
            }           
        }
    }
   
    //decimal comma or whatever it is replace with dot
    //$decPointIsHere is the key of the element that will contain decimal
separator dot
    if($decPointIsHere!=""){
        $numberArrRev[$decPointIsHere]=".";
    }
   
    //again check through array for non numerical characters but skipping
allready processed keys
    //if is not number remove from array
   
    foreach ($numberArrRev as $key => $value) {
        if(!is_numeric($value) && $key>$decPointIsHere){
            unset($numberArrRev[$key]);           
        }
    }
   
    //reverse back, at the start reversed array $numberArrRev to $numberArr
    $numberArr=array_reverse($numberArrRev);   
   
    //create string from array
    $numberClean=implode("",$numberArr);
       
    // apply php number_format function
    return number_format($numberClean,$decPlaces,$decSep,$thouSep);
   
}

echo format_price("1 225 552, 55",2,',',' ')."<br>";
echo format_price("1.225.552, 55",2,',',' ')."<br>";
echo format_price("1'225'552. 55",2,',',' ')."<br>";
echo format_price("1225552.55",2,',',' ')."<br>";
?>
all results are: 1 225 552,55
===============================================================================

Needed an easy way to format account number with leading zeros, e.g.
0-001-231-237

<?php
$accno = '0001231237';
$tmp = number_format('1'.$accno, 0, '-','-');
echo substr($tmp, 1);
?>
===============================================================================

A simple funtion to format american dollars.

<?php
function formatMoney($money) {
    if($money<1) {
        $money='¢'.$money*100;
    }
    else {
        $dollars=intval($money);
        $cents=$money-$dollars;
        $cents=$cents*100;
        $money='$'.$dollars.' and ¢'.$cents;
    }
    return $money;
}
echo formatmoney('52.342');
?>
This will output: "   $52 and ¢34.2  ".
===============================================================================

What do you do if some of your numbers have decimal places, and some don't? 
You can switch between functions, but if you're building it in a loop, that's
not a good solution.  Instead, we have the same as below, with a slight change:

function number_format_unlimited_precision($number,$decimal = '.'){
    $broken_number = explode($decimal,$number);
    if($broken_number[1]==0){
        return number_format($broken_number[0]);
    }else{
        return number_format($broken_number[0]).$decimal.$broken_number[1];
    };
};
===============================================================================

Sometimes, I'm sure, you guys are looking for a way to do the exact opposite of
this function: convert a comma-filled number back to normal decimal.
Here's a quick code that popped into my head today:

<?php
$mynumstr = "100,000,000.75";
$mynum = doubleval(str_replace(",","",$mynumstr));
?>

This is especially useful when validating user input. Some people like to
include comma's with their numbers.
Some also like to include the dollar-sign when entering prices. Here's a
modification:

<?php
$mynumstr = '$100,000,000.25';
$arr1 = array(',','$');
$arr2 = array('','');
$mynum = doubleval(str_replace($arr1,$arr2,$mynumstr));
//The arrays had to be defined in a
//  variable to shorten statement.
?>

Okay, that takes care of it, I use the PHP4 array compatibility update to
remove several characters.
Don't forget to either use single-quotes or escape the dollar-sign!

~Cody G.
===============================================================================

As many people state the number_format function will round. Now if you're like
me and you don't want stuff to round (and the functions below do not work for
you) you can try a little regex:

<?php

function convert_size_human($size){
    $unit=array('','KB','MB','GB','TB','PB');
    $byte_size = $size/pow(1024,($i=floor(log($size,1024))));

    if(is_really_int($byte_size)){
        return $byte_size.' '.$unit[$i];
    }else{
        preg_match('/^[0-9]+\.[0-9]{2}/', $byte_size, $matches);
        return $matches[0].' '.$unit[$i];
    }
}

?>

The regex used when the number is not an int ensures that 3.99887 GB comes out
as 3.99 GB instead of 4GB as it does from number_format or the functions below.
===============================================================================

Remember that number_format returns a string, so you shouldn't run a
number_format on a variable that's already a product of number_format (it will
only take the first token of the string)...

eg. echo number_format("123,456.00", 2);
produces: 123.00
===============================================================================

Hey Guys, dont know if this is the best way but it worked for me as i faced a
problem where I had to split any large number > then 10K into into to exact
split amounts.. so i wrote this this to do the trick.. hope it helps some one
out there!

<?php
function divide22($num)
{
  $valone = intval($num / 2);
  $valtwo = $valone;
  if (($num % 2) > 0) $valtwo++;
  return array($valone, $valtwo);
}
function split2vals($num,$split_amount)
{ 
  $store=array();
  $times = round(($num/$split_amount));
  $amount= $num/$times;  
  for($i=0;$i<$times;$i++)
  {
     $store[]=round($amount);
  }
  foreach($store as $index=>$value)
  {
    if($value>$split_amount)
    {
       $get_splits=divide22($value);
       //unset the split
       unset($store[$index]);
       $store[]=$get_splits[0];
       $store[]=$get_splits[1];
    }
  }
  $sum=array_sum($store);

  if($sum > $num){
    $sub=$sum-$num;
      $end=end($store);
    array_pop($store);
    $store[]=$end-$sub;
  }
  if($sum < $num){
    $store[]=($num-$sum); 
  }
  return $store;
}

//USAGE

$check_amount=50567.83;
echo 'Input Split = '.$check_amount.'<br><br>';
$store=split2vals($check_amount,10000);
print_r($store);
$sum=array_sum($store);
echo '<br><br>Should Be Exact ='. $sum;
exit();
?>
===============================================================================

if you want &nbsp; as a separator and use windows charset this piece of code
may help:

<?php
$number=number_format($number,2,'.',chr(0xA0));
?>
===============================================================================

You could add padding zeros like this:

<?
$number="129";
$number=sprintf("%08d",$number);
?>
===============================================================================

number_format($number,$precision,".","") should be used when setting the value
of form elements because if you read the number into a double upon submission,
it will only store digits before the comma.
<p>
ie. <input type="text" value="<?php echo(number_format(2.5343,2,".","")">
===============================================================================

Since number_format returns a string, you must perform all mathmatical
functions on the number before applying number_format:

<?
$total = 100;
$total = number_format($total, 2);
$shipping = 20.00;
$grand_total = $total + $shipping;

echo number_format($grand_total, 2);

/* The above will return 21.00 because $total is now a string, and no longer an
integer or float. Since a string will have a value of 1,  the addition of the
two will return 21 and not 120. */

$total = 100;
$shipping = 20.00;
$grand_total = $total + $shipping;

echo number_format($grand_total, 2);

/* This works, and will return 120.00 as intended */

?>
===============================================================================

The function rlerne posted does not work well in many cases:

<?php
function number_format_clean($number, $precision = 0, $dec_point = '.', 
$thousands_sep = ',') {
    return trim(number_format($number, $precision, $dec_point ,$thousands_sep),
'0' . $dec_point);
}
?>

Fail examples:

<?php
number_format_clean(0.1, 2); // returns "1"
number_format_clean(10.000001, 2); // returns "1"
?>

This one is correct:

<?php
function number_format_clean($number, $precision = 0, $dec_point = '.', 
$thousands_sep = ',') {
    return rtrim(rtrim(number_format($number, $precision, $dec_point ,
$thousands_sep), '0'), $dec_point);
}
?>
===============================================================================

This function formats an decimal number to a String.
But it does'n use an fixed count of decimals but calculates the needed count of
decimals.

<?
function formatNumber( $number, $decimals=2, $dec_point=".", $thousands_sep=
",") {
    $nachkomma = abs($in - floor($in));
    $strnachkomma = number_format($nachkomma , $decimals, ".", "");

    for ($i = 1; $i <= $decimals; $i++) {
        if (substr($strnachkomma, ($i * -1), 1) != "0") {
            break;
        }
    }
   
    return number_format($in, ($decimals - $i +1), $dec_point, $thousands_sep);
}
?>
Example:

formatNumber( 100.00 );
--> 100
formatNumber( 100.50 );
--> 100.5
formatNumber( 100.1234 );
--> 100.12
formatNumber( 100.12, 4 );
--> 100.12
formatNumber( 100.12345, 4 );
--> 100.1234
===============================================================================

People here in India are more used to counting money in Lakhs & Crores .. so
here is the code for formatting the commas with thousands for the first time
and then with hundred multiples from there after.

Ex: 1234567  ->  12,34,567

<?php

function makecomma($input)
{
    // This function is written by some anonymous person - I got it from Google
    if(strlen($input)<=2)
    { return $input; }
    $length=substr($input,0,strlen($input)-2);
    $formatted_input = makecomma($length).",".substr($input,-2);
    return $formatted_input;
}

function formatInIndianStyle($num){
    // This is my function
    $pos = strpos((string)$num, ".");
    if ($pos === false) { $decimalpart="00";}
    else { $decimalpart= substr($num, $pos+1, 2); $num = substr($num,0,$pos); }

    if(strlen($num)>3 & strlen($num) <= 12){
                $last3digits = substr($num, -3 );
                $numexceptlastdigits = substr($num, 0, -3 );
                $formatted = makecomma($numexceptlastdigits);
                $stringtoreturn = $formatted.",".$last3digits.".".$decimalpart 
;
    }elseif(strlen($num)<=3){
                $stringtoreturn = $num.".".$decimalpart ;
    }elseif(strlen($num)>12){
                $stringtoreturn = number_format($num, 2);
    }

    if(substr($stringtoreturn,0,2)=="-,"){$stringtoreturn = "-".substr(
$stringtoreturn,2 );}

    return $stringtoreturn;
}

$num = 1234567;
echo  formatInIndianStyle($num);

?>
===============================================================================

The following function converts a string into Float or Integer while taking the
given or locale number format into account.

<?php

    function strtonumber( $str, $dec_point=null, $thousands_sep=null )
    {
        if( is_null($dec_point) || is_null($thousands_sep) ) {
            $locale = localeconv();
            if( is_null($dec_point) ) {
                $dec_point = $locale['decimal_point'];
            }
            if( is_null($thousands_sep) ) {
                $thousands_sep = $locale['thousands_sep'];
            }
        }
        $number = (float) str_replace($dec_point, '.', str_replace(
$thousands_sep, '', $str));
        if( $number == (int) $number ) {
            return (int) $number;
        } else {
            return $number;
        }
    }

?>
===============================================================================

If you want to use nbsp as decimal/thousand delimiter with UTF-8 you have to
replace the whitespace after using number_format:

<?php
$number = number_format(1000, 0, ".", " "); // normal space
echo str_replace(" ", utf8_encode("\xA0"), $number);
// or
echo str_replace(" ", html_entity_decode("&nbsp;", ENT_COMPAT, "UTF-8"), 
$number);
?>
===============================================================================

this also works as well

$number = "29346.99"; //value
echo "$" .number_format($number, 2, '.', ',');

produces $29,346.99
===============================================================================

One-liner to add filesizes and print a human readable result:

seq 1 500 | php -r '$t=0;while(1){$a=rtrim(fgets(STDIN));if(feof(STDIN))break;
$t+=$a+0;} $p=floor(log($t, 1024)); printf("%.0f%s\n", $t/pow(1024,$p),substr
("BKMGT",$p,1));'

-- Ren
===============================================================================

To address the problems number_format has when dealing with big numbers I've
created my own Number_Format method, it acts the same way as number_format and
takes the same arguments but deals with numbers as strings solving the problems
above referred.

(The other methods are available at http://www.alixaxel.com/wordpress/2007/05/
19/php-math-library/)

function Number_Format($number, $decimal_precision = 0, $decimals_separator =
'.', $thousands_separator = ',')
{
if ($this->Is_Negative($number))
{
    $negative = true;

    $number = str_replace('-', '', $number);
}

$number = explode('.', str_replace(' ', '', $number));

$number[0] = str_split(strrev($number[0]), 3);

$total_segments = count($number[0]);

for ($i = 0; $i < $total_segments; $i++)
{
    $number[0][$i] = strrev($number[0][$i]);
}

$number[0] = implode($thousands_separator, array_reverse($number[0]));

if ($negative === true)
{
    $number[0] = '-' . $number[0];
}

if (!empty($number[1]))
{
    $number[1] = $this->Round($number[1], $decimal_precision);
}

$number = implode($decimals_separator, $number);

return $number;
}

I hope this is useful for someone!
