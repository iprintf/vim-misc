
switch

(PHP 4, PHP 5, PHP 7)

switch 语句类似于具有同一个表达式的一系列 if 语句。很多场合下需要把同一个变量（
或表达式）与很多不同的值比较，并根据它等于哪个值来执行不同的代码。这正是 switch
语句的用途。

    Note: 注意和其它语言不同，continue 语句作用到 switch 上的作用类似于 break。
    如果在循环中有一个 switch 并希望 continue 到外层循环中的下一轮循环，用
    continue 2。

    Note:

    注意 switch/case 作的是松散比较。

下面两个例子使用两种不同方法实现同样的事，一个用一系列的 if 和 elseif 语句，另
一个用 switch 语句：

Example #1 switch 结构

<?php
if ($i == 0) {
    echo "i equals 0";
} elseif ($i == 1) {
    echo "i equals 1";
} elseif ($i == 2) {
    echo "i equals 2";
}

switch ($i) {
    case 0:
        echo "i equals 0";
        break;
    case 1:
        echo "i equals 1";
        break;
    case 2:
        echo "i equals 2";
        break;
}
?>

Example #2 switch 结构可以用字符串

<?php
switch ($i) {
case "apple":
    echo "i is apple";
    break;
case "bar":
    echo "i is bar";
    break;
case "cake":
    echo "i is cake";
    break;
}
?>

为避免错误，理解 switch 是怎样执行的非常重要。switch 语句一行接一行地执行（实际
上是语句接语句）。开始时没有代码被执行。仅当一个 case 语句中的值和 switch 表达
式的值匹配时 PHP 才开始执行语句，直到 switch 的程序段结束或者遇到第一个 break
语句为止。如果不在 case 的语句段最后写上 break 的话，PHP 将继续执行下一个 case
中的语句段。例如：
<?php
switch ($i) {
    case 0:
        echo "i equals 0";
    case 1:
        echo "i equals 1";
    case 2:
        echo "i equals 2";
}
?>

这里如果 $i 等于 0，PHP 将执行所有的 echo 语句！如果 $i 等于 1，PHP 将执行后面
两条 echo 语句。只有当 $i 等于 2 时，才会得到“预期”的结果——只显示“i equals 2”。
所以，别忘了 break 语句就很重要（即使在某些情况下故意想避免提供它们时）。

在 switch 语句中条件只求值一次并用来和每个 case 语句比较。在 elseif 语句中条件
会再次求值。如果条件比一个简单的比较要复杂得多或者在一个很多次的循环中，那么用
switch 语句可能会快一些。

在一个 case 中的语句也可以为空，这样只不过将控制转移到了下一个 case 中的语句。
<?php
switch ($i) {
    case 0:
    case 1:
    case 2:
        echo "i is less than 3 but not negative";
        break;
    case 3:
        echo "i is 3";
}
?>

一个 case 的特例是 default。它匹配了任何和其它 case 都不匹配的情况。例如：
<?php
switch ($i) {
    case 0:
        echo "i equals 0";
        break;
    case 1:
        echo "i equals 1";
        break;
    case 2:
        echo "i equals 2";
        break;
    default:
        echo "i is not equal to 0, 1 or 2";
}
?>

case 表达式可以是任何求值为简单类型的表达式，即整型或浮点数以及字符串。不能用数
组或对象，除非它们被解除引用成为简单类型。

switch 支持替代语法的流程控制。更多信息见流程控制的替代语法一节。
<?php
switch ($i):
    case 0:
        echo "i equals 0";
        break;
    case 1:
        echo "i equals 1";
        break;
    case 2:
        echo "i equals 2";
        break;
    default:
        echo "i is not equal to 0, 1 or 2";
endswitch;
?>

允许使用分号代替 case 语句后的冒号，例如：
<?php
switch($beer)
{
    case 'tuborg';
    case 'carlsberg';
    case 'heineken';
        echo 'Good choice';
    break;
    default;
        echo 'Please make a new selection...';
    break;
}
?>


User Contributed Notes 60 notes

===============================================================================

This is listed in the documentation above, but it's a bit tucked away between
the paragraphs. The difference between a series of if statements and the switch
statement is that the expression you're comparing with, is evaluated only once
in a switch statement. I think this fact needs a little bit more attention, so
here's an example:

<?php
$a = 0;

if(++$a == 3) echo 3;
elseif(++$a == 2) echo 2;
elseif(++$a == 1) echo 1;
else echo "No match!";

// Outputs: 2

$a = 0;

switch(++$a) {
    case 3: echo 3; break;
    case 2: echo 2; break;
    case 1: echo 1; break;
    default: echo "No match!"; break;
}

// Outputs: 1
?>

It is therefore perfectly safe to do:

<?php
switch(winNobelPrizeStartingFromBirth()) {
case "peace": echo "You won the Nobel Peace Prize!"; break;
case "physics": echo "You won the Nobel Prize in Physics!"; break;
case "chemistry": echo "You won the Nobel Prize in Chemistry!"; break;
case "medicine": echo "You won the Nobel Prize in Medicine!"; break;
case "literature": echo "You won the Nobel Prize in Literature!"; break;
default: echo "You bought a rusty iron medal from a shady guy who insists it's
a Nobel Prize..."; break;
}
?>

without having to worry about the function being re-evaluated for every case.
There's no need to preemptively save the result in a variable either.
===============================================================================

Attention if you have mixed types of value in one switch statemet it can make
you some trouble

<?php

$string="2string";

switch($string)
{
    case 1:
        echo "this is 1";
        break;
    case 2:
        echo "this is 2";
        break;
    case '2string':
        echo "this is a string";
        break;
}

?>

The swich-statement will halt on 'case 2'

Answer: this is 2
===============================================================================

Please note that PHP won't throw any error/warning if your `switch` utilizes
more than one `default` - in such case it will just jump to the first one.

Also note that you (for unknown reason for me) are allowed to use semicolons `;
` along colon `:` for `case` and `default` entries:

<?php

switch($foo) {
   case 0:    // colon
        ...
   break;

   case 1;    // semicolon is fine
        ...
   break;
}
===============================================================================

Just a trick I have picked up:

If you need to evaluate several variables to find the first one with an actual
value, TRUE for instance. You can do it this was.

There is probably a better way but it has worked out well for me.

switch (true) {

  case (X != 1):

  case (Y != 1):

  default:
}
===============================================================================

In reply to lko at netuse dot de

Just so others know whom may not, that's because PHP does automatic type
conversion if a string is evaluated as an integer (it sees the 2 in '2string'
so when compared like if ('2string' == 2), PHP sees if (2 == 2) ).

I just tested it, but if you go:

<?php

$string="2string";

switch($string)
{
    case (string) 1:
        echo "this is 1";
        break;
    case (string) 2:
        echo "this is 2";
        break;
    case '2string':
        echo "this is a string";
        break;
}

?>

The output will be "this is a string" and if you change $string to "2" it will
again be "this is 2".

Just in case that may help anyone who may run into that problem.
===============================================================================

Something not mentioned in the documentation itself, and only touched on
momentarily in these notes, is that the default: case need not be the last
clause in the switch.
<?php
for($i=0; $i<8; ++$i)
{
    echo $i,"\t";
    switch($i)
    {
    case 1: echo "One"; break;
    case 2:
    default: echo "Thingy"; break;
    case 3:
    case 4: echo "Three or Four"; break;
    case 5: echo "Five"; break;
    }
    echo "\n";
}
?>
Outputs what you'd expect, namely
0       Thingy
1       One
2       Thingy
3       Three or Four
4       Three or Four
5       Five
6       Thingy
7       Thingy
with case 2 and the default both producing the same result ("Thingy"); strictly
speaking, the case 2 clause is completely empty and control just falls straight
through. The same result could have been achieved with
<?php
switch($i)
{
    case 1: echo "One"; break;
    case 3:
    case 4: echo "Three or Four"; break;
    case 5: echo "Five"; break;
    default: echo "Thingy"; break;
}
?>
But if "case 2" represented a fairly common case (other than "everything
else"), then it would be better to declare it explicitly, not only because it
saves time by not having to test EVERY other case first  (in the current
example, PHP finds 'case 2' in the first switch in two tests, but in the second
switch it has to make four tests before giving up and going with the default)
but also because someone (perhaps yourself in a few months' time) will be
reading the code and expecting to see it handled. Listing it explicitly aids
comprehension
===============================================================================

Rewriting the function (to be three times faster) provided by [stever at
ashomecare dot com 07-Sep-2007 09:11] and demonstrating points that others have
made:

<?php
function getChineseZodiac($year){

    switch ($year % 12) :
        case  0: return 'Monkey';  // Years 0, 12, 1200, 2004...
        case  1: return 'Rooster';
        case  2: return 'Dog';
        case  3: return 'Boar';
        case  4: return 'Rat';
        case  5: return 'Ox';
        case  6: return 'Tiger';
        case  7: return 'Rabit';
        case  8: return 'Dragon';
        case  9: return 'Snake';
        case 10: return 'Horse';
        case 11: return 'Lamb';
    endswitch;
}

echo getChineseZodiac(2016);
?>
===============================================================================

Something fairly simple (and maybe obvious) that I didn't see mentioned is that
the default case WILL be executed even if the switched variable does not exist
or is undefined.

For example:

<?php

$a = "abc";
$b = "def";

switch($c){
    case "a":
        echo "a";
        break;
    case "b":
        echo "b";
        break;
    default:
        echo "default";
        break;
}

?>

Will output: default

Even though $c was never declared or defined, the default case will still be
executed rather than PHP throwing an error.
===============================================================================

Be careful if distinguishing between NULL and (int)0.  As implied in the above
documentation, the case statements are equivalent to the '==' operator, not the
'===' operator, so the following code did not work as i expected:

<?php
$mixed = 0;
switch($mixed){
   case NULL: echo "NULL";  break;
   case 0: echo "zero";  break;
   default: echo "other"; break;
}
?>

Instead, I may use a chain of else-ifs.  (On this page, kriek at jonkreik dot
com states that "in most cases [a switch statement] is 15% faster [than an
else-if chain]" but jemore at m6net dotdot fr claims that when using ===, if/
elseif/elseif can be 2 times faster than a switch().)

Alternatively, if i prefer the appearance of the switch() statement I may use a
trick like the one nospam at please dot com presents:

<?php
$mixed = 0;
switch(TRUE){
   case (NULL===$mixed): //blah break;
   case (0   ===$mixed): //etc. break;
}
?>

code till dawn! mark meves!
===============================================================================

"loose comparison" means that switch won't check the type.
switch will only compare values:
<?php
if('a string' == 0) echo 'a string is 0' . PHP_EOL;
if('a string' === 0) echo 'but you will never see this' . PHP_EOL;
switch(0){
    case 'a string': echo 'a string' . PHP_EOL;
    case 'another string': echo 'another string' . PHP_EOL;
}

if('a string' == true) echo 'a string is TRUE' . PHP_EOL;
if('a string' === true) echo 'but you will never see this' . PHP_EOL;
switch(true){
    case 'a string': echo 'a string' . PHP_EOL;
    case 'another string': echo 'another string' . PHP_EOL;
}
?>

will output:
a string is 0
a string
another string
a string is TRUE
a string
another string
===============================================================================

Not sure if this has been posted or not, but I found the switch statement
useful for finding ranges of data.

This script creates web 2.0 style links in different font sizes (popular on
blogs) using a randomizer and switch statement. I used links from within a
database for a mod I made for a Simple Machines forums, but this example uses
arrays for links if you wanted to add your own custom links:
<?php
// Create set of links
$link = array();
$link[] = '<a href="whatever.html">page 1</a>';
$link[] = '<a href="whatever.html">page 2</a>';
$link[] = '<a href="whatever.html">page 3</a>';
$link[] = '<a href="whatever.html">page 4</a>';
$link[] = '<a href="whatever.html">page 5</a>';
$link[] = '<a href="whatever.html">page 6</a>';
$link[] = '<a href="whatever.html">page 7</a>';
$link[] = '<a href="whatever.html">page 8</a>';

// Create loop to display links
for($i = 0; $i < count($link); ++$i)
{
    // Create randomizer
    // Use switch statement to find font size
    $randomizer = rand(1,50);
    switch($randomizer)
    {
    case ($randomizer <= 20):
    $font_size = "11";
    break;

    case ($randomizer <= 30):
    $font_size = "16";
    break;

    case ($randomizer <= 40):
    $font_size = "18";
    break;

    case ($randomizer <= 50):
    $font_size = "20";
    break;
    }

    // Display the link
    echo '<span style="font-size: ' .$font_size. ';">' .$link[$i]. '</span>&
nbsp;&nbsp;';

// Loop the next link
}
?>

Using this type of range randomizer is useful for game development and it can
be useful on the web too, for things where you don't want to use a randomizer
just for things like (1-5) where you wanted a more then likely result for one
thing over another. The switch statement saves from writing spaghetti code if
statements.
===============================================================================

<?php
    /* script 1  */
    $foo = "not a number";
    switch(false)
    {
        case "1":    {    $foo = "1";    break;    }
        case "2":    {    $foo = "2";    break;    }
        default:    {    $foo = "0";    }
    }
   
    echo $foo;    // will produce "not a number"
   
    /* script 2  */
    $foo = "not a number";
    $arr = array("not a number"); // 1 element only !
    switch($arr[1])    // element $foo[1] doesn't defined
    {
        case "1":    {    $foo = "1";    break;    }
        case "2":    {    $foo = "2";    break;    }
        default:    {    $foo = "0";    }
    }
   
    echo $foo;    // will produce "not a number" ( not 0 ! )
   
    /* script 3  */
    $foo = "not a number";
    $arr = array("not a number"); // 1 element only !
    switch($arr[1]?$arr[1]:"1")    // element $foo[1] doesn't defined
    {
        case "1":    {    $foo = "1";    break;    }
        case "2":    {    $foo = "2";    break;    }
        default:    {    $foo = "0";    }
    }
   
    echo $foo;   
    // will produce :
    // 1 if $arr[1] isn't set
    // 1 if $arr[1]=1
    // 2 if $arr[1]=2
    // 0 if none of above
?>
===============================================================================

Be careful if you have mixed types of values in the switch statement.
Explicitly cast your variables where possible to avoid mismatch:

<?php
$var = 0;

// This match case #1
// switch ( $var )

// This works as expected
switch ( (string)$var )
{
  case "0string":
    echo "0string match";
    break;
}
?>
===============================================================================

As follow-up to ben dot lancaster at holler dot co dot uk's post:

'continue' ends the switch, not the case, just as it would with any other flow
control. Think of it as putting the execution pointer right before the ending
accolade (that is, the }) because that is essentially what happens. In the case
of a for loop, this would cause the iteration clause to execute, and if
applicable, the loop to begin again. However, switches do not loop, which is
why (as noted above, in the manual!) a continue statement essentially acts as a
break when within a switch.
===============================================================================

Just a word of warning about using switch don't try and compare variables that
contain numbers with strings like so:

<?php
$i=0;

switch($i)
{
    case 'TEST': print "Test";break;
    case 0: print "0";break;
}
?>

The output will be: Test and not 0.
===============================================================================

If you want to avoid numeric compare for numeric strings in switch statement,
try prepending something non-numeric.

e.g.
<?php
$val='2';
switch($val){
case '2.0' : echo '2.0!??'; break;
case '2' : echo '2.'; break;
}
?>
echoes '2.0!??' ; while prepended version
<?php
$val='2';
switch('#' . $val){
case '#2.0' : echo '2.0!??'; break;
case '#2' : echo '2.'; break;
}
?>
echoes '2.'.
===============================================================================

Switch usage for make some actions with all of cases

<?php
$out = ' ';
for ($i=1;$i<10:$i++) {
   switch ($i) {
      case true: $out .= 'test_';
      case 1:
      case 2:
      case 3: $out .= $i;
      default: $out .= ' ';
   }
}
echo $out;
?>

That sample out:

" test_1 test_2 test_3 "
===============================================================================

Haven't seen it mentioned here, but at least in my version (PHP 5.2.5) and I'm
sure all of PHP 5, the switch statement is a great way to check type safe
enumerates that are otherwise missing in the PHP language. Example:

<?php

class WannabeEnum {
    /**
     * @var WannabeEnum
     */
    public static $FOO;
    /**
     * @var WannabeEnum
     */
    public static $BAR;
    /**
     * @var WannabeEnum
     */
    public static $FOOBAR;
    private $_ordinal;
    public function __construct($ordinal) {
        $this->_ordinal = $ordinal;
    }
}
WannabeEnum::$FOO = new WannabeEnum(1);
WannabeEnum::$BAR = new WannabeEnum(2);
WannabeEnum::$FOOBAR = new WannabeEnum(3);

function testSwitch(WannabeEnum $wannabeEnum) {
    switch($wannabeEnum) {
        case WannabeEnum::$FOO:
            echo('Foo!' . PHP_EOL);
            break;
        case WannabeEnum::$BAR:
            echo('Bar!' . PHP_EOL);
            break;
        default:
            echo('Default!' . PHP_EOL);
    }   
}
testSwitch(WannabeEnum::$FOO);
testSwitch(WannabeEnum::$FOOBAR);
?>

Outputs:

Foo!
Default!

Don't forget it uses loose comparisons!
===============================================================================

In reply to earlier comment, "switch"- I found this to be one of the best ways
to interpret 'actions'. Simply create a new instance of Handler_action before
including any content source files. This is a highly stripped version of the
class.

The real one I created handles (and secures) input for $_GET and $_POST,
creates a 'permission' array that only allows certain actions to be called by
non-admins, and creates handy little diagnostic messages that can be displayed
upon redirecting.

On that note, the beauty in this class really shines in the simple redirect.
You wont be left with ugly URLs like, "http://www.domain.com/path/to/
script.php?action=blah&var1=123". Rather, you will be left with something like
"http://www.domain.com/path/to/script.php"- helps protect some of the site by
not showing any vulnerabilities in URLs.

Also, this class keeps all actions organized neatly by directly passing $_GET
vars to the actions through function parameters.

<?php
  class Handler_action {
    function __construct( ){
      //Add code here to secure attacks through $_GET or use $_POST
      $action = $_GET["action"];
 
      //$actions_index conventions:
      //'action_name' => array( 'arg1', 'arg2', 'etc', ['/redirect/to/path' |
NULL ] )
      $actions_index = array(
        'create' => array( $_GET['newVar1'], $_GET['newVar2'], '/home.php' ),
        'edit' => array( $_GET['id'], $_GET['otherVar'], '/home.php' ),
        'delete' => array( $_GET['id'], '/other_script.php' )
      );
             
      if( $action && array_key_exists( $action, $actions_index ) ){
        $redirect_path = array_pop( $actions_index[$action] );
        call_user_func_array( array( &$this, $action ), $actions_index[$action]
);
        if( $redirect_path )
          header( "Location: http://www.domain.com{$redirect_path}" );
      }
    }

    //being defining actions now
    function create( $new_var1, $new_var2 ){
 
      //code...
 
    }
    function edit( $id, $other_var ){
 
      //code...
 
    }
    function delete( $id ){
 
      //code...
 
    }
  }
?>
===============================================================================

Declaring a variable (actually an array) as static w/in a switch{} spun my wool
for a while:
don't:
<?
function ss() {
    switch ("bug") {
        case "bug" :
           static $test = "xyz";
           break;
        default :
           static $test = "abc";
    }
echo $test;
}
ss(); //abc
?>
do:
<?
function tt() {
    static $test;
    switch ("fix") {
        case "fix" :
           $test = "xyz";
           break;
        default :
           $test = "abc";
    }
echo $test;
}
tt(); // xyz
?>
===============================================================================

Did you know that switch() and case() can also accomodate things like basic
math calculations and counter incrementing? They do. In this example, I use a
switch statement (which is inside of a while loop) to alternate the background
color of a table row. It gives me a cool spool-printer-paper effect.

<?php
$rows_per_color = 5;  // change bgcolor every 5 rows
switch($ctr++) {
    case 0:
        $bgcolor = "#ffffff";
        break;
    case ($rows_per_color):
        $bgcolor = "#ff0000";
        break;               
    case ($rows_per_color * 2):
        $bgcolor = "#ffffff";
        $ctr = 1;
        break;       
}
?>

As you can see, I increment $ctr by 1 in the switch() itself, and the final
case() does a simple calculation. Simple, but powerful. [Remember, the above
example is inside of a while() loop... each time it iterates, switch increments
$ctr.]
===============================================================================

Remember, that you also could use functions in a switch.
For example, if you need to use regular expressions in a switch:

<?php
$browserName = 'mozilla';
switch ($browserName) {
  case 'opera':
    echo 'opera';
  break;
  case (preg_match("/Mozilla( Firebird)?|phoenix/i", $browserName)?$browserName
:!$browserName):
    echo "Mozilla or Mozilla Firebird";
  break;
  case 'konqueror':
    echo 'Konqueror';
  break;
  default:
    echo 'Default';
  break;
}
?>

or you could just use a regular expression for everything:

<?php
$uri = 'http://www.example.com';
switch (true) {
  case preg_match("/$http(s)?/i", $uri, $matches):
    echo $uri . ' is an http/https uri...';
  break;
  case preg_match("/$ftp(s)?/i", $uri, $matches):
    echo $uri . ' is an ftp/ftps uri...';
  break;
  default:
    echo 'default';
  break;
}
?>
===============================================================================

Be very careful when you're using text strings as cases. If the variable
supplied to switch() is an integer, the cases would be converted to integer
before the comparison is made (usually to zero). The following snippet prints
"hello".

<?php
$a = 0;
switch($a) {
case 'Hello': echo "Hello";
break;
}
?>
===============================================================================

Again, just to re-iterate, if you supply 0 as the switched element, only the
first statement will run if the comparison is with text.

<?php

$in = array('first',0,"second");

foreach ($in as $a){
  switch ($a){
    case "first": print "first<br>"; break;
    case "second": print "second<br>"; break;
  }
}

?>

This is annoying if you're using an array where you've got key's which could be
text or numbers, so I'm using the suggested idea of:

<?php

switch (true){
  case ($a==="first"): print "first<br>"; break;
  case ($a==="second"): print "second<br>"; break;
}

?>

The reason for this as mentioned on http://uk3.php.net/ternary is that: "If you
compare an integer with a string, the string is converted to a number. If you
compare two numerical strings, they are compared as integers. These rules also
apply to the switch statement." Effectively it's saying if ($a=="first") which
becomes does ($a (0) == 0) which is yes.

In my example this mean't a date had a regular expression of an email applied
to it which didnt help!
===============================================================================

To get the conditional statement to work for the above example use this:

<?php
$chr = substr($a,$i,1);
switch (TRUE) {

case $chr == " " || $chr == " " || $chr == " " || $chr == " ":
$a = str_replace(substr($a,$i,1),"a",$a);
break;

case $chr == " " || $chr == " " || $chr == " ":
$a = str_replace(substr($a,$i,1),"e",$a);
break;
?>

}
===============================================================================

Example of default NOT included as the last item

<?php
switch(5) {
  case 1:
    echo "1";
    break;
  case 2:
  default:
    echo "2, default";
    break;
  case 3;
    echo "3";
    break;
}
?>

Outputs '2,default'

very useful if you want your cases to be presented in a logical order in the
code (as in, not saying case 1, case 3, case 2/default) and your cases are very
long so you do not want to repeat the entire case code at the bottom for the
default

Hamy
===============================================================================

Regarding [php_net at mcdragonsoftware dot com 17-Jun-2011 09:53]; the elegant
function and syntax provided for an "inline switch" statement is more readable
and about 25% faster than this alternative (that uses existing builtin
functions), which produces the same result:

<?php echo array_pop(array_slice(array( 'rock', 'paper', 'scissors' ), --$roll,
1)); ?>
===============================================================================

Sometimes you need to execute a common piece of code for several cases, and
then execute some special code for each of those cases in particular. You'd
then be tempted to duplicate "case" entries, like so:

<?php

$health = 50;
$prevActionType = "none";

$action = "kill";

switch($action) {

case "heal":
  $prevActionType = "good";
  $health += 10;
  break;

case "hurt":
case "kill":
  $prevActionType = "bad";
  break;

case "hurt":
  $health -= 10;
  break;

case "kill":
  $health = 0;
  break;

}

?>

That won't work as intended -- you'll enter at the first case that matches
($prevActionType = "bad") and then exit the switch altogether.
===============================================================================

In response to the entry by "kriek at jonkriek dot com", I think you would
probably be better of doing this:
<?php
    // ensure $_GET['go'] is set, an integer, and not 0
    // then, set nav number; default to 1
    $nav = ( isset($_GET['go']) && (intval($_GET['go']) == $_GET['go']) && 
$_GET['go'] ) ?
        intval($_GET['go']) : 1;

    // format navigation string and include
    include(sprintf("Page%02d.php",$nav));   
?>

... as oppposed to the switch setup you recommended, which is limited to the
number of cases you specify...
===============================================================================

It's easy to abuse the switch syntax to do some very useful things. As this
example will show, the possibilities can go beyond even Duff's Device-style
craziness (not that this example is nearly as clever as Duff's Device, but it
demonstrates how you can do certain things other than simply the increment/
decrement/assignment that's possible in C).

Fundamentally, this works mostly due to the fact that, from the point of view
of the assembler/interpreter, a switch block is hardly any different from a
bunch of GOTO labels and  if()  evaluations. But, like an  if() evaluation, the
line of a case: statement is evaluated as an expression. So, in this case, we
can perform an assignment and match the result of that assignment, because the
return value of an assignment is the data that was assigned (and not the value
of the variable it was assigned to, as you might expect).

So far, this is not actually amazing, even if it is a bit unintuitive. From a
language point-of-view, it would be the same as an  if($var = "string") 
statement which is using an assignment (=) rather than a comparison (==)
operator. When you look at the pre-processing optimization, because a normal
assignment of $var = "string" will always equal "string", it makes sense to
have the result of that expression simply be equal to the right side of the
expression (the right side is used rather than the left to let the assembler/
interpreter work faster, on account of how they traditionally simply change the
memory location for the assigned variable rather than copy the memory around
unnecessarily).

Where this becomes more interesting is where, in PHP, you have language
constructs that behave like functions but are used like statements. An  $array
[] = "string"  expression is actually a language construct that just happens to
behave a lot like a function, but you use it in the same way that you use an
assignment expression, and like an expression, it always evaluates to the right
side of the expression; in this case,  "string"  and not  array() .

The assembler/interpreter can't use the right side of the expression as a
shortcut for the result of a function, so you can't use functions in this way
in a case statement. You also can't get around this limit on calling functions
from the case line by using variable functions, because they are used in the
same way as functions.

But imagine what you could do with other language constructs, like eval() or
include() !

Consider the following:

<?php
function flavor($type = null)
{
    switch ($type) {
        /* Note the isolation of break; statements and the fact that default:
is at the top */
        default:
            $type = null;
        case $array[] = "chocolate":
            if ($type != null) {
                $array = array($type);
                break;
            }
        case $array[] = "strawberry":
            if ($type != null) {
                $array = array($type);
                break;
            }
        case $array[] = "vanilla":
            if ($type != null) {
                $array = array($type);
                break;
            }
    }
    if ( (count($array) != 1) ) {
        return "Flavors available: " . implode(", ", $array);
    } else {
        return "Flavor selected: " . implode(", ", $array);
    }
}

echo flavor() . "<br>";
/* Flavors available: chocolate, strawberry, vanilla */

echo flavor("banana") . "<br>";
/* Flavors available: chocolate, strawberry, vanilla */

echo flavor("chocolate") . "<br>";
/* Flavor selected: chocolate */
?>

What makes this example useful is that you don't need a variable somewhere that
contains the available options (even within the function itself), so to support
new options, you only ever have to change the code to add the new option - you
don't need to update some variable somewhere that controls whether or not it
works or whether or not people can tell that there's a new option.
===============================================================================

In answer to njones at fredesign dot com, what you're seeing is the way the
switch statement is supposed to work. The switch statement evaluates the cases,
top to bottom, until it finds the first one that matches the value being switch
()ed on. So, for example, if you had:

<?php
switch(2) {
case 1: echo "One\n"; break;
case 2: echo "Two\n"; break;
case 3: echo "Three\n"; break;
case 2: echo "Two again\n"; break;
}
?>

Only "Two" would get echoed. "Two again" would NOT get echoed, because once the
first case matches, the rest of them do NOT get evaluated. As soon as a
matching case is found, the statements starting at that case get executed until
the first break, then control flows out the bottom of the switch block.
===============================================================================

In case : ) it helps someone, I was able to clean up some hairball code by
using nested switches (didn't see it mentioned here).  Thanks to all those who
are writing examples - I love this site!

<?php
$string_match="second";
switch ($string_match) {
case "first":
case "second":
case "third":
    print "<H3>Something for all three</H3><br>";
    switch ($string_match) {
      case "first":
      print "something for first only";
      break;
      case "second":
      case "third":
      print "something for the other two";
      break;
    }
break;
default:
print "<H3>no match</H3>";
}
?>
===============================================================================

Following on from bensphpnetemail at supernaut dot org's post, it would seem
that 'continue' doesn't really continue at all. Consider the following:

<?php
$foo = 'bar';
$bar = true;

switch($foo)
{
    case 'bar':
        if($bar)
        {
            continue;
        }
        echo '$bar is false';
        break;

    case 'bar':
    case 'foo':
        echo '$bar is true, or $foo is foo';
        break;
   
    default:
        echo "You shouldnt ever get here";
        break;
}

?>

I would expect the above to output "$bar is true, or $foo is foo", but it
doesn't output anything. The continue statement acts as a break and stops
evaluating the rest of the matching cases.

Instead, you should issue a 'break' statement conditionally to achieve the
desired result.
===============================================================================

I could have used a swich for this, but I found that using the array was much
faster.

    $action = $_GET['action'];

    $pages = array
    (
      'edit'   => './edit.php',
      'search' => './search.php'
    );

    if(strlen($pages[$action]) > 0)
    {
      require $pages[$action];
    }
    else
    {
      require './default.php';
    }
===============================================================================

If you want to avoid problems with loose comparison and strings in case
statements (0 matching the first string case), you can use an explicit string
cast in the switch statement:

switch((string)$switchkey) {...}

If $switchkey is 0 then the switch statement will either jump to the 'default'
case or execute nothing at all (if there is no 'default' case present).

<?php

$switchkey = 0;

if('a string' == $switchkey) echo 'a string is 0' . PHP_EOL;
if('a string' === $switchkey) echo 'but you will never see this' . PHP_EOL;

switch($switchkey)
{
    case 'a string': echo 'switch string test without explicit cast:'.
$switchkey.' is a string (this is not what we want to see)' . PHP_EOL;break;
    case 'another string': echo 'switch string test without explicit cast: '.
$switchkey.' is another string' . PHP_EOL;break;
    default: echo 'switch string test without explicit cast: default :'.
$switchkey.' is somethign else (this is the correct choice)' . PHP_EOL;break;
}
switch((string)$switchkey)
{
    case 'a string': echo 'switch string test with explicit cast:'.$switchkey.'
is a string (this is not what we want to see)' . PHP_EOL;break;
    case 'another string': echo 'switch string test with explicit cast: '.
$switchkey.' is another string' . PHP_EOL;break;
    default: echo 'switch string test with explicit cast: default :'.$switchkey
.' is something else (this is the correct choice)' . PHP_EOL;break;
}

$switchkey = true;

if('a string' == $switchkey) echo 'a string is TRUE' . PHP_EOL;
if('a string' === $switchkey) echo 'but you will never see this' . PHP_EOL;

switch($switchkey)
{
    case 'a string': echo 'Switch boolean test without explicit cast:'.
$switchkey.' is a string (this is not what we want to see)' . PHP_EOL;break;
    case 'another string': echo 'Switch boolean test without explicit cast: '.
$switchkey.' is another string' . PHP_EOL;break;
    default : echo 'Switch boolean test : default without explicit cast: '.
$switchkey.' is something else (this is the correct choice)' . PHP_EOL;break;
}
switch((string)$switchkey)
{
    case 'a string': echo 'Switch boolean test with explicit cast:'.$switchkey.
' is a string (this is not what we want to see)' . PHP_EOL;break;
    case 'another string': echo 'Switch boolean test with explicit cast: '.
$switchkey.' is another string' . PHP_EOL;break;
    default : echo 'Switch boolean test  with explicit cast: default:s '.
$switchkey.' is something else (this is the correct choice)' . PHP_EOL;break;
}

?>

The script will output :

a string is 0
switch string test without explicit cast:0 is a string (this is not what we
want to see)
switch string test with explicit cast: default :0 is something else (this is
the correct choice)
a string is TRUE
Switch boolean test without explicit cast:1 is a string (this is not what we
want to see)
Switch boolean test with explicit cast: default:s 1 is something else (this is
the correct choice)
===============================================================================

Apparently you need to be extra careful with "0" (zero) in your case statements
when mixing int and string values:

switch($key) {
     case 0: echo "only if I am zero";break;
     case 1: echo "I'm one";break;
     case "E1": echo "Why don't you output me?";break;
     default: echo "No value Found";
}

Switch will be convinced that you mean "0" when you really mean "E1" unless you
wrap it in quotes:

switch($key) {
     case '0': echo "only if I am zero";break;
     case 1: echo "I'm one";break;
     case "E1":echo "Yay! I'm back!";break;
     default: echo "No value Found";
}

Maybe this is what they mean by "loose comparison" with True, False operators?
===============================================================================

In regard to what dohpaz at kennethpaul dot com wrote.

If you ever have time you may want to test out having a premade associative
array with the required elements eaqualing the needed value. Then assign the
value based on the array element.

in dohpaz's month example it would look like this:
<?php
$arr_month = array(
'January' => 1,
'February' => 2,
'March' => 3,
'April' => 4,
'May' => 5,
'June' => 6,
'July' => 7,
'August' => 8,
'September' => 9,
'October' => 10,
'November' => 11,
'December' => 12);
foreach($arr_month as $k => $v) {$arr_month[substr($k,0,3)] = $v;} // autogen a
3 letter version

//note that the overall size will be 23 because May will only exist once

$month = 'Jan';
$month = $arr_months[$month];
echo $month; // outputs: 1
?>

It beats a switch in this case.

I did some benchmarking.
The array system is faster than the switch system.

Here were my average time results of 1000 itterations of assigning the numeric
value to the month.
The value was randomized between each itteration (this was not added to the
benchmark value), so each method was simulated with various data to stress
different points.

array:
'avg' => 1.09958648682E-6
switch:
'avg' => 4.32157516479E-6
switch (true):
'avg' => 6.90913200378E-6

Contrary to what dohpaz suggested I found that a normal switch was faster than
a switch(true) version.

I repeated these test several times to take into acount server load variations.
The ratios were always consistent.

The array way is notably faster.
===============================================================================

Also,
when using switch for mode selecting on websites like:

switch($_GET['mode']) {
  case "gallery":
    //code
  break;
  case "news":
    //code
  break;
  case "stuff":
    //code
  break;
  default, etc etc
}

Will NOT trigger the string == 0 bug, because $_GET automatically parse
anything passed to them as strings.
(same applies for all browser variables: SESSION, POST etc)

so passing:
mode=0
into the address bar is the same as:
$_GET['mode'] = "0"; //not $_GET['mode'] = 0;

thought it may help.
===============================================================================

You can solve the problem by just writing the following piece of code:

<?php
$x = 18;
$y = 6;

switch ($x) {
   case ($y * 4):
   case (9 * 3):
       echo "Member";
       break;
   default:
       echo "Not a member";
}
?>
===============================================================================

You can also nest switch statements inside case statements:

<?php
   // Set argument handlers
    $argv = explode(",", urldecode(getenv('QUERY_STRING')));
    $argc = array_shift($argv);
    $argd = array_shift($argv);
    $arge = array_shift($argv);
?>

   // Begin switching

<?php
    switch ($argc) {
        case 'home': {
             print('This is $argc, home case.');
            break;
        }
        case 'subsection': {
                switch ($argd) {
                     case 'links': {
                            switch($arge) {
                                case 'display': {
                                print('This is $arge, subsection,links,display
case.');
                                break;
                                }
                           }
                    }
                }
        }
    }
?>
===============================================================================

As jason at devnetwork dot net and others have pointed out, using switch() when
you wish to compare against strings can be dangerous:

<?php
$bug = 0;
switch ($bug) {
    case 'fly':
        echo 'flies buzz';
        break;

    case 'mantis':
        echo 'mantes pray';
        break;

    default:
        echo 'swat, splat, you are dead';
        break;
}
?>

Will print "flies buzz", NOT "swat, splat, you are dead".
Remember PHP says that 'fly' == 0, or in general string == 0 is true.

Anyway, avoid that with:

<?php
$bug = 0;
switch ($bug === 0 ? '' : $bug) {
    case 'fly':
        echo 'flies buzz';
        break;

    case 'mantis':
        echo 'mantes pray';
        break;

    default:
        echo 'swat, splat, you are dead';
        break;
}
?>

Prints out what you expect:

Swat
Splat
You are dead

P.S.: that's an empty string (single quote single quote), not a spurious double
quote.
===============================================================================

if and switch statement :             
  <?php
               
                    $gender = "male";
                    $nam ="johnson";
                    if ($gender==="male"){
                        echo "hello Mr. {$nam}";                               
 
                    }elseif ($gender === "female") {
                        echo "hello Mrs. {$nam}";
                }elseif ($gender=== "Doc") {
                    echo "hello Dr.{$nam}";
                }else {
                    echo "Hello Human!";
                }
                   
                ?>
                   <hr>
                   <!--
===========================================
                -->
                <?php
               
                switch ($gender){
                    case "female"  :echo  "hello Mrs. {$nam}";                 
              break;
                    case "male"      :echo "hello Mr. {$nam}";                 
                break;
                    case "Doc"        :echo "hello Dr. {$nam}" ;               
                 break;
                    default : "Hello Human!";                                 
                             break;                        
                }
                ?>
===============================================================================

It's obvious, but might still bear explicit mention that you can conditionally
execute the BREAK statement in order to allow a CASE to fall through to the
next CASE. 

e.g.:-> Here, CASE 1 will fall through and the DEFAULT CASE statements will
also be executed unless $somevar is true.

<?php
switch ($i) {
    case 0:
        print "i equals 0";
        break;
    case 1:
        print "i equals 1";
        if ($somevar) {
             break;
             }
    default;
       echo 'Some Default Statements';
        break;
}
?>

Cheers,
Ben Nardone
===============================================================================

This caught me out. The number '6' when compared with the string '6b' returns
true. The solution is to either typecast the compare  -  ie, " switch ((string)
$type): "  or to make sure $type is a string (eg $type="6")

<?
$type=6;
switch ($type):
    case "6b":
        print "6b: ";
        print $type;
    break;
    case "6":
        print "6: ";
        print $type;
    break;
endswitch;
?>
===============================================================================

In reply to Alex Fung :
The following code doesn't work :

<?php
$x = 18;
$y = 6;

switch ($x) {
   case (($y * 4) || (9 * 3)):
       echo "Member";
       break;
   default:
       echo "Not a member";
}
?>

Why :
<design at hyperoptix dot com> want to test if $x == $y*4 or $x == 9*3 ($x ==
(($y*4)||(9*3))
However the case statement evaluate the value of (($y*4)||(9*3)) that is always
true because 9*3=27 (!=0)
That's why this code always return true when $x != 0.
The correct code would be :

<?php
$x = 18;
$y = 6;

switch ($x) {
   case (($y * 4)):
   case ((9*3)):
        echo "Member";
        break;
   default:
       echo "Not a member";
}
?>

Boolean logic work inside case statement, you just need to know that the
expression in the case statement is first evaluated then compared with the
evaluated value in the switch statement.
===============================================================================

Regarding bishop's comment below, although using:
   switch($bug === 0 ? '' : $bug) {
may work, ( and although I do like the ternary operator, :) it might be more
intuitive/readable to use this instead:
   switch( (string)$bug ) {
which typecasts the variable to a string to ensure that "0" will be handled
correctly.
===============================================================================

working a bit around with it I found out that it is not possible to
compare the variable with two different values in one step like this
(system running a w2k server, apache2.0.43 & php430):

<?php
switch ($myvar) {
case ("foo" || "bar"): //do something
break;
case ("other"): //do another thing
break;
default:
}
?>

rather use:

<?php
switch ($myvar) {
case ("foo"):
case ("bar"): //do something
break;
case ("other"): //do another thing
break;
default:
}
?>
===============================================================================

It's has already been mentioned indirectly in a few posts, but it is important
to realize that switch statements evaluate each case with the "==" operator by
default. This can lead to unexpected results when comparing strings to
integers, because PHP will convert the string to an integer. In many cases this
means a string can be equivalent to the integer 0.

Example:
<?php
$x = 0;

switch($x) {
case "a":
    echo "a";
    break;
case "b":
    echo "b";
    break;
default
    echo "default";
}
?>

The result will be an "a" echoed out. What PHP does in this instance, is once
it realizes that it's attempting to compare string ("a") to an integer (0), it
converts "a" into an integer which ends up satisfying the first case.

The rules for string conversion into integers is available at:
http://us3.php.net/manual/en/language.types.string.php

The easiest way to combat this issue is to force type comparison by using the "
===" operator. This makes PHP forego the string to integer conversion.

Example:
<?php
switch(true) {
case $x === "a":
    echo "a";
    break;
case $x === "b":
    echo "b";
    break;
default
    echo "default";
}
?>

Or the switch input can be type-casted to always be a string, etc.

Also note that even though a conditional statement needs to be explicitly set
in each case to gain expected behavior, the switch can still execute faster
then an "ifelse" block because PHP will not continue to evaluate conditions
once a case has been satisfied.
===============================================================================

So instead of writing the code shown below it would have to be like this:

<?php
$x = 18;
$y = 6;

switch ($x) {
   case ((($y * 4) || (9 * 3))?$x:false):
       echo "Member";
       break;
   default:
       echo "Not a member";
}
?>

So now the case expression contains an if statement in simplified notation
which either returns the value of $x if the expression is true (so the case
matches) or false, if the expression was false (so the case does not match).
Be aware that it only works if $x never actually is "false" because then it
would match in either case. So the "false" in the above code should always be
any random value which is not a possible value for $x.
===============================================================================

often you will have to perform multiple actions in sequence, but this sequence
must be broken once one of them detects a stop condition (such as an error,
when validating form request variables).
One way is to use:

if (check1()
&& check2()
&& check3()
) valid();
else error();

But when the sequence is long and must reordered, this can be errorprone
because not all line of check have the same syntax (imagine that you want to
comment one of them).

Another way is to rewrite it as:

check1() and
check2() and
check3() and
...
valid() or
error();

The above syntax does not fit well when the valid() code must be several
statements.
An alternative syntax can be:

switch (false) {
case check1():
case check2():
case check3():
  error();
  break;
default:
  valid();
}

This last equivalent sample show you that each case expressions is evaluated,
until one of them evaluates to a value equal (==) to the switch expression.
Above, the error() code will only be called if one of the check evaluates to
false. And the valid() code will only be evaluated only if the switch reach the
default, which means that none of the above check returned false...
===============================================================================

/*
    Have one value need to deal with currency
    - follow as example
*/
while ($row = mysql_fetch_array($v_Result,MYSQL_NUM)) {
    $v_BAL = $row[1]/10000;
   
    switch (TRUE){

        case ($v_BAL <= 0):            //less then 0 , -0
            echo $v_BAL;
        break;
                   
        case ($v_BAL <= 10 AND $v_BAL >= 1):    //less then 10 and greater then
1
            echo $v_BAL;
        break;
                                       
        default:                //default
            echo $v_BAL;
        break;
    }
}
===============================================================================

In the post:
----------------------------------------------------
design at hyperoptix dot com
18-Feb-2004 12:46
Boolean logic does not work inside case statements:

<?php
$x = 18;
$y = 6;

switch ($x) {
   case (($y * 4) || (9 * 3)):
       echo "Member";
       break;
   default:
       echo "Not a member";
}
?>

echoes "Member".
----------------------------------------------------
there were many responses but all seem to miss the point.  You cannot mix
apples and oranges.  The "switch($x)" establishes that this "switch" statement
will be a Relational syntax while the "case" qualifier uses a Logical syntax. 
There must be a match.  Either change "switch($x)" to "switch(true)" or change
"case(($y * 4) || (9 * 3)):" to resolve to a value.

The syntax of the original post is like a cop that says, "I want all of your
answers to reflect truth.  So, are you eighteen?"  The respondent says, " 4 x 4
or 11 + 5".  Need I say more?
===============================================================================

In response to 'i luv spam',

when you enter 07, you tell PHP to interpret a number as an octal number (much
like '0x' for hex numbers). Octal numbering system uses only 8 digits, i.e.
0-7. http://en.wikipedia.org/wiki/Octal

The number 8 does not exist in octal numbering system. The comparison works
because the octal numbers 0 to 7 have identical counterparts in decimal system.

So, in order to get a number compared as decimal 8, you would have to enter 010
in the case.

BTW this behavior obviously isn't specific to switch, it's a part of PHP.

(I personally stumbled into this when trying to make my code nicely indented
while declaring an array)
===============================================================================

It should be pointed out that this:

<?php

$var = 0;

switch ( $var )
{
    case "something":
        $foo = "Broken";
        break;
    default:
        $foo = "Okay";
        break;
}

echo $foo;

?>

Will print out "Broken".  It's not broken, because in PHP, when an Integer and
a String are compared, the string is == 0.  So 0 == "something".  However, this
is not apparent.  switch() does not do type checking.
===============================================================================

Be carefull: If you want to test the return of a function, you have to use
switch, because if you use 'if' and 'ifelse', your function will be executed
every time again.

For example if use use the following construct:

if(file_get_contents('file.htm', 0) == 'typ1') {
     // Do one thing
}
ifelse(file_get_contents('file.htm', 0) == 'typ2') {
     // Do the second thing
}
ifelse(file_get_contents('file.htm', 0) == 'typ3') {
     // Do the third thing
}

The file will be requested 3 times!!!

If you use the following:

switch (file_get_contents('file.htm', 0)) {
     case 'typ1': // Do one thing
     break;
     case 'typ2': // Do the second thing
     break;
     case 'typ3': // Do the third thing
}

The file will be requested only once!!!
===============================================================================

Just a reminder: there may be easier ways to manipulate _long_ lists of data
instead of using switches.

function getChineseZodiac($year){
 
  // Chinese Zodiac Animals
  $animals = Array
  (
    'Monkey',  // Years 0, 12, 1200, 2004...
    'Rooster',
    'Dog',
    'Boar',
    'Rat',
    'Ox',
    'Tiger',
    'Rabit',
    'Dragon',
    'Snake',
    'Horse',
    'Lamb'
  );

  // Number of animals and years in a calendar rotation
  $numAnimals = count($animals);

  // Years left until full rotation of calender
  $yearOffset= round($year) % $numAnimals;
 
  return $animals[$yearOffset];
 
}

Of course this is a really generic function, we're just finding how many years
away from a full 12 year rotation the current year is.
===============================================================================

Just in reply to the comment about 2 digit numbers: something octal certainly
is going on. Integer literals prefixed with a "0", like in C and several other
languages, are treated as octal. Similarly, integer literals prefixed with "0x"
are treated as hexadecimal. Seeing as this is the case, 08 and 09 are not valid
integer literals. It turns out that php treats them as 0 (it would probably be
better to fail with an error message, but it doesn't). Bottom line? Don't
prefix numbers with 0 in code unless you mean octal. Format them as you print
them with printf, like so: printf("%02u", $my_unsigned_int); or if you will,
use sprintf to get a string representation rather than printing on stdout.
===============================================================================

A word of caution around the order used for the case/default controls.  I
notice that a lot of people do not break; the default section and the following
could lead to incorrect results when run.

$a = "lowercase";

switch ( $a ) {
  default:
    $a = strtoupper( $a );
    print $a . "<br />";

  case ( 'LOWERCASE' ):
    print $a . "<br />";
    break;
}

Result:
LOWERCASE
LOWERCASE

Placing a break; in the default control will result in:
LOWERCASE

.. as expected.  Also, placing the default section at the bottom (as in an else
control) will also display the correct result.
===============================================================================

Along the lines of using expressions in switch statements.  I came across some
code which wrapped switch statements in 'if' blocks like so...
if (isset($var) {
    switch($var) {
        ....
   

But I found the following a little cleaner.

switch ( isset($var) ? $var : defaultValue ) {
...
===============================================================================

Noticed some odd switch behavior worth mentioning:

Switching on a variable set as $var="08" and forgetting the quotes within the
case results in different behavior depending on the two digit number the
variable is set to.

For "01" to "07", using a case like
  case 01:
the case is triggered.

For "08" or "09" the case is skipped.

For "10" to "12" the case is triggered.

Looks like something octal may be going on.

Anyway, not a problem once the case is changed to:
  case "08":
as it should have been from the start.  Just odd.
