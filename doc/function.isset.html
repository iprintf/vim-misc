
isset

(PHP 4, PHP 5, PHP 7)

isset — 检测变量是否设置

说明

bool isset ( mixed $var [, mixed $... ] )

检测变量是否设置，并且不是 NULL。

如果已经使用 unset() 释放了一个变量之后，它将不再是 isset()。若使用 isset() 测
试一个被设置成 NULL 的变量，将返回 FALSE。同时要注意的是一个 NULL 字节（"\0"）
并不等同于 PHP 的 NULL 常数。

If multiple parameters are supplied then isset() will return TRUE only if all
of the parameters are set. Evaluation goes from left to right and stops as soon
as an unset variable is encountered.

参数

var

    要检查的变量。

...

    其他变量。

返回值

如果 var 存在并且值不是 NULL 则返回 TRUE，否则返回 FALSE。

更新日志

版本                   说明
5.4.0 检查字符的非数字偏移量将会返回 FALSE。

范例

Example #1 isset() 例子

<?php

$var = '';

// 结果为 TRUE，所以后边的文本将被打印出来。
if (isset($var)) {
    echo "This var is set so I will print.";
}

// 在后边的例子中，我们将使用 var_dump 输出 isset() 的返回值。
// the return value of isset().

$a = "test";
$b = "anothertest";

var_dump(isset($a));      // TRUE
var_dump(isset($a, $b)); // TRUE

unset ($a);

var_dump(isset($a));     // FALSE
var_dump(isset($a, $b)); // FALSE

$foo = NULL;
var_dump(isset($foo));   // FALSE

?>

这对于数组中的元素也同样有效：
<?php

$a = array ('test' => 1, 'hello' => NULL, 'pie' => array('a' => 'apple'));

var_dump(isset($a['test']));            // TRUE
var_dump(isset($a['foo']));             // FALSE
var_dump(isset($a['hello']));           // FALSE

// 键 'hello' 的值等于 NULL，所以被认为是未置值的。
// 如果想检测 NULL 键值，可以试试下边的方法。 
var_dump(array_key_exists('hello', $a)); // TRUE

// Checking deeper array values
var_dump(isset($a['pie']['a']));        // TRUE
var_dump(isset($a['pie']['b']));        // FALSE
var_dump(isset($a['cake']['a']['b']));  // FALSE

?>

Example #2 isset() on String Offsets

PHP 5.4 changes how isset() behaves when passed string offsets.

<?php
$expected_array_got_string = 'somestring';
var_dump(isset($expected_array_got_string['some_key']));
var_dump(isset($expected_array_got_string[0]));
var_dump(isset($expected_array_got_string['0']));
var_dump(isset($expected_array_got_string[0.5]));
var_dump(isset($expected_array_got_string['0.5']));
var_dump(isset($expected_array_got_string['0 Mostel']));
?>

以上例程在PHP 5.3中的输出：

bool(true)
bool(true)
bool(true)
bool(true)
bool(true)
bool(true)

以上例程在PHP 5.4中的输出：

bool(false)
bool(true)
bool(true)
bool(true)
bool(false)
bool(false)

注释

Warning

isset() 只能用于变量，因为传递任何其它参数都将造成解析错误。若想检测常量是否已
设置，可使用 defined() 函数。

    Note: 因为是一个语言构造器而不是一个函数，不能被可变函数调用。

    Note:

    如果使用 isset() 来检查对象无法访问的属性，如果 __isset() 方法已经定义则会
    调用这个重载方法。

参见

  • empty() - 检查一个变量是否为空
  • __isset()
  • unset() - 释放给定的变量
  • defined() - 检查某个名称的常量是否存在
  • the type comparison tables
  • array_key_exists() - 检查给定的键名或索引是否存在于数组中
  • is_null() - 检测变量是否为 NULL
  • 错误控制 @ 运算符。


User Contributed Notes 61 notes

===============================================================================

"empty() is the opposite of (boolean) var, except that no warning is generated
when the variable is not set."

So essentially
<?php
if (isset($var) && $var)
?>
is the same as
<?php
if (!empty($var))
?>
doesn't it? :)

!empty() mimics the chk() function posted before.
===============================================================================

in PHP5, if you have

<?PHP
class Foo
{
    protected $data = array('bar' => null);

    function __get($p)
    {
        if( isset($this->data[$p]) ) return $this->data[$p];
    }
}
?>

and
<?PHP
$foo = new Foo;
echo isset($foo->bar);
?>
will always echo 'false'. because the isset() accepts VARIABLES as it
parameters, but in this case, $foo->bar is NOT a VARIABLE. it is a VALUE
returned from the __get() method of the class Foo. thus the isset($foo->bar)
expreesion will always equal 'false'.
===============================================================================

To organize some of the frequently used functions..

<?php

/**
* Returns field of variable (arr[key] or obj->prop), otherwise the third
parameter
* @param array/object $arr_or_obj
* @param string $key_or_prop
* @param mixed $else
*/
function nz($arr_or_obj, $key_or_prop, $else){
  $result = $else;
  if(isset($arr_or_obj)){
    if(is_array($arr_or_obj){
      if(isset($arr_or_obj[$key_or_prop]))
        $result = $arr_or_obj[$key_or_prop];
    }elseif(is_object($arr_or_object))
      if(isset($arr_or_obj->$key_or_prop))
        $result = $arr_or_obj->$key_or_prop;
    }
  }
  return $result;
}

/**
* Returns integer value using nz()
*/
function nz_int($arr_or_obj, $key_or_prop, $else){
  return intval(nz($arr_or_obj, $key_or_prop, $else));
}

$my_id = nz_int($_REQUEST, 'id', 0);
if($my_id > 0){
  //why?
}
?>
===============================================================================

How to test for a variable actually existing, including being set to null. This
will prevent errors when passing to functions.

<?php
// false
var_export(
  array_key_exists('myvar', get_defined_vars())
);

$myvar;
// false
var_export(
  array_key_exists('myvar', get_defined_vars())
);

$myvar = null;
// true
var_export(
  array_key_exists('myvar', get_defined_vars())
);

unset($myvar);
// false
var_export(
  array_key_exists('myvar', get_defined_vars())
);

if (array_key_exists('myvar', get_defined_vars())) {
  myfunction($myvar);
}
?>

Note: you can't turn this into a function (e.g. is_defined($myvar)) because
get_defined_vars() only gets the variables in the current scope and entering a
function changes the scope.
===============================================================================

I tried the example posted previously by Slawek:

$foo = 'a little string';
echo isset($foo)?'yes ':'no ', isset($foo['aaaa'])?'yes ':'no ';

He got yes yes, but he didn't say what version of PHP he was using.

I tried this on PHP 5.0.5 and got:  yes no

But on PHP 4.3.5 I got:  yes yes

Apparently, PHP4 converts the the string 'aaaa' to zero and then returns the
string character at that position within the string $foo, when $foo is not an
array. That means you can't assume you are dealing with an array, even if you
used an expression such as isset($foo['aaaa']['bbb']['cc']['d']), because it
will return true also if any part is a string.

PHP5 does not do this. If $foo is a string, the index must actually be numeric
(e.g. $foo[0]) for it to return the indexed character.
===============================================================================

isset expects the variable sign first, so you can't add parentheses or
anything.

<?php
    $foo = 1;
    if(isset(($foo))) { // Syntax error at isset((
        $foo = 2;
    }
?>
===============================================================================

<?php
$foo = 'a little string';
echo isset($foo)?'yes ':'no ', isset($foo['aaaa'])?'yes ':'no ';
>

results with unexpected values:
yes yes

Well, it is necessary to check type of $foo first !
===============================================================================

Here is an example with multiple parameters supplied

<?php
$var = array();
$var['val1'] = 'test';
$var['val2'] = 'on';

if ( isset( $var['val1'], $var['val2'] ) && $var['val2'] === 'on' ) {
    unset( $var['val1'] );
}
print_r( $var );
?>

This will output:
Array
(
    [val2] => on
)

The following code does the same calling "isset" 2 times:

<?php
$var = array();
$var['val1'] = 'test';
$var['val2'] = 'on';

if ( isset( $var['val1'] ) && isset( $var['val2'] ) && $var['val2'] === 'on' )
{
    unset( $var['val1'] );
}
print_r( $var );
?>
===============================================================================

Note that isset() is not recursive as of the 5.4.8 I have available here to
test with: if you use it on a multidimensional array or an object it will not
check isset() on each dimension as it goes.

Imagine you have a class with a normal __isset and a __get that fatals for
non-existant properties. isset($object->nosuch) will behave normally but isset
($object->nosuch->foo) will crash. Rather harsh IMO but still possible.

<?php

class FatalOnGet {

    // pretend that the methods have implementations that actually try to do
work
    // in this example I only care about the worst case conditions

    public function __get($name) {
        echo "(getting {$name}) ";

        // if property does not exist {
            echo "Property does not exist!";
            exit;
        // }
    }

    public function __isset($name) {
        echo "(isset {$name}?) ";
        // return whether the property exists
        return false;
    }

}

$obj = new FatalOnGet();

// works
echo "Testing if ->nosuch exists: ";
if (isset($obj->nosuch)) echo "Yes"; else echo "No";

// fatals
echo "\nTesting if ->nosuch->foo exists: ";
if (isset($obj->nosuch->foo)) echo "Yes"; else echo "No";

// not executed
echo "\nTesting if ->irrelevant exists: ";
if (isset($obj->irrelevant)) echo "Yes"; else echo "No";

?>

    Testing if ->nosuch exists: No
    Testing if ->nosuch->foo exists: Property does not exist!

Uncomment the echos in the methods and you'll see exactly what happened:

    Testing if ->nosuch exists: (isset nosuch?) No
    Testing if ->nosuch->foo exists: (getting nosuch) Property does not exist!

On a similar note, if __get always returns but instead issues warnings or
notices then those will surface.
===============================================================================

I found something interesting while working with isset() in PHP5.5+

<?php

$a = "foo";
$b = "bar";

var_dump(isset($a, $b)); //returns true

unset($b);

var_dump(isset($a,$b)); // returns false (as expected);

...BUT...
var_dump(!isset($a,$b)); // STILL returns true!
===============================================================================

Now this is how to achieve the same effect (ie, having isset() returning true
even if variable has been set to null) for objects and arrays

<?php

// array

$array=array('foo'=>null);

return isset($array['foo']) || array_key_exists('foo',$array)
  ? true : false ; // return true

return isset($array['inexistent']) || array_key_exists('inexistent',$array)
  ? true : false ; // return false

// static class

class bar

{
  static $foo=null;
}

return isset(bar::$foo) || array_key_exists('foo',get_class_vars('bar'))
  ? true : false ; // return true

return isset(bar::$inexistent) || array_key_exists('inexistent',get_class_vars(
'bar'))
  ? true : false ; // return false

// object

class bar
{
    public $foo=null;
}

$bar=new bar();

return isset($bar->foo) || array_key_exists('foo',get_object_vars($bar))
  ? true : false ; // return true

return isset($bar->inexistent) || array_key_exists('inexistent',get_object_vars
($bar))
  ? true : false ; // return true

// stdClass

$bar=new stdClass;
$bar->foo=null;

return isset($bar->foo) || array_key_exists('foo',get_object_vars($bar))
  ? true : false ; // return true

return isset($bar->inexistent) || array_key_exists('inexistent',get_object_vars
($bar))
  ? true : false ; // return true

?>
===============================================================================

Sometimes you have to check if an array has some keys. To achieve it you can
use "isset" like this: isset($array['key1'], $array['key2'], $array['key3'],
$array['key4'])
You have to write $array all times and it is reiterative if you use same array
each time.

With this simple function you can check if an array has some keys:

<?php
function isset_array() {
    if (func_num_args() < 2) return true;
    $args = func_get_args();
    $array = array_shift($args);
    if (!is_array($array)) return false;
    foreach ($args as $n) if (!isset($array[$n])) return false;
    return true;
}
?>

Use: isset_array($array, 'key1', 'key2', 'key3', 'key4')
First parameter has the array; following parameters has the keys you want to
check.
===============================================================================

The following is an example of how to test if a variable is set, whether or not
it is NULL. It makes use of the fact that an unset variable will throw an
E_NOTICE error, but one initialized as NULL will not.

<?php

function var_exists($var){
    if (empty($GLOBALS['var_exists_err'])) {
        return true;
    } else {
        unset($GLOBALS['var_exists_err']);
        return false;
    }
}

function var_existsHandler($errno, $errstr, $errfile, $errline) {
   $GLOBALS['var_exists_err'] = true;
}

$l = NULL;
set_error_handler("var_existsHandler", E_NOTICE);
echo (var_exists($l)) ? "True " : "False ";
echo (var_exists($k)) ? "True " : "False ";
restore_error_handler();

?>

Outputs:
True False

The problem is, the set_error_handler and restore_error_handler calls can not
be inside the function, which means you need 2 extra lines of code every time
you are testing. And if you have any E_NOTICE errors caused by other code
between the set_error_handler and restore_error_handler they will not be dealt
with properly. One solution:

<?php

function var_exists($var){
   if (empty($GLOBALS['var_exists_err'])) {
       return true;
   } else {
       unset($GLOBALS['var_exists_err']);
       return false;
   }
}

function var_existsHandler($errno, $errstr, $errfile, $errline) {
    $filearr = file($errfile);
    if (strpos($filearr[$errline-1], 'var_exists') !== false) {
        $GLOBALS['var_exists_err'] = true;
        return true;
    } else {
        return false;
    }
}

$l = NULL;
set_error_handler("var_existsHandler", E_NOTICE);
echo (var_exists($l)) ? "True " : "False ";
echo (var_exists($k)) ? "True " : "False ";
is_null($j);
restore_error_handler();

?>

Outputs:
True False
Notice: Undefined variable: j in filename.php on line 26

This will make the handler only handle var_exists, but it adds a lot of
overhead. Everytime an E_NOTICE error happens, the file it originated from will
be loaded into an array.
===============================================================================

Careful with this function "ifsetfor" by soapergem, passing by reference means
that if, like the example $_GET['id'], the argument is an array index, it will
be created in the original array (with a null value), thus causing posible
trouble with the following code. At least in PHP 5.

For example:

<?php
$a = array();
print_r($a);
ifsetor($a["unsetindex"], 'default');
print_r($a);
?>

will print

Array
(
)
Array
(
    [unsetindex] =>
)

Any foreach or similar will be different before and after the call.
===============================================================================

Simple solution for: "Fatal error: Can't use function return value in write
context in ..."

<?php
function _isset($val) { return isset($val); }
?>
===============================================================================

Note: Because this is a language construct and not a function, it cannot be
called using variable functions.

So why it is under "Variable handling Functions". Maybe there should be some
good documentation field for language constructs.
===============================================================================

You can safely use isset to check properties and subproperties of objects
directly. So instead of writing

    isset($abc) && isset($abc->def) && isset($abc->def->ghi)

or in a shorter form

    isset($abc, $abc->def, $abc->def->ghi)

you can just write

    isset ($abc->def->ghi)

without raising any errors, warnings or notices.

Examples
<?php
    $abc = (object) array("def" => 123);
    var_dump(isset($abc));                // bool(true)
    var_dump(isset($abc->def));           // bool(true)
    var_dump(isset($abc->def->ghi));      // bool(false)
    var_dump(isset($abc->def->ghi->jkl)); // bool(false)
    var_dump(isset($def));                // bool(false)
    var_dump(isset($def->ghi));           // bool(false)
    var_dump(isset($def->ghi->jkl));      // bool(false)

    var_dump($abc);                       // object(stdClass)#1 (1) { ["def"]
=> int(123) }
    var_dump($abc->def);                  // int(123)
    var_dump($abc->def->ghi);             // null / E_NOTICE: Trying to get
property of non-object
    var_dump($abc->def->ghi->jkl);        // null / E_NOTICE: Trying to get
property of non-object
    var_dump($def);                       // null / E_NOTICE: Trying to get
property of non-object
    var_dump($def->ghi);                  // null / E_NOTICE: Trying to get
property of non-object
    var_dump($def->ghi->jkl);             // null / E_NOTICE: Trying to get
property of non-object
?>
===============================================================================

//thin way to set a variable
$foo  = isset($_POST['foo']) ? $_POST['foo'] : null;
===============================================================================

1) Note that isset($var) doesn't distinguish the two cases when $var is
undefined, or is null. Evidence is in the following code.

<?php
unset($undefined);
$null = null;
if (true === isset($undefined)){echo 'isset($undefined) === true'} else {echo 
'isset($undefined) === false'); // 'isset($undefined) === false'
if (true === isset($null)){echo 'isset($null) === true'} else {echo 'isset
($null) === false');              // 'isset($null)      === false'
?>

2) If you want to distinguish undefined variable with a defined variable with a
null value, then use array_key_exist

<?php
unset($undefined);
$null = null;

if (true !== array_key_exists('undefined', get_defined_vars())) {echo 
'$undefined does not exist';} else {echo '$undefined exists';} // '$undefined
does not exist'
if (true === array_key_exists('null', get_defined_vars())) {echo '$null exists'
;} else {echo '$null does not exist';}                // '$null exists'
?>
===============================================================================

Note that array keys are case sensitive.

<?php
$ar['w'] = true;

var_dump(isset($ar['w']),
      isset($ar['W']));
?>

will report:
bool(true) bool(false)
===============================================================================

Note: isset() only checks variables as anything else will result in a parse
error. In other words, the following will not work: isset(trim($name)).

isset() is the opposite of is_null($var) , except that no warning is generated
when the variable is not set.
===============================================================================

isset() returns TRUE if a value is NULL. That seems wrong to me as there is no
way to distinguish between a value set to NULL and a truly undefined value.

If you have this problem inside a class, there is a fix:

<?php
class T
{
  function __isset($att)
  {
    $props = get_object_vars($this);
    return array_key_exists($att, $props);
  }
}

$x = new T();
$x->foo_exists = 4;

var_dump(isset($x->foo_exists)); // TRUE
var_dump(isset($x->bar_exists)); // FALSE
?>
[EDITOR thiago NOTE: This snippet has improvements by "Paul Lashbrook"]
===============================================================================

In PHP 5.2.3, really returns true if the variable is set to null.
===============================================================================

Here's a simple function to test if the variable is set:

<?php
function is($var)
{
if (!isset($var)) return false;
if ($var!==false) return true;
return false;
}
?>

Now instead of very popular (but invalid in many situations):

if (!$var) $var=5;

you can write:

if (!is($var)) $var=5;
===============================================================================

In PHP4, the following works as expected:

<?php
if (isset($obj->thing['key'])) {
  unset($obj->thing['key']) ;
}
?>

In PHP5 however you will get a fatal error for the unset().

The work around is:

<?php
if (is_array($obj->thing) && isset($obj->thing['key'])) {
  unset($obj->thing['key']) ;
}
?>
===============================================================================

<?php
return isset($nonexistentarray['foo']);
?>
Returns false without trouble (assuming $nonexistent array does not exist).

<?php
$foo = 17;
return isset($nonexistentarray[$foo]);
?>
Also returns false without trouble.

But, oddly,
<?php
return isset($nonexistentarray[$nonexistentkey]);
?>
While returning false, also triggers a notice regarding the undefined variable
"$nonexistentkey".

Some thought shows that this is the right behaviour (we're testing for the
existence of an array element, but we need to know which array element we're
testing the existence of), but it probably isn't obvious. This implies that:
<?php
$extantarray[null] = 42;
return isset($extantarray[$nonexistentkey]);
?>
Triggers a notice and returns true.
===============================================================================

In response to 10-Feb-2006 06:02, isset($v) is in all (except possibly buggy)
cases equivalent to !is_null($v). And no, it doesn't actually test if a
variable is set or not by my definition "$v is set if unset($v) has no effect".

<?php
unset($c); //force $c to be unset
var_dump($a=&$c); // NULL, but this actually sets $a and $c to the 'same' NULL.
var_dump(isset($c)); // bool(false)
var_dump($a = 5); // int(5)
var_dump($c); // int(5)

unset($c);
var_dump($a=&$c); // NULL
var_dump(isset($c)); // bool(false)
unset($c);
var_dump($a = 5); // int(5)
var_dump($c); // NULL
?>

In the following example, we see an alternate method of testing if a variable
is actually set or not:
<?php
var_dump(array_key_exists('c',get_defined_vars())); // false
var_dump(isset($c));                                // also false
var_dump($c);                                       // manipulate $c a bit...
var_dump((string)$c);
var_dump(print_r($c,true));
var_dump($a=$c);
var_dump(array_key_exists('c',get_defined_vars())); // ... still false
var_dump($c = NULL);                                // this sets $c
var_dump(array_key_exists('c',get_defined_vars())); // true!
var_dump(isset($c));                                // false; isset() still
says it's unset
unset($c);                                          // actually unset it
var_dump(array_key_exists('c',get_defined_vars())); // false
var_dump($a=&$c);                                          
var_dump(array_key_exists('c',get_defined_vars())); // true!
unset($c);                                          // unset it again
var_dump(&$c);                                      // &NULL
var_dump(array_key_exists('c',get_defined_vars())); // true!
?>

Obviously, null values take up space (or they wouldn't show up in
get_defined_vars). Also, note that &$v sets $v to NULL if it is unset.
===============================================================================

Here's a nice little function that I use everywhere that'll help with setting
alternate values so you don't have a bunch of situations like:

<?php
if(isset($a))
{
    $b = $a;
}
else
{
    $b = "default";
}

function isset_or(&$check, $alternate = NULL)
{
    return (isset($check)) ? $check : $alternate;
}

// Example usage:
$first_name = isset_or($_POST['first_name'], "Empty");
$total        = isset_or($row['total'], 0);

?>
===============================================================================

The unexpected results of isset has been really frustrating to me. Hence, it
doesn't work how you'd think it would, (as documented) a var currently in the
scope with a null value will return false.

Heres a quick solution, perhaps there are better ways of going about this, but
heres my solution...

<?php
function is_set( $varname, $parent=null ) {
  if ( !is_array( $parent ) && !is_object($parent) ) {
    $parent = $GLOBALS;
  }
  return array_key_exists( $varname, $parent );
}
?>

Hence, $varname should be a mixed value of var's to check for, and $parent can
be an array or object, which will default to the GLOBAL scope. See the
documentation of array_key_exists for further information.

This will allow to check if a var is in the current scope, object, or array...
Whether it's a null, false, true, or any value. It depends on ARRAY_KEY_EXISTS
for it's functionality which also works with Objects. Feel free to improve on
this anyone ;D
===============================================================================

Beware that the chk() function below creates the variable or the array index if
it didn't existed.

<?php
function chk(&$var) {
  if (!isset($var))
    return NULL;
  else
    return $var;
}

echo '<pre>';
$a = array();
var_dump($a);
chk($a['b']);
var_dump($a);
echo '</pre>';

// Gives:
// array
//   empty
//
// array
//   'b' => null
?>
===============================================================================

I don't know if you guys can use this but i find this piece of code pretty
useful (for readabillity at least):

function isset_else( $&v, $r )
{
    if( isset( $v ))
        return $v;
    else
        return $r;
}

This way you can go:

$a = 4;

$c += isset_else( $a, 0 );
$c += isset_else( $b, 0 );

echo $c;

Of course, this code would work anyway, but you get the point.
===============================================================================

It is possible to encapsulate isset() calls inside your own functions if you
pass them by reference (note the ampersand in the argument list) instead of by
value. A prime example would be the heavily-requested "ifsetor" function, which
will return a value when it is set, otherwise a default value that the user
specifies is used.

<?php

function ifsetor(&$val, $default = null)
{
    return isset($val) ? $val : $default;
}

//    example usage
$id = intval(ifsetor($_GET['id'], 0));

?>
===============================================================================

Check out this ifsetor function. If $var is set, do nothing, otherwise $var =
$default.

<?php

$name = ifsetor($name, 'default name') ;

function ifsetor(&$var, $default)
    {
        return isset($var) ? $var : $default) ;
    }
   
?>
===============================================================================

Simple, but very useful:

<?php
function issetOr($var, $or = false) {
  return isset($var) ? $var : $or;
}
?>

Some examples:
<?php
$a = '1';
$b = '2';
echo issetOr($a,issetOr($b,3)); // 1
?>
<?php
$b = '2';
echo issetOr($a,issetOr($b,3)); // 2
?>
<?php
echo issetOr($a,issetOr($b,3)); // 3
?>
===============================================================================

Below a user by the name of Scott posted an isval() function; I just wanted to
point out a revision to his method since it's a bit lengthy for what it does.
The trick is to realize that a boolean AND clause will terminate with false as
soon as it encounters anything that evaluates to false, and will skip over any
remaining checks.

Instead of taking up the space to define isval(), you could just run inline
commands for each variable you need to check this:

<?php

$isval = isset($_POST['var']) && !empty($_POST['var']);

?>

Also be warned that if you try to encapsulate this into a function, you might
encounter problems. It's meant to stand alone.
===============================================================================

Before:

//ask, if is set
$number = isset($_GET['number']) ? $_GET['number'] : '';
$age = isset($_GET['age']) ? $_GET['age'] : '';
$street = isset($_GET['street']) ? $_GET['street'] : '';

After: --> it's easier to read

//ask, if is set
$parameter = array('number', 'age', 'street');
foreach($parameter as $name)
{
    $$name = isset($_GET[$name]) ? $_GET[$name] : '';
}
===============================================================================

if(isset($_POST['in_qu']))
          {

          include("qanda/in_qu.php");
          $content.=$message;
          include("qanda/view_qanda.php");
    }
elseif(isset($_GET['rq']))
          {
          include("qanda/add_answer.php");
    }
elseif(isset($_POST['add_answer']))
          {
          include("qanda/in_an.php");
          $content.=$message;
          include("qanda/view_qanda.php");
    }
elseif($_GET['act']== 'v_qanda' && !(isset($_GET['rq'])))
{
include("qanda/view_qanda.php");
}
/*
if(isset($_POST['add_answer']))
===============================================================================

just as note: if you want to check variables by boolean value: true or false ,
"isset" has a different meaning!
<?php
$var=null;
// sample 1
if($var) {
   // if true or another value exept "false" , "null": go on here
   echo "1. var is true or has a value $var<br>";
} else {
   echo "1. var is &quot;false&quot; or &quot;null&quot;<br>";
}

if(!$var) {
   // if false or "null": go on here
   echo "2. var has no value $var<br>";
} else {
   echo "2. var is &quot;false&quot; or &quot;null&quot;<br>";
}

// sample 2
$var =false;
if(isset($var)) {
  // $var is false so it is set to a value and the execution goes here
   echo "3. var has value: $var<br>";
}

$var=null;
if(!isset($var)) {
  // $var is null (does not exist at this time) and the execution goes here
   echo "4. var was not set $var<br>";
}
?>
===============================================================================

I know this is probably not the recommended way to do this, but it seems to
work fine for me. Instead of the normal isset check to extract variables from
arrays (like $_REQUEST), you can use the @ prefix to squelch any errors.

For example, instead of:
<?php
$test = isset($_REQUEST['test']) ? $_REQUEST['test'] : null;
?>
you can use:
<?php
$test = @$_REQUEST['test'];
?>

It saves some typing, but doesn't give the opportunity to provide a default
value. If 'test' is not an assigned key for $_REQUEST, the assigned value will
be null.
===============================================================================

Using
  isset($array['key'])
is useful, but be careful!
using
  isset($array['key']['subkey'])
doesn't work as one could expect, if $array['key'] is a string it seems that
'subkey' is converted to (integer) 0 and $array['key']['subkey'] is evaluated
as the first char of the string.
The solution is to use
  is_array($array['key']) && isset($array['key']['subkey'])

Here is a small code to show this:

<?php
$ex = array('one' => 'val1','two' => 'val2');
echo '$ex = ';print_r($ex);
echo "<br />";

echo " isset(\$ex['one']['three']) : ";
if (isset($ex['one']['three']))
    echo 'true';
else
    echo 'false';

echo "<br />";
echo "is_array(\$ex['one']) &&  isset(\$ex['one']['three']) : ";
if (is_array($ex['one']) && isset($ex['one']['three']))
    echo 'true';
else
    echo 'false';
?>

shows:
$ex = Array ( [one] => val1 [two] => val2 )
isset($ex['one']['three']) : true
is_array($ex['one']) && isset($ex['one']['three']) : false
===============================================================================

KISS: array_key_exists() is often the answer, not isset()
<?php
$array['secure'] = null;
if ( isset( $array['secure'] ) ) {
    // what happens here?
}?>
===============================================================================

This function is very useful while calling to the URL to specify which template
to be used on certain parts of your application.

Here is an example...

<?php

    $cat = $_GET['c'];
    $id = $_GET['id'];   
    $error = 'templates/error.tpl';

    if( isset($cat))
    {
        if( isset($id))
        {
            $var = 'templates/pics/' . $cat . '-' . $id . '.tpl';
            if (is_file($var))
            {
                include($var);
            }
            else
            {
                include($error);
            }
        }
        else
        {
            $var = 'templates/pics/' . $cat . '.tpl';       
            if (is_file($var))
            {
                include($var);
            }
            else
            {
                include($error);
            }
        }
    }
    else
    {
        include('templates/alternative.'.tpl);
    }

?>

You can see several uses of the isset function being used to specify wheter a
template is to be called upon or not.  This can easily prevent other generic
PHP errors.
===============================================================================

I've come up with a little not-so-clean but useful function to avoid checking
if a variable is set before reading its value, specially useful for $_REQUEST
and the like:

<?php
function toLocal( $source, &$dest, $default = null )
{
    if( isset( $source ) )
        $dest = $source;
    else
        $dest = $default;
}
?>

and then call it this way:
<?php
@toLocal( $_REQUEST['item_id'], $item_id, 0 );
?>

It checks wether the variable is set, copies it to a local variable, and if it
wasn't set, it assigns the new variable a default value, all in one line,
preventing you to have to always check for isset() before trying to read its
value.
Gotta call it with @ because if the variable is not set, then trying to pass it
as an argument will yield a warning.

Petruza.
===============================================================================

fyi:
you *cannot* do assignments inside of the isset() function. although you *can*
while inside of other functions such as is_null().

<?php
if (isset($var = $_GET['key'])) echo 'whatever'; //this will throw an error :(

if (is_null($var = $_GET['key'])) echo 'whatever'; //this will not :)
?>

hope someone finds this useful.
===============================================================================

Based on the previous post, I've found this code even more useful:

<?php
function isset_sum(&$var, $val) {
    if (isset($var))  $var += $val;
    else              $var  = $val;
}
?>

Now instead of:

<?php
if (isset($foo[$bar][$baz][$fooz])) $foo[$bar][$baz][$fooz] += $count;
else                                $foo[$bar][$baz][$fooz] = $count;
?>

No more "Undefined variable" warnings, and you save your fingers and sanity! 
Thanks to the previous poster for inspiration.
===============================================================================

Just to reiterate on what everyone has already said before, you should not use
wrapper functions for isset. Using a wrapper function will generate a Notice
unless you pass the unset variable by reference, in which case it is the
equivalent to writing using $var === null (which is a lot faster). Even if you
do pass the variable by reference, you could still get notices using
multidimensional arrays where isset() would silently return false.
===============================================================================

Since PHP will check cases in order, I often end up using this bit of code:

<?php
if (isset($var) && $var) {
    // do something
}
?>

In short, if you have error reporting on, and $var is not set, PHP will
generate an error if you just have:

<?php
if ($var) { // do something }
?>

...but, as noted elsewhere, will return True if set to False in this case:
<?php
if (isset($var)) { // do something }
?>

Checking both to see if $var is set, and that it equals something other than
Null or False is something I find very useful a lot of times.  If $var is not
set, PHP will never execute the second part of "(isset($var) && $var)", and
thus never generate an error either.

This also works very nice for setting variable as well, e.g.:
<?php
$var = (isset($var) && $var) ? $var : 'new value';
?>
===============================================================================

test:

<?php
$qnt=100000;
$k=array();
for ($i=0;$i<$qnt;$i++)
$k[$i]=1;

echo microtime()."\n";
for ($i=0;$i<$qnt;$i++)if(isset($k[$i]));
echo microtime()."\n";
for ($i=0;$i<$qnt;$i++)if(array_key_exists($i,$k));
echo microtime()."\n";
for ($i=0;$i<$qnt;$i++)if($k[$i]==1);
echo microtime()."\n";

?>

the interesting result:
isset is the fastest
===============================================================================

if you want to check whether the user has sent post vars from a form, it is a
pain to write something like the following, since isset() does not check for
zero-length strings:

if(isset($form_name) && $form_name != '') [...]

a shorter way would be this one:

if($form_name && $form_message) [...]

but this is dirty since you cannot make sure these variables exist and php will
echo a warning if you refer to a non-existing variable like this. plus, a
string containing "0" will evaluate to FALSE if casted to a boolean.

this function will check one or more form values if they are set and do not
contain an empty string. it returns false on the first empty or non-existing
post var.

<?
function postvars() {
    foreach(func_get_args() as $var) {
        if(!isset($_POST[$var]) || $_POST[$var] === '') return false;
    }
    return true;
}
?>

example: if(postvars('form_name','form_message')) [...]
===============================================================================

It is worth noting that in order to check for the existence of a key within an
array, regardless of it's contents one should use array_key_exists() not isset
(). 

isset() will (correctly) return false if the value of your array key is null,
which may be a perfectly valid condition.
===============================================================================

Here a short note on the function tomek wrote:
Don't use it, because it is still better to use !$var than !is($var).

Some comments on the body of the function:
<?php
function is($var)
{
if (!isset($var)) return false; # Variable is always set... Otherwise PHP would
have thrown an error on call.
if ($var!==false) return true; # So, 0, NULL, and some other values may not
behave like isNot? And what about the difference between a class and NULL?
return false;
}
?>

The reason why you shall not use this function:
Notice: Undefined variable: {variablename} in {file} on line {__LINE__}

It's me as plain as the nose on your face that the piece of code hasn't been
tested with E_NOTICE.

So my advice in this case is: don't use the above function, but simply use !,
and functions such like is_null in the situation they are made for.
===============================================================================

Useful to check if the variable have some value...specially for GET POST
variables

<?php
function isset_or(&$check, $alternate = NULL)
{
    return (isset($check)) ? (empty($check) ? $alternate : $check) : $alternate
;
}

function getGETPOST($var)
{
      return isset_or($_GET[$var],isset_or($_POST[$var],"Empty"));
}
?>

Example
echo getGETPOST('na'); //Find the na varriabl by get and post
===============================================================================

If you don't want to bother checking every single var with isset or empty, use
this function on every var you use:

<?php

function chk( & $var )
{
    if ( !isset($var) )
    {
        return NULL;
    }
    else
    {
        return $var;
    }
}

?>

It takes ANYTHING as argument, and returns the exact same thing, but without
Notice if the var doesn't actually exist
===============================================================================

This is very simple implementation of issetor() for PHP. It works like ?? in C
#, // in Perl (it can access undefined hash keys without it nevertheless) or ?
in CoffeeScript (also can access undefined hash keys too). You shouldn't use
directly $_GET['something'] (it can generate E_NOTICEs in case somebody would
try hacking your site), but isset($_GET['something']) ? $_GET['something'] : ''
is long for many people (for so common operation). This alternative makes using
superglobals easier.

<?php
function issetor(&$variable, $or = NULL) {
    return $variable === NULL ? $or : $variable;
}
?>

Now you can do:

<?php
echo issetor($_GET['a']);       // $_GET['a'] or NULL
echo issetor($_GET['b'], '42'); // $_GET['b'] or 42
echo issetor($_GET['c']['d']);  // $_GET['c']['d'] or NULL
?>

This code doesn't generate notices in case variable doesn't exist.
===============================================================================

If you have for example a variable in your URL say url.php?var= and some one
types in %00 the variable will pass isset. For post and get variables I wrote
this function to filter out varables that are set but empty.

function isval($inp){
    if(isset($inp)){
        $len = strlen($inp);
        if($len > 0){
            return true;
        }
        else{
            return false;
        }
    }
    else{
        return false;
    }
}
===============================================================================

according to the docs -- "isset() will return FALSE if testing a variable that
has been set to NULL."

That statment is not always correct, sometimes isset() returns TRUE for a NULL
value.  But the scenarios are obtuse.  There are a tons of bugs on this
subject, all marked as bogus.

Problems occur when NULLs are in named fields of arrays and also when vars are
passed by reference.

do lots of testing and code defensively.

is_null()   is your friend...
===============================================================================

Just a note on the previous users comments. isset() should only be used for
testing if the variable exists and not if the variable containes an empty ""
string. empty() is designed for that.

Also, as noted previosuly !empty() is the best method for testing for set
non-empty variables.
===============================================================================

When a variable is set and its values is null, isset() returns false.

You can use array_key_exists() to check whether a null value variable exists.

<?php
    $wxc = null;
    var_dump( isset( $wxc ) );
    var_dump( array_key_exists( 'wxc', $GLOBALS ) );
?>

Output of the above example:

bool(false) bool(true)
===============================================================================

Here is another way to check if you have any $_GET variable set.

<?php

if (sizeof($_GET) > 0)

{echo "There are $_GET variables.";}
else
{echo "There are no $_GET variables.";};

?>

Alternatively you could use the switch method.
===============================================================================

This could be viewed as a philosophy. I wonder why a NULL variabel is being
considered FALSE rather than TRUE while in isset, because if the variable has
been unset it becomes undefined but a NULL variabel is still defined although
it has no value. Or, perhaps, it's based on the memory usage, if it is how
about $x="" ? Is empty value use memory too? This leads me to another thinking
that the isset isn't have family relationship with unset although both of it
are a language construct and have 'set' word :)
===============================================================================

Return Values :
Returns TRUE if var exists and has value other than NULL, FALSE otherwise.

<?php
$a=NULL;
$b=FALSE; //The out put was TRUE.
$c=TRUE;
$d='';
$e="";
if(isset($b)):
echo "TRUE";
else:
echo "FALSE";   
endif;
?>
Could any one explain me in clarity.
