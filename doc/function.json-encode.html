
json_encode

(PHP 5 >= 5.2.0, PECL json >= 1.2.0, PHP 7)

json_encode — 对变量进行 JSON 编码

说明

string json_encode ( mixed $value [, int $options = 0 [, int $depth = 512 ]] )

返回 value 值的 JSON 形式

参数

value

    待编码的 value ，除了resource 类型之外，可以为任何数据类型

    该函数只能接受 UTF-8 编码的数据

        Note:

        PHP implements a superset of JSON as specified in the original » RFC
        4627 - it will also encode and decode scalar types and NULL. RFC 4627
        only supports these values when they are nested inside an array or an
        object.

        Although this superset is consistent with the expanded definition of
        "JSON text" in the newer » RFC 7159 (which aims to supersede RFC 4627)
        and » ECMA-404, this may cause interoperability issues with older JSON
        parsers that adhere strictly to RFC 4627 when encoding a single scalar
        value.

options

    由以下常量组成的二进制掩码： JSON_HEX_QUOT, JSON_HEX_TAG, JSON_HEX_AMP,
    JSON_HEX_APOS, JSON_NUMERIC_CHECK, JSON_PRETTY_PRINT,
    JSON_UNESCAPED_SLASHES, JSON_FORCE_OBJECT, JSON_PRESERVE_ZERO_FRACTION,
    JSON_UNESCAPED_UNICODE, JSON_PARTIAL_OUTPUT_ON_ERROR。关于 JSON 常量详情参
    考JSON 常量页面。

depth

    设置最大深度。必须大于0。

返回值

成功则返回 JSON 编码的 string 或者在失败时返回 FALSE 。

更新日志

版本                                    说明
5.6.6 options 参数增加常量： JSON_PRESERVE_ZERO_FRACTION
5.5.0 增加 depth 参数。
5.4.0 options 参数增加常量： JSON_PRETTY_PRINT, JSON_UNESCAPED_SLASHES, 和
      JSON_UNESCAPED_UNICODE。
5.3.3 options 参数增加常量：JSON_NUMERIC_CHECK。
5.3.0 增加 options 参数.

范例

Example #1 json_encode() 例子

<?php
$arr = array ('a'=>1,'b'=>2,'c'=>3,'d'=>4,'e'=>5);

echo json_encode($arr);
?>

以上例程会输出：

{"a":1,"b":2,"c":3,"d":4,"e":5}

Example #2 json_encode() 函数中 options 参数的用法

<?php
$a = array('<foo>',"'bar'",'"baz"','&blong&', "\xc3\xa9");

echo "Normal: ",  json_encode($a), "\n";
echo "Tags: ",    json_encode($a, JSON_HEX_TAG), "\n";
echo "Apos: ",    json_encode($a, JSON_HEX_APOS), "\n";
echo "Quot: ",    json_encode($a, JSON_HEX_QUOT), "\n";
echo "Amp: ",     json_encode($a, JSON_HEX_AMP), "\n";
echo "Unicode: ", json_encode($a, JSON_UNESCAPED_UNICODE), "\n";
echo "All: ",     json_encode($a, JSON_HEX_TAG | JSON_HEX_APOS | JSON_HEX_QUOT 
| JSON_HEX_AMP | JSON_UNESCAPED_UNICODE), "\n\n";

$b = array();

echo "Empty array output as array: ", json_encode($b), "\n";
echo "Empty array output as object: ", json_encode($b, JSON_FORCE_OBJECT), "\n\
n";

$c = array(array(1,2,3));

echo "Non-associative array output as array: ", json_encode($c), "\n";
echo "Non-associative array output as object: ", json_encode($c, 
JSON_FORCE_OBJECT), "\n\n";

$d = array('foo' => 'bar', 'baz' => 'long');

echo "Associative array always output as object: ", json_encode($d), "\n";
echo "Associative array always output as object: ", json_encode($d, 
JSON_FORCE_OBJECT), "\n\n";
?>

以上例程会输出：

Normal: ["<foo>","'bar'","\"baz\"","&blong&","\u00e9"]
Tags: ["\u003Cfoo\u003E","'bar'","\"baz\"","&blong&","\u00e9"]
Apos: ["<foo>","\u0027bar\u0027","\"baz\"","&blong&","\u00e9"]
Quot: ["<foo>","'bar'","\u0022baz\u0022","&blong&","\u00e9"]
Amp: ["<foo>","'bar'","\"baz\"","\u0026blong\u0026","\u00e9"]
Unicode: ["<foo>","'bar'","\"baz\"","&blong&","é"]
All: ["\u003Cfoo\u003E","\u0027bar\u0027","\u0022baz\u0022","\u0026blong\u0026","é"]

Empty array output as array: []
Empty array output as object: {}

Non-associative array output as array: [[1,2,3]]
Non-associative array output as object: {"0":{"0":1,"1":2,"2":3}}

Associative array always output as object: {"foo":"bar","baz":"long"}
Associative array always output as object: {"foo":"bar","baz":"long"}

Example #3 选项 JSON_NUMERIC_CHECK 例子

<?php
echo "Strings representing numbers automatically turned into numbers".PHP_EOL;
$numbers = array('+123123', '-123123', '1.2e3', '0.00001');
var_dump(
 $numbers,
 json_encode($numbers, JSON_NUMERIC_CHECK)
);
echo "Strings containing improperly formatted numbers".PHP_EOL;
$strings = array('+a33123456789', 'a123');
var_dump(
 $strings,
 json_encode($strings, JSON_NUMERIC_CHECK)
);
?>

以上例程会输出：

Strings representing numbers automatically turned into numbers
array(4) {
  [0]=>
  string(7) "+123123"
  [1]=>
  string(7) "-123123"
  [2]=>
  string(5) "1.2e3"
  [3]=>
  string(7) "0.00001"
}
string(28) "[123123,-123123,1200,1.0e-5]"
Strings containing improperly formatted numbers
array(2) {
  [0]=>
  string(13) "+a33123456789"
  [1]=>
  string(4) "a123"
}
string(24) "["+a33123456789","a123"]"

Example #4 连续与非连续数组示例

<?php
echo "连续数组".PHP_EOL;
$sequential = array("foo", "bar", "baz", "blong");
var_dump(
 $sequential,
 json_encode($sequential)
);

echo PHP_EOL."非连续数组".PHP_EOL;
$nonsequential = array(1=>"foo", 2=>"bar", 3=>"baz", 4=>"blong");
var_dump(
 $nonsequential,
 json_encode($nonsequential)
);

echo PHP_EOL."删除一个连续数组值的方式产生的非连续数组".PHP_EOL;
unset($sequential[1]);
var_dump(
 $sequential,
 json_encode($sequential)
);
?>

以上例程会输出：

连续数组
array(4) {
  [0]=>
  string(3) "foo"
  [1]=>
  string(3) "bar"
  [2]=>
  string(3) "baz"
  [3]=>
  string(5) "blong"
}
string(27) "["foo","bar","baz","blong"]"

非连续数组
array(4) {
  [1]=>
  string(3) "foo"
  [2]=>
  string(3) "bar"
  [3]=>
  string(3) "baz"
  [4]=>
  string(5) "blong"
}
string(43) "{"1":"foo","2":"bar","3":"baz","4":"blong"}"

删除一个连续数组值的方式产生的非连续数组
array(3) {
  [0]=>
  string(3) "foo"
  [2]=>
  string(3) "baz"
  [3]=>
  string(5) "blong"
}
string(33) "{"0":"foo","2":"baz","3":"blong"}"

Example #5 选项 JSON_PRESERVE_ZERO_FRACTION 的例子

<?php
var_dump(json_encode(12.0, JSON_PRESERVE_ZERO_FRACTION));
var_dump(json_encode(12.0));
?>

以上例程会输出：

string(4) "12.0"
string(2) "12"

注释

    Note:

    如果执行失败，可以通过 json_last_error() 函数来获取详细错误信息。

    Note:

    如果要编码的数组的键不是从0开始的数字，所有的键将会被当作字符串，并明确声明
    为 key-value 对。

    Note:

    Like the reference JSON encoder, json_encode() will generate JSON that is a
    simple value (that is, neither an object nor an array) if given a string, 
    integer, float or boolean as an input value. While most decoders will
    accept these values as valid JSON, some may not, as the specification is
    ambiguous on this point.

    To summarise, always test that your JSON decoder can handle the output you
    generate from json_encode().

参见

  • JsonSerializable
  • json_decode() - 对 JSON 格式的字符串进行解码
  • json_last_error() - 返回最后发生的错误
  • serialize() - 产生一个可存储的值的表示


User Contributed Notes 68 notes

===============================================================================

Are you sure you want to use JSON_NUMERIC_CHECK, really really sure?

Just watch this usecase:

<?php
// International phone number
json_encode(array('phone_number' => '+33123456789'), JSON_NUMERIC_CHECK);
?>

And then you get this JSON:

{"phone_number":33123456789}

Maybe it makes sense for PHP (as is_numeric('+33123456789') returns true), but
really, casting it as an int?!

So be careful when using JSON_NUMERIC_CHECK, it may mess up with your data!
===============================================================================

Solution for UTF-8 Special Chars.

<?

$array = array('nome'=>'Paição','cidade'=>'São Paulo');

$array = array_map('htmlentities',$array);

//encode
$json = html_entity_decode(json_encode($array));

//Output: {"nome":"Paição","cidade":"São Paulo"}
echo $json;

?>
===============================================================================

Hey everyone,

In my application, I had objects that modeled database rows with a few one to
many relationships, so one object may have an array of other objects.

I wanted to make the object properties private and use getters and setters, but
I needed them to be serializable to json without losing the private variables.
(I wanted to promote good coding practices but I needed the properties on the
client side.) Because of this, I needed to encode not only the normal private
properties but also properties that were arrays of other model objects. I
looked for awhile with no luck, so I coded my own:

You can place these methods in each of your classes, or put them in a base
class, as I've done. (But note that for this to work, the children classes must
declare their properties as protected so the parent class has access)

<?php
abstract class Model {
  
   public function toArray() {
        return $this->processArray(get_object_vars($this));
    }
   
    private function processArray($array) {
        foreach($array as $key => $value) {
            if (is_object($value)) {
                $array[$key] = $value->toArray();
            }
            if (is_array($value)) {
                $array[$key] = $this->processArray($value);
            }
        }
        // If the property isn't an object or array, leave it untouched
        return $array;
    }
   
    public function __toString() {
        return json_encode($this->toArray());
    }
  
}
?>

Externally, you can just call

<?php
    echo $theObject;
    //or
    echo json_encode($theObject->toArray());
?>

And you'll get the json for that object. Hope this helps someone!
===============================================================================

This is intended to be a simple readable json encode function for PHP 5.3+ (and
licensed under GNU/AGPLv3 or GPLv3 like you prefer):

<?php

function json_readable_encode($in, $indent = 0, $from_array = false)
{
    $_myself = __FUNCTION__;
    $_escape = function ($str)
    {
        return preg_replace("!([\b\t\n\r\f\"\\'])!", "\\\\\\1", $str);
    };

    $out = '';

    foreach ($in as $key=>$value)
    {
        $out .= str_repeat("\t", $indent + 1);
        $out .= "\"".$_escape((string)$key)."\": ";

        if (is_object($value) || is_array($value))
        {
            $out .= "\n";
            $out .= $_myself($value, $indent + 1);
        }
        elseif (is_bool($value))
        {
            $out .= $value ? 'true' : 'false';
        }
        elseif (is_null($value))
        {
            $out .= 'null';
        }
        elseif (is_string($value))
        {
            $out .= "\"" . $_escape($value) ."\"";
        }
        else
        {
            $out .= $value;
        }

        $out .= ",\n";
    }

    if (!empty($out))
    {
        $out = substr($out, 0, -2);
    }

    $out = str_repeat("\t", $indent) . "{\n" . $out;
    $out .= "\n" . str_repeat("\t", $indent) . "}";

    return $out;
}

?>
===============================================================================

If you need pretty-printed output, but want it indented by 2 spaces instead of
4:

$json_indented_by_4 = json_encode($output, JSON_UNESCAPED_SLASHES|
JSON_PRETTY_PRINT);
$json_indented_by_2 = preg_replace('/^(  +?)\\1(?=[^ ])/m', '$1',
$json_indented_by_4);
===============================================================================

Because json_encode() only deals with utf8, it is often necessary to convert
all the string values inside an array to utf8. I've created these two
functions:   

<?php
function utf8_encode_all($dat) // -- It returns $dat encoded to UTF8
{
  if (is_string($dat)) return utf8_encode($dat);
  if (!is_array($dat)) return $dat;
  $ret = array();
  foreach($dat as $i=>$d) $ret[$i] = utf8_encode_all($d);
  return $ret;
}
/* ....... */

function utf8_decode_all($dat) // -- It returns $dat decoded from UTF8
{
  if (is_string($dat)) return utf8_decode($dat);
  if (!is_array($dat)) return $dat;
  $ret = array();
  foreach($dat as $i=>$d) $ret[$i] = utf8_decode_all($d);
  return $ret;
}
/* ....... */
?>
===============================================================================

This function has weird behavior regarding error reporting in PHP version 5.4
or lower. This kind of warning is raised only if you configure PHP with
"display_errors=Off" (!?): "PHP Warning:  json_encode(): Invalid UTF-8 sequence
in argument ..."

You can reproduce this behavior:
<?php
// Warning not displayed, not logged
ini_set('display_errors', '1');
json_encode(urldecode('bad utf string %C4_'));

// Warning not displayed but logged
ini_set('display_errors', '0');
json_encode(urldecode('bad utf string %C4_'));
?>

This is considered feature - not-a-bug - by PHP devs:
https://bugs.php.net/bug.php?id=52397
https://bugs.php.net/bug.php?id=63004
===============================================================================

For users of php 5.1.6 or lower, a native json_encode function. This version
handles objects, and makes proper distinction between [lists] and {associative
arrays}, mixed arrays work as well. It can handle newlines and quotes in both
keys and data.

This function will convert non-ascii symbols to "\uXXXX" format as does
json_encode.

Besides that, it outputs exactly the same string as json_encode. Including
UTF-8 encoded 2-, 3- and 4-byte characters. It is a bit faster than PEAR/
JSON::encode, but still slow compared to php 5.3's json_encode. It encodes any
variable type exactly as the original.

Relative speeds:
PHP json_encode: 1x
__json_encode: 31x
PEAR/JSON: 46x

NOTE: I assume the input will be valid UTF-8. I don't know what happens if your
data contains illegal Unicode sequences. I tried to make the code fast and
compact.

<?php
function __json_encode( $data ) {           
    if( is_array($data) || is_object($data) ) {
        $islist = is_array($data) && ( empty($data) || array_keys($data) === 
range(0,count($data)-1) );
       
        if( $islist ) {
            $json = '[' . implode(',', array_map('__json_encode', $data) ) . ']
';
        } else {
            $items = Array();
            foreach( $data as $key => $value ) {
                $items[] = __json_encode("$key") . ':' . __json_encode($value);
            }
            $json = '{' . implode(',', $items) . '}';
        }
    } elseif( is_string($data) ) {
        # Escape non-printable or Non-ASCII characters.
        # I also put the \\ character first, as suggested in comments on the
'addclashes' page.
        $string = '"' . addcslashes($data, "\\\"\n\r\t/" . chr(8) . chr(12)) . 
'"';
        $json    = '';
        $len    = strlen($string);
        # Convert UTF-8 to Hexadecimal Codepoints.
        for( $i = 0; $i < $len; $i++ ) {
           
            $char = $string[$i];
            $c1 = ord($char);
           
            # Single byte;
            if( $c1 <128 ) {
                $json .= ($c1 > 31) ? $char : sprintf("\\u%04x", $c1);
                continue;
            }
           
            # Double byte
            $c2 = ord($string[++$i]);
            if ( ($c1 & 32) === 0 ) {
                $json .= sprintf("\\u%04x", ($c1 - 192) * 64 + $c2 - 128);
                continue;
            }
           
            # Triple
            $c3 = ord($string[++$i]);
            if( ($c1 & 16) === 0 ) {
                $json .= sprintf("\\u%04x", (($c1 - 224) <<12) + (($c2 - 128)
<< 6) + ($c3 - 128));
                continue;
            }
               
            # Quadruple
            $c4 = ord($string[++$i]);
            if( ($c1 & 8 ) === 0 ) {
                $u = (($c1 & 15) << 2) + (($c2>>4) & 3) - 1;
           
                $w1 = (54<<10) + ($u<<6) + (($c2 & 15) << 2) + (($c3>>4) & 3);
                $w2 = (55<<10) + (($c3 & 15)<<6) + ($c4-128);
                $json .= sprintf("\\u%04x\\u%04x", $w1, $w2);
            }
        }
    } else {
        # int, floats, bools, null
        $json = strtolower(var_export( $data, true ));
    }
    return $json;
}
?>

[EDIT BY danbrown AT php DOT net: Contains a bugfix by the original poster on
08-DEC-2010 with the following message: "I discovered a rather bad bug in my
__json_encode function below. On versions prior to php 5.2.5, all 'f'
characters are escaped to '\f'. This is because addcslashes in php < 5.2
doesn't understand \f as 'formfeed'."]
===============================================================================

A note of caution: If you are wondering why json_encode() encodes your PHP
array as a JSON object instead of a JSON array, you might want to double check
your array keys because json_encode() assumes that you array is an object if
your keys are not sequential.

e.g.:

<?php
$myarray = Array('isa', 'dalawa', 'tatlo');
var_dump($myarray);
/* output
array(3) {
  [0]=>
  string(3) "isa"
  [1]=>
  string(6) "dalawa"
  [2]=>
  string(5) "tatlo"
}
*/
?>

As you can see, the keys are sequential; $myarray will be correctly encoded as
a JSON array.

<?php
$myarray = Array('isa', 'dalawa', 'tatlo');

unset($myarray[1]);
var_dump($myarray);
/* output
array(2) {
  [0]=>
  string(3) "isa"
  [2]=>
  string(5) "tatlo"
}
*/
?>

Unsetting an element will also remove the keys. json_encode() will now assume
that this is an object, and will encode it as such.

SOLUTION: Use array_values() to re-index the array.
===============================================================================

Although this is not documented on the version log here, non-UTF8 handling
behaviour has changed in 5.5, in a way that can make debugging difficult.

Passing a non UTF-8 string to json_encode() will make the function return false
in PHP 5.5, while it will only nullify this string (and only this one) in
previous versions.

In a Latin-1 encoded file, write this:
<?php
$a = array('é', 1);
var_dump(json_encode($a));
?>

PHP < 5.4:
string(8) "[null,1]"

PHP >= 5.5:
bool(false)

PHP 5.5 has it right of course (if encoding fails, return false) but its likely
to introduce errors when updating to 5.5 because previously you could get the
rest of the JSON even when one string was not in UTF8 (if this string wasn't
used, you'd never notify it's nulled)
===============================================================================

For PHP5.3 users who want to emulate JSON_UNESCAPED_UNICODE, there is simple
way to do it:
<?php
function my_json_encode($arr)
{
        //convmap since 0x80 char codes so it takes all multibyte codes (above
ASCII 127). So such characters are being "hidden" from normal json_encoding
        array_walk_recursive($arr, function (&$item, $key) { if (is_string(
$item)) $item = mb_encode_numericentity($item, array (0x80, 0xffff, 0, 0xffff),
'UTF-8'); });
        return mb_decode_numericentity(json_encode($arr), array (0x80, 0xffff, 
0, 0xffff), 'UTF-8');

}
?>
===============================================================================

Note that if you try to encode an array containing non-utf values, you'll get
null values in the resulting JSON string.  You can batch-encode all the
elements of an array with the array_map function:
<?php
$encodedArray = array_map(utf8_encode, $rawArray);
?>
===============================================================================

If you need to force an object (ex: empty array) you can also do:

         <?php json_encode( (object)$arr ); ?>

which acts the same as

         <?php json_encode($arr, JSON_FORCE_OBJECT); ?>
===============================================================================

If you are planning on using this function to serve a json file, it's important
to note that the json generated by this function is not ready to be consumed by
javascript until you wrap it in parens and add ";" to the end.

It took me a while to figure this out so I thought I'd save others the
aggravation.

<?php
    header('Content-Type: text/javascript; charset=utf8');
    header('Access-Control-Allow-Origin: http://www.example.com/');
    header('Access-Control-Max-Age: 3628800');
    header('Access-Control-Allow-Methods: GET, POST, PUT, DELETE');
   
    $file='rss.xml';
    $arr = simplexml_load_file($file);//this creates an object from the xml
file
    $json= '('.json_encode($arr).');'; //must wrap in parens and end with
semicolon
    print_r($_GET['callback'].$json); //callback is prepended for json-p
?>
===============================================================================

This may help others who are seeing null strings returned by json_encode().

This function will encode all array values to utf8 so they are safe for
json_encode();

usage:

<?php
json_encode(utf8json($dataArray));

function utf8json($inArray) {

    static $depth = 0;

    /* our return object */
    $newArray = array();

    /* safety recursion limit */
    $depth ++;
    if($depth >= '30') {
        return false;
    }

    /* step through inArray */
    foreach($inArray as $key=>$val) {
        if(is_array($val)) {
            /* recurse on array elements */
            $newArray[$key] = utf8json($val);
        } else {
            /* encode string values */
            $newArray[$key] = utf8_encode($val);
        }
    }

    /* return utf8 encoded array */
    return $newArray;
}
?>

[NOTE BY danbrown AT php DOT net: Includes a bugfix by (robbiz233 AT hotmail
DOT com) on 18-SEP-2010, to replace:
    $newArray[$key] = utf8json($inArray);
with:
    $newArray[$key] = utf8json($val);"
in the given function.]
===============================================================================

<?php

$fp = fopen('php://stdin', 'r');
$json = @json_encode(array('a' => 'foo', 'b' => $fp));
var_dump($json);

?>

[PHP5.5 or after]
bool(false)

[PHP 5.4 or before]
string(20) "{"a":"foo","b":null}"
===============================================================================

If you're wondering whether a JSON string can be an analog of an XML document,
the answer is probably "nope."  XML supports attributes, but JSON does not.  A
JSON string generated by json_encode(), when called on a SimpleXML object, will
not have the attributes and no error or exception will issue - the original
data will simply be lost.  To see this in action:
<?php
error_reporting(E_ALL);
echo '<pre>';

// STARTING FROM XML
$xml = <<<EOD
<?xml version="1.0" ?>
<ingredients>
  <ingredient>
     <name>tomatoes</name>
     <quantity type="cup">4</quantity>
  </ingredient>
  <ingredient>
     <name>salt</name>
     <quantity type="tablespoon">2</quantity>
  </ingredient>
</ingredients>
EOD;

// CREATES AN ARRAY OF SimpleXMLElement OBJECTS
$obj = SimpleXML_Load_String($xml);
var_dump($obj);
echo PHP_EOL;

// SHOW THE ATTRIBUTES HIDDEN IN THE SimpleXMLElement OBJECTS
foreach ($obj as $sub)
{
    echo PHP_EOL . (string)$sub->quantity . ' ' . (string)$sub->quantity['type'
];
}
echo PHP_EOL;

// USING THE OBJECT, CREATE A JSON STRING
$jso = json_encode($obj);
echo htmlentities($jso); // 'type' IS LOST
echo PHP_EOL;
===============================================================================

json and utf8?

Fast Easy Method:)

Encode: json_encode(array_map('base64_encode', $array));

Decode: array_map('base64_decode', json_decode($array);
===============================================================================

Be careful with floating values in some locales (e.g. russian) with comma (",")
as decimal point. Code:

<?php
setlocale(LC_ALL, 'ru_RU.utf8');

$arr = array('element' => 12.34);
echo json_encode( $arr );
?>

Output will be:
--------------
{"element":12,34}
--------------

Which is NOT a valid JSON markup. You should convert floating point variable to
strings or set locale to something like "LC_NUMERIC, 'en_US.utf8'" before using
json_encode.
===============================================================================

As json_encode() is recursive, you can use it to serialize whole structure of
objects.

<?php
class A {
    public $a = 1;
    public $b = 2;
    public $collection = array();

    function  __construct(){
        for ( $i=3; $i-->0;){
            array_push($this->collection, new B);
        }
    }
}

class B {
    public $a = 1;
    public $b = 2;
}

echo json_encode(new A);
?>

Will give:

{
    "a":1,
    "b":2,
    "collection":[{
        "a":1,
        "b":2
    },{
        "a":1,
        "b":2
    },{
        "a":1,
        "b":2
    }]
}
===============================================================================

I came across the "bug" where running json_encode() over a SimpleXML object was
ignoring the CDATA. I ran across http://bugs.php.net/42001 and http://
bugs.php.net/41976, and while I agree with the poster that the documentation
should clarify gotchas like this, I was able to figure out how to workaround
it.

You need to convert the SimpleXML object back into an XML string, then
re-import it back into SimpleXML using the LIBXML_NOCDATA option. Once you do
this, then you can use json_encode() and still get back the CDATA.

<?php
// Pretend we already have a complex SimpleXML object stored in $xml
$json = json_encode(new SimpleXMLElement($xml->asXML(), LIBXML_NOCDATA));
?>
===============================================================================

<?php

// alternative json_encode
function _json_encode($val)
{
    if (is_string($val)) return '"'.addslashes($val).'"';
    if (is_numeric($val)) return $val;
    if ($val === null) return 'null';
    if ($val === true) return 'true';
    if ($val === false) return 'false';

    $assoc = false;
    $i = 0;
    foreach ($val as $k=>$v){
        if ($k !== $i++){
            $assoc = true;
            break;
        }
    }
    $res = array();
    foreach ($val as $k=>$v){
        $v = _json_encode($v);
        if ($assoc){
            $k = '"'.addslashes($k).'"';
            $v = $k.':'.$v;
        }
        $res[] = $v;
    }
    $res = implode(',', $res);
    return ($assoc)? '{'.$res.'}' : '['.$res.']';
}

?>

Example:
Array
(
    [0] => 7
    [1] => false
    [2] => Array
        (
            ['a'] => Array
                (
                    [0] => 1
                    [1] => 2
                    [3] => Array
                        (
                            [1] => true
                            [2] => 6
                            [0] => 4
                        )
                    [4] => Array
                        (
                            [0] => 'b'
                            [1] => null
                        )
                )
        )
)
Result: [7,false,{"a":{"0":1,"1":2,"3":{"1":true,"2":6,"0":4},"4":["b",null]}}]

This function is more accurate and faster than, for example, that one:
http://www.php.net/manual/ru/function.json-encode.php#89908
(RU: эта функция работает более точно и быстрее, чем указанная выше).
===============================================================================

WARNING! Do not pass associative arrays if the order is important to you. It
seems that while FireFox does keep the same order, both Chrome and IE sort it.
Here's a little workaround:

<?php
        $arWrapper = array();       
        $arWrapper['k'] = array_keys($arChoices);
        $arWrapper['v'] = array_values($arChoices);
        $json = json_encode($arWrapper);
?>
===============================================================================

For anyone who would like to encode arrays into JSON, but is using PHP 4, and
doesn't want to wrangle PECL around, here is a function I wrote in PHP4 to
convert nested arrays into JSON.

Note that, because javascript converts JSON data into either nested named
objects OR vector arrays, it's quite difficult to represent mixed PHP arrays
(arrays with both numerical and associative indexes) well in JSON. This
function does something funky if you pass it a mixed array -- see the comments
for details.

I don't make a claim that this function is by any means complete (for example,
it doesn't handle objects) so if you have any improvements, go for it.

<?php

/**
* Converts an associative array of arbitrary depth and dimension into JSON
representation.
*
* NOTE: If you pass in a mixed associative and vector array, it will prefix
each numerical
* key with "key_". For example array("foo", "bar" => "baz") will be translated
into
* {"key_0": "foo", "bar": "baz"} but array("foo", "bar") would be translated
into [ "foo", "bar" ].
*
* @param $array The array to convert.
* @return mixed The resulting JSON string, or false if the argument was not an
array.
* @author Andy Rusterholz
*/
function array_to_json( $array ){

    if( !is_array( $array ) ){
        return false;
    }

    $associative = count( array_diff( array_keys($array), array_keys( 
array_keys( $array )) ));
    if( $associative ){

        $construct = array();
        foreach( $array as $key => $value ){

            // We first copy each key/value pair into a staging array,
            // formatting each key and value properly as we go.

            // Format the key:
            if( is_numeric($key) ){
                $key = "key_$key";
            }
            $key = '"'.addslashes($key).'"';

            // Format the value:
            if( is_array( $value )){
                $value = array_to_json( $value );
            } else if( !is_numeric( $value ) || is_string( $value ) ){
                $value = '"'.addslashes($value).'"';
            }

            // Add to staging array:
            $construct[] = "$key: $value";
        }

        // Then we collapse the staging array into the JSON form:
        $result = "{ " . implode( ", ", $construct ) . " }";

    } else { // If the array is a vector (not associative):

        $construct = array();
        foreach( $array as $value ){

            // Format the value:
            if( is_array( $value )){
                $value = array_to_json( $value );
            } else if( !is_numeric( $value ) || is_string( $value ) ){
                $value = '"'.addslashes($value).'"';
            }

            // Add to staging array:
            $construct[] = $value;
        }

        // Then we collapse the staging array into the JSON form:
        $result = "[ " . implode( ", ", $construct ) . " ]";
    }

    return $result;
}

?>
===============================================================================

json_encode($binary) problem: it results in an empty string "" without error.

You will see this happening when encoding binary images, for example.

Use utf8_encode first.

<?php

    $data = 'éáíúűóüöäÍÓ';
    $json = json_encode( utf8_encode($data) );

    // [..]

    $data = utf8_decode( json_decode($json) );

?>
===============================================================================

A note about json_encode automatically quoting numbers:

It appears that the json_encode function pays attention to the data type of the
value. Let me explain what we came across:

We have found that when retrieving data from our database, there are occasions
when numbers appear as strings to json_encode which results in double quotes
around the values.

This can lead to problems within javascript functions expecting the values to
be numeric.

This was discovered when were were retrieving fields from the database which
contained serialized arrays. After unserializing them and sending them through
the json_encode function the numeric values in the original array were now
being treated as strings and showing up with double quotes around them.

The fix: Prior to encoding the array, send it to a function which checks for
numeric types and casts accordingly. Encoding from then on worked as expected.
===============================================================================

If, for some reason you need to force a single object to be an array, you can
use array_values() -- this can be necessary if you have an array with only one
entry, as json_encode will assign it as an object otherwise :

<?php
$object[0] = array("foo" => "bar", 12 => true);

$encoded_object = json_encode($object);
?>

output:

{"1": {"foo": "bar", "12": "true"}}

<?php $encoded = json_encode(array_values($object)); ?>

output:

[{"foo": "bar", "12": "true"}]
===============================================================================

So i like to use ISO-8859-1 and a lot of åäöÅÄÖ and not that much for UTF-8 but
i need some json stuff so this is what I'm trying to use this lite thing i
made...

<?php
function my_json_encode($in) {
  $_escape = function ($str) {
    return addcslashes($str, "\v\t\n\r\f\"\\/");
  };
  $out = "";
  if (is_object($in)) {
    $class_vars = get_object_vars(($in));
    $arr = array();
    foreach ($class_vars as $key => $val) {
      $arr[$key] = "\"{$_escape($key)}\":\"{$val}\"";
    }
    $val = implode(',', $arr);
    $out .= "{{$val}}";
  }elseif (is_array($in)) {
    $obj = false;
    $arr = array();
    foreach($in AS $key => $val) {
      if(!is_numeric($key)) {
        $obj = true;
      }
      $arr[$key] = my_json_encode($val);
    }
    if($obj) {
      foreach($arr AS $key => $val) {
        $arr[$key] = "\"{$_escape($key)}\":{$val}";
      }
      $val = implode(',', $arr);
      $out .= "{{$val}}";
    }else {
      $val = implode(',', $arr);
      $out .= "[{$val}]";
    }
  }elseif (is_bool($in)) {
    $out .= $in ? 'true' : 'false';
  }elseif (is_null($in)) {
    $out .= 'null';
  }elseif (is_string($in)) {
    $out .= "\"{$_escape($in)}\"";
  }else {
    $out .= $in;
  }
  return "{$out}";
}
?>

have fun make money off it or what you like with you code... this is for
everyone...
===============================================================================

Beware of index arrays :

<?php
echo json_encode(array("test","test","test"));
echo json_encode(array(0=>"test",3=>"test",7=>"test"));
?>

Will give :

["test","test","test"]
{"0":"test","3":"test","7":"test"}

arrays are returned only if you don't define index.
===============================================================================

If I want to encode object whith all it's private and protected properties,
then I implements that methods in my object:

<?php
public function encodeJSON()
{
    foreach ($this as $key => $value)
    {
        $json->$key = $value;
    }
    return json_encode($json);
}
public function decodeJSON($json_str)
{
    $json = json_decode($json_str, 1);
    foreach ($json as $key => $value)
    {
        $this->$key = $value;
    }
}
?>

Or you may extend your class from base class, wich is implements that methods.

Found that much more simple than regular expressions with PHP serialized
objects...
===============================================================================

Note that this function does not always produce legal JSON.

<?php
$json = json_encode('foo');
var_dump($json);
//string(5) ""foo""

$json = json_encode(23);
var_dump($json);
//string(2) "23"
?>

According to the JSON spec, only objects and arrays can be represented; the
JSON_FORCE_OBJECT flag available since PHP 5.3 does not change this behaviour.
If you're using this to produce JSON that will be exchanged with other systems,
adjust your output accordingly.

<?php
$json = preg_replace('/^([^[{].*)$/', '[$1]', $json);
?>

The json_decode function accepts these JSON fragments without complaint.
===============================================================================

Here's a quick function to pretty-print some JSON. Optimizations welcome, as
this was a 10-minute dealie without efficiency in mind:

<?php
// Pretty print some JSON
function json_format($json)
{
    $tab = "  ";
    $new_json = "";
    $indent_level = 0;
    $in_string = false;

    $json_obj = json_decode($json);

    if($json_obj === false)
        return false;

    $json = json_encode($json_obj);
    $len = strlen($json);

    for($c = 0; $c < $len; $c++)
    {
        $char = $json[$c];
        switch($char)
        {
            case '{':
            case '[':
                if(!$in_string)
                {
                    $new_json .= $char . "\n" . str_repeat($tab, $indent_level+
1);
                    $indent_level++;
                }
                else
                {
                    $new_json .= $char;
                }
                break;
            case '}':
            case ']':
                if(!$in_string)
                {
                    $indent_level--;
                    $new_json .= "\n" . str_repeat($tab, $indent_level) . $char
;
                }
                else
                {
                    $new_json .= $char;
                }
                break;
            case ',':
                if(!$in_string)
                {
                    $new_json .= ",\n" . str_repeat($tab, $indent_level);
                }
                else
                {
                    $new_json .= $char;
                }
                break;
            case ':':
                if(!$in_string)
                {
                    $new_json .= ": ";
                }
                else
                {
                    $new_json .= $char;
                }
                break;
            case '"':
                if($c > 0 && $json[$c-1] != '\\')
                {
                    $in_string = !$in_string;
                }
            default:
                $new_json .= $char;
                break;                   
        }
    }

    return $new_json;
}
?>
===============================================================================

note that although PHP bundles JSON, some linux distributions do not do to a
licensing conflict.  As such you may need to install json support yourself.

IE: on Ubuntu 13.10 Saucy Salamander apt-get install php5-json re-enables json
support (json_encode and json_decode)
===============================================================================

When you have trouble with json_encode and German umlauts. json_encode converts
Strings to NULL when detecting umlauts not being UTF8encoded.

Here's another recursive UTF8 conversion function and vice-versa. The object
handling might be buggy but works for me.

<?php
function array_utf8_encode_recursive($dat)
        { if (is_string($dat)) {
            return utf8_encode($dat);
          }
          if (is_object($dat)) {
            $ovs= get_object_vars($dat);
            $new=$dat;
            foreach ($ovs as $k =>$v)    {
                $new->$k=array_utf8_encode_recursive($new->$k);
            }
            return $new;
          }
         
          if (!is_array($dat)) return $dat;
          $ret = array();
          foreach($dat as $i=>$d) $ret[$i] = array_utf8_encode_recursive($d);
          return $ret;
        }
function array_utf8_decode_recursive($dat)
        { if (is_string($dat)) {
            return utf8_decode($dat);
          }
          if (is_object($dat)) {
            $ovs= get_object_vars($dat);
            $new=$dat;
            foreach ($ovs as $k =>$v)    {
                $new->$k=array_utf8_decode_recursive($new->$k);
            }
            return $new;
          }
         
          if (!is_array($dat)) return $dat;
          $ret = array();
          foreach($dat as $i=>$d) $ret[$i] = array_utf8_decode_recursive($d);
          return $ret;
        }
?>
===============================================================================

This isn't mentioned in the documentation for either PHP or jQuery, but if
you're passing JSON data to a javascript program, make sure your program begins
with:

<?php
header('Content-Type: application/json');
?>
===============================================================================

For anyone who has run into the problem of private properties not being added,
you can simply implement the IteratorAggregate interface with the getIterator()
method. Add the properties you want to be included in the output into an array
in the getIterator() method and return it.
===============================================================================

When using the JsonSerializable interface be aware that throwing any exception
from within the jsonSerialize() method will be suppressed and an exception
saying "Failed calling YourClass::jsonSerialize()" will be thrown instead.
===============================================================================

reading json pretty of my code. i have simple code for easy read array, object,
path, etc
json pretty print with str_replace ( \r \n \t ) and preg_replace ( \ ).

function jsonDump ($a,$die = true)
{
$json = str_replace(array("\\r","\\n","\\t"), "",json_encode
($a,JSON_PRETTY_PRINT));

$json = preg_replace('#(?<!\\\\)(\\$|\\\\)#', "", $json);

echo'<pre>';
print_r($json);
echo'</pre><hr>';
           
if($die) die();
}

//input

$infoPath = array (
'method' => $_SERVER['REQUEST_METHOD'],
'status' => $status,
'dirbatch' => $dirbatch,
'pathData' => $path_data //array
);   

//output
{
    "method": "GET",
    "status": "ins_tarif",
    "dirbatch": "C:\xampp\htdocs\simrs\services",
    "pathData": [
        "E:\Brankas\Project\RSIA\SIMRS\dump\DOKTER.csv",
        "E:\Brankas\Project\RSIA\SIMRS\dump\GOLPAS.csv",
        "E:\Brankas\Project\RSIA\SIMRS\dump\PANGKAT.csv",
        "E:\Brankas\Project\RSIA\SIMRS\dump\PEMAKAI.csv"
    ]
}

Hope it works well for you  :)
===============================================================================

Notice the last json_decode does not working :) ,you need to use a variable to
use the encoded data in json_decode():-
<?php
$arr=array('a'=>1,'b'=>2,'c'=>3,'d'=>4,'e'=>5);

echo json_encode($arr)."<br />";
//{"a":1,"b":2,"c":3,"d":4,"e":5}

print_r (json_decode(json_encode($arr)));
//stdClass Object ( [a] => 1 [b] => 2 [c] => 3 [d] => 4 [e] => 5 )
echo "<br />";
$var=json_encode($arr);
print_r (json_decode($var,true));
//Array ( [a] => 1 [b] => 2 [c] => 3 [d] => 4 [e] => 5 )
echo "<br />";
print_r (json_decode(json_encode($arr)),true);//no output
?>
===============================================================================

Attention when passing a plain array to json_encode and using
JSON_FORCE_OBJECT. It figured out that the index-order of the resulting
JSON-string depends on the system PHP is running on.

$a = array("a" , "b", "c");
echo json_encode($a, JSON_FORCE_OBJECT);

On Xampp (Windows) you get:

{"0":"a","1":"b","2":"c"}';

On a machine running debian I get:

{"2":"a","1":"b","0":"c"}';

Note that the key:value pairs are different!

Solution here was to use array_combine to create a ssociative array and then
pass it to json_encode:

json_encode(array_combine(range(0, count($a) - 1), $a), JSON_FORCE_OBJECT);
===============================================================================

If your on a version of PHP before 5.2, this might help:

<?php
if (!function_exists('json_encode')) {
    function json_encode($data) {
        switch ($type = gettype($data)) {
            case 'NULL':
                return 'null';
            case 'boolean':
                return ($data ? 'true' : 'false');
            case 'integer':
            case 'double':
            case 'float':
                return $data;
            case 'string':
                return '"' . addslashes($data) . '"';
            case 'object':
                $data = get_object_vars($data);
            case 'array':
                $output_index_count = 0;
                $output_indexed = array();
                $output_associative = array();
                foreach ($data as $key => $value) {
                    $output_indexed[] = json_encode($value);
                    $output_associative[] = json_encode($key) . ':' . 
json_encode($value);
                    if ($output_index_count !== NULL && $output_index_count++ !
== $key) {
                        $output_index_count = NULL;
                    }
                }
                if ($output_index_count !== NULL) {
                    return '[' . implode(',', $output_indexed) . ']';
                } else {
                    return '{' . implode(',', $output_associative) . '}';
                }
            default:
                return ''; // Not supported
        }
    }
}
?>
===============================================================================

The JSON_NUMERIC_CHECK flag introduced in 5.3.0 comes in very handy when
handling numbers encapsulated in a string (database results and post requests
are always encoded as string types, for example). Sending over variables from a
database result directly (as string) would cause the json_encode() function to
quote them, which in turn would make the Javascript store them as strings. As
Javascript isn't loosely typed, some libraries could break on this, when
attempting to use one of those variables as row id in a data store for
instance. Using the aforementioned flag can prevent this from happening.

<?php
$arr = array( 'row_id' => '1', 'name' => 'George' ); // fictional db result
echo json_encode( $arr, JSON_NUMERIC_CHECK ); // {"row_id":1,"name":"George"}
?>
===============================================================================

To save some space, at the risk of it being illegal JSON, strictly speaking:

<?php
$json = preg_replace('/"([a-zA-Z]+[a-zA-Z0-9]*)":/', '$1:', json_encode(
$whatever));
?>
===============================================================================

The json_encode() does'nt gave you correct json I have written a  code that can
give a valid json
//DatabaseConnectionClass.php
abstract class DatabaseConnectionClass {
    protected  $link;

    protected  function  __construct()
    {
     $this->link=mysqli_connect('localhost','root','','realestate')  or die
('Unable to connect to database');

    }

}
//JSON.php
include 'DatabaseConnectionClass.php';

class JSON extends DatabaseConnectionClass
{
    private $recordCount;
    function __construct()
    {
       
        // Used for  Connecting to Database
        parent::__construct();
        $this->recordCount=0;
    }
    private function jsonFileWriter($buffer_string,$mode)
    {
        // This function is to write data onto a file.
        $jsonFile=fopen("data.json",$mode);
        fwrite($jsonFile, $buffer_string);
        fclose($jsonFile);

    }   
    public function generateJSON()
    {
        /* Used to generate data for Angular JS JSON File*/
        /*Refer ExportJson.class in phpMyAdmin*/

        $res=$this->link->query('SELECT `id`,`district`,`taluk`,`category`,
`type`,`description`,`amount` FROM `tbl_info` WHERE 1');
        while ($row=$res->fetch_assoc())
        {
            $this->recordCount=$this->recordCount+1;
            if($this->recordCount==1)
            {
                $buffer='[';
                $this->jsonFileWriter($buffer,'w');

            }
            else
            {
                $buffer = ', ';
                $this->jsonFileWriter($buffer,'a');
            }
            $json=json_encode($row, JSON_PRETTY_PRINT, 512);
            $this->jsonFileWriter($json,'a');
            
        }
            $buffer = '] ';
            $this->jsonFileWriter($buffer,'a');
            }
           
       

}
===============================================================================

Another way to work with Russian characters. This procedure just handles
Cyrillic characters without UTF conversion. Thanks to JsHttpRequest developers.

<?php
function php2js($a=false)
{
  if (is_null($a)) return 'null';
  if ($a === false) return 'false';
  if ($a === true) return 'true';
  if (is_scalar($a))
  {
    if (is_float($a))
    {
      // Always use "." for floats.
      $a = str_replace(",", ".", strval($a));
    }

    // All scalars are converted to strings to avoid indeterminism.
    // PHP's "1" and 1 are equal for all PHP operators, but
    // JS's "1" and 1 are not. So if we pass "1" or 1 from the PHP backend,
    // we should get the same result in the JS frontend (string).
    // Character replacements for JSON.
    static $jsonReplaces = array(array("\\", "/", "\n", "\t", "\r", "\b", "\f",
'"'),
    array('\\\\', '\\/', '\\n', '\\t', '\\r', '\\b', '\\f', '\"'));
    return '"' . str_replace($jsonReplaces[0], $jsonReplaces[1], $a) . '"';
  }
  $isList = true;
  for ($i = 0, reset($a); $i < count($a); $i++, next($a))
  {
    if (key($a) !== $i)
    {
      $isList = false;
      break;
    }
  }
  $result = array();
  if ($isList)
  {
    foreach ($a as $v) $result[] = php2js($v);
    return '[ ' . join(', ', $result) . ' ]';
  }
  else
  {
    foreach ($a as $k => $v) $result[] = php2js($k).': '.php2js($v);
    return '{ ' . join(', ', $result) . ' }';
  }
}
?>
===============================================================================

json_encode also won't handle objects that do not directly expose their
internals but through the Iterator interface. These two function will take care
of that:

<?php

/**
* Convert an object into an associative array
*
* This function converts an object into an associative array by iterating
* over its public properties. Because this function uses the foreach
* construct, Iterators are respected. It also works on arrays of objects.
*
* @return array
*/
function object_to_array($var) {
    $result = array();
    $references = array();

    // loop over elements/properties
    foreach ($var as $key => $value) {
        // recursively convert objects
        if (is_object($value) || is_array($value)) {
            // but prevent cycles
            if (!in_array($value, $references)) {
                $result[$key] = object_to_array($value);
                $references[] = $value;
            }
        } else {
            // simple values are untouched
            $result[$key] = $value;
        }
    }
    return $result;
}

/**
* Convert a value to JSON
*
* This function returns a JSON representation of $param. It uses json_encode
* to accomplish this, but converts objects and arrays containing objects to
* associative arrays first. This way, objects that do not expose (all) their
* properties directly but only through an Iterator interface are also encoded
* correctly.
*/
function json_encode2($param) {
    if (is_object($param) || is_array($param)) {
        $param = object_to_array($param);
    }
    return json_encode($param);
}
===============================================================================

I write a function "php_json_encode"
for early version of php which support "multibyte" but doesn't support
"json_encode".
<?php
  function json_encode_string($in_str)
  {
    mb_internal_encoding("UTF-8");
    $convmap = array(0x80, 0xFFFF, 0, 0xFFFF);
    $str = "";
    for($i=mb_strlen($in_str)-1; $i>=0; $i--)
    {
      $mb_char = mb_substr($in_str, $i, 1);
      if(mb_ereg("&#(\\d+);", mb_encode_numericentity($mb_char, $convmap, 
"UTF-8"), $match))
      {
        $str = sprintf("\\u%04x", $match[1]) . $str;
      }
      else
      {
        $str = $mb_char . $str;
      }
    }
    return $str;
  }
  function php_json_encode($arr)
  {
    $json_str = "";
    if(is_array($arr))
    {
      $pure_array = true;
      $array_length = count($arr);
      for($i=0;$i<$array_length;$i++)
      {
        if(! isset($arr[$i]))
        {
          $pure_array = false;
          break;
        }
      }
      if($pure_array)
      {
        $json_str ="[";
        $temp = array();
        for($i=0;$i<$array_length;$i++)       
        {
          $temp[] = sprintf("%s", php_json_encode($arr[$i]));
        }
        $json_str .= implode(",",$temp);
        $json_str .="]";
      }
      else
      {
        $json_str ="{";
        $temp = array();
        foreach($arr as $key => $value)
        {
          $temp[] = sprintf("\"%s\":%s", $key, php_json_encode($value));
        }
        $json_str .= implode(",",$temp);
        $json_str .="}";
      }
    }
    else
    {
      if(is_string($arr))
      {
        $json_str = "\"". json_encode_string($arr) . "\"";
      }
      else if(is_numeric($arr))
      {
        $json_str = $arr;
      }
      else
      {
        $json_str = "\"". json_encode_string($arr) . "\"";
      }
    }
    return $json_str;
  }
===============================================================================

As json_encode() won't work with character sets other than UTF-8, this
expression allows to encode strings for JSON regardless of the character set:

<?php
str_replace("\0", "\\u0000", addcslashes($string, "\t\r\n\"\\"));
?>

You need to replace the nul character manually as addcslashes() won't do it
right way. But BEWARE, this is only solution for common strings, other "unusual
wild characters" like ESC, \b, \a etc. are not handled.
===============================================================================

::fast utf8-encoding of strings::

json_encode( array_map( function($t){ return is_string($t) ? utf8_encode($t) :
$t; }, $array ) )
===============================================================================

If you have problems with json_encode() on arrays, you can force json_encode()
to encode as object, and then use json_decode() casting the result as array:

<?php

$myarray = Array('isa', 'dalawa', 'tatlo');

unset($myarray[1]);

$json_encoded_array = json_encode ( $myarray, JSON_FORCE_OBJECT );

// do whatever you want with your data
// then you can retrive the data doing:

$myarray = (array) json_decode ( $json_encoded_array );

?>
===============================================================================

Guys, (and girls)

A trick to unescape UTF8 for ppl with php < 5.4.0

json_encode(...) gives you \\u..... right ?

json_decode DOES unescape though !

so:

<?php
/* Imagine you have an object like this :
[{"name":"php help héhéhahéhé","url":"http://payAttention.example.com"},
{"name":"took me brainack j'étais mal mec","url":"http://slashesEscapingSux"}]
*/

//first encode your object
$myDirtyString = $json_encode($myObject);

/*the JSON_UNESCAPED_SLASHES, and JSON_UNESCAPED_UNICODE being unavailable,
you'll have some ugly escaping happening :

[{"name":"php help h\\u00e9h\\u00e9hah\\u00e9h\\u00e9","url":"http:\\/\\/
payAttention.example.com"},{"name":"took me brainack j'\\u00e9tais mal
mec","url":"http:\\/\\/slashesEscapingSux\\/"}]
*/

//So, you'll have to unescape slashes:
$myDirtyString = str_replace("\\/","/",$myDirtyString);

//Then, for the trick, escape doule quotes
$myDirtyString = str_replace('"','\\\\"',$myDirtyString);

//in oder to json_decode this trciked string (and get your utf8 unescaped)

$myCleanedString = json_decode('"'.$myDirtyString.'"');

// Je tour est joué !
// There might be better ways to do it but i found so much useless nonsense on
forums that i decided to go with it for tonight
?>
===============================================================================

copy the php tagged code in a page
this is use full for multy dimention array

<?php

function arr_2_str($arr,$counter=1,$str="")
{
    foreach( $arr as $key=>$value)
    {
        if(is_array($value))
        {
            $str.= $key."=$counter>".arr_2_str($value,($counter+1))."=".
$counter.">~Y~|".$counter."|";
        }
        else
        {
            $str.=$key."=$counter>".$value."|$counter|";
        }
    }
    return rtrim($str,"|$counter|");
}

function str_2_arr($str,$counter=1,$arr=array(),$temparr=array())
{
    $temparr=explode("|$counter|",$str);
   
    foreach( $temparr as $key=>$value)
    {
        $t1=explode("=$counter>",$value);
        $kk=$t1[0];
        $vv=$t1[1];
        if ($t1[2]=="~Y~")
        {
            $arr[$kk]=str_2_arr($vv,($counter+1));
        }
        else
        {
            $arr[$kk]=$vv;
        }
       
    }
    return $arr;
}

$arr=array();

$arr[1]="a";
$arr[2][1]="b";
$arr[2][2]="c";
$arr[2][3][1]="d";
$arr[2][3][2][1]="e1";
$arr[2][3][2][2]="e2";
$arr[2][3][3]="f";
print "<pre>";

print_r($arr);

print "<br><br><br>";

print $ssttrr=arr_2_str($arr);

print "<br><br><br>";

print_r(str_2_arr($ssttrr));

/*print "<br><br><br>";
print "use of json";
print "<br><br><br>";
print $sstr=json_encode($arr);
print "<br><br><br>";
print_r(json_decode($sstr));*/

print "</pre>";

?>
===============================================================================

If you need a json_encode / json_decode which is array/object/assoc-array you
might want to use: http://gist.github.com/820694

<?php
$dataIn = (object)array(
    "assoc" => array("cow"=>"moo"),
    "object" => (object)array("cat"=>"miao"),
);
/*
== IN
object(stdClass)#2 (2) {
  ["assoc"]=>
  array(1) {
    ["cow"]=>
    string(3) "moo"
  }
  ["object"]=>
  object(stdClass)#1 (1) {
    ["cat"]=>
    string(4) "miao"
  }
}

== JSON
{"assoc":{"_PHP_ASSOC":{"cow":"moo"}},"object":{"cat":"miao"}}

== OUT
object(stdClass)#4 (2) {
  ["assoc"]=>
  array(1) {
    ["cow"]=>
    string(3) "moo"
  }
  ["object"]=>
  object(stdClass)#7 (1) {
    ["cat"]=>
    string(4) "miao"
  }
}
*/
?>
===============================================================================

There is a gotcha that keeps getting me with JSON_NUMERIC_CHECK. At first it
seems like the greatest thing in the world if you are encoding data pulled from
a db because it turns numeric strings into seemingly appropriate ints or
floats. Use with caution. I've been surprised a number of times by "numbers"
that really are strings ie really precise lat/long coords.  json_encode with
the JSON_NUMERIC_CHECK will encode these as floats but the precision of the
data is so large that php actually rounds the number off. In this case I had to
rework my code so that it didn't use JSON_NUMERIC_CHECK and I manually cast
fields as ints or floats as appropriate and skipped my lat/long fields so that
they stayed numeric strings.
===============================================================================

Obviously, this function has trouble encoding arrays with empty string keys
(''). I have just noticed that (because I was using a function in PHP under
PHP4). When I switched to PHP5's json_encode, I noticed that browsers could not
correctly parse the encoded data. More investigation maybe needed for a bug
report, but this quick note may save somebody several hours.

Also, it manifests on Linux in 5.2.1 (tested on two boxes), on my XP with
PHP5.2.3 json_encode() works just great! However, both 5.2.1 and 5.2.3 phpinfo
()s show that the json version is 1.2.1 so might be Linux issue
===============================================================================

Take care that json_encode() expects strings to be encoded to be in UTF8
format, while by default PHP strings are ISO-8859-1 encoded.
This means that

json_encode(array('àü'));

will produce a json representation of an empty string, while

json_encode(array(utf8_encode('àü')));

will work.
The same applies to decoding, too, of course...
===============================================================================

It's my __json_encode function to encode in JSON format array or string with
javascript function

<?php

function __json_encode($mVar,$fnCallback="stripcslashes") {
    return preg_replace_callback(
        '#"[ ]{0,}function[ ]{0,}\([^)$]{0,}\)[ ]{0,}\{[ ]{0,}(?(?![ ]{0,}}[ ]
{0,}").){0,}[ ]{0,}\}[ ]{0,}"([(?,")|(?\}{0,}$)]{0,})#si',
        function ($aRes) use ($fnCallback) {
            for($aRes[0]=substr($aRes[0],1),$sOut="",$i=0,$iOpen=0,$iClose=0;$i
<= strlen($aRes[0]) && $sOut.= substr($aRes[0],$i,1);$i++)
                if (substr($aRes[0],$i,1) == "{") $iOpen++;
                else if (substr($aRes[0],$i,1) == "}" AND $iOpen == ++$iClose)
break;
            return is_callable($fnCallback) ? $fnCallback($sOut).$aRes[1] : 
$fnCallback($sOut).$aRes[1];
        },
        json_encode($mVar)
    );
}
   

$aData = array(
    'key1' => 'value1',
    'key2' => 'function(){ return $("<INPUT />").attr("type","text"); }',
    'key3' => array(
        'key3.1'=>'val3.1',
        'key3.2'=>'function(someArg) { if (someArg == "someValue") return true;
else { document.write("error"); return false; } }',
        ),
    'key4' => 'function(){ return true; }'
);

$sData = 'function(someArg) { if (someArg == "someValue") return true; else {
document.write("error"); return false; } }';

echo  'Output for json_encode() : '.json_encode($aData)."\n\n";
echo  'Output for __json_encode() : '.__json_encode($aData)."\n\n";

echo  'Output for json_encode($sData) : '.json_encode($sData)."\n\n";
echo  'Output for __json_encode($sData) : '.__json_encode($sData)."\n\n";

/*
*
* Output for json_encode() : {"key1":"value1","key2":"function(){ return $(\"
<INPUT \/>\").attr(\"type\",\"text\"); }","key3":
{"key3.1":"val3.1","key3.2":"function(someArg) { if (someArg == \"someValue\")
return true; else { document.write(\"error\"); return false; } }
"},"key4":"function(){ return true; }"}
*
* Output for __json_encode() : {"key1":"value1","key2":function(){ return $("
<INPUT />").attr("type","text"); },"key3":{"key3.1":"val3.1","key3.2":function
(someArg) { if (someArg == "someValue") return true; else { document.write
("error"); return false; } }},"key4":function(){ return true; }}
*
*
* Output for json_encode($sData) : "function(someArg) { if (someArg == \
"someValue\") return true; else { document.write(\"error\"); return false; } }"
*
* Output for __json_encode($sData) : function(someArg) { if (someArg ==
"someValue") return true; else { document.write("error"); return false; } }
*
*/
===============================================================================

If you have problems with quotes when encoding numeric data retrieved from the
database, you can just cast that value to integer and there will be no quotes:

<?php
$testArr['key'] = '1';
print json_encode($testArr);
?>

===> {"key":"1"}

<?php
$testArr['key'] = (int)'1';
print json_encode($testArr);
?>

===> {"key":1}

Don't forget that you have to deal with numbers, otherwise your string will be
converted to 0.
===============================================================================

json_encode "only works with UTF-8 encoded data." so if there is any chance
that users influence the variable you're about to encode to json, you should
first recursively encode to UTF-8.

There are several comments doing that, but some only traverse the input array 1
level deep. Others write full fledged recursive functions themselves. Whereas
as of PHP5 you could also utilize array_walk_recursive

<?php
array_walk_recursive($inputArray, function(&$val) {
    $val = utf8_encode($val);
});
json_encode($inputArray);
?>

Hope this helps
===============================================================================

Another way for pre-5.2.0 PHP users is using rawurlencode() in PHP to encode a
string and decodeURIComponent() in javascript to decode it. I have written
following class to handle PHP arrays and convert them to javascript format. It
uses object notation for associative arrays and arrays for the other. Nesting
is supported. True, false, integers, floats and null values are presented in
respective javascript syntax.

Use: convert an array in PHP using this class, load it into the browser using
ajax and then decode the strings in the resulting object using javascript
function decodeData (below).

All of the example results have passed json validator so it shoud be allright.
Feel free to use this.

PHP CLASS - encoding arrays
=======

<?php

class custom_json {

    /**
     * Convert array to javascript object/array
     * @param array $array the array
     * @return string
     */
    public static function encode($array)
    {

        // determine type
        if(is_numeric(key($array))) {

            // indexed (list)
            $output = '[';
            for($i = 0, $last = (sizeof($array) - 1); isset($array[$i]); ++$i)
{
                if(is_array($array[$i])) $output .= self::encode($array[$i]);
                else  $output .= self::_val($array[$i]);
                if($i !== $last) $output .= ',';
            }
            $output .= ']';

        } else {

            // associative (object)
            $output = '{';
            $last = sizeof($array) - 1;
            $i = 0;
            foreach($array as $key => $value) {
                $output .= '"'.$key.'":';
                if(is_array($value)) $output .= self::encode($value);
                else  $output .= self::_val($value);
                if($i !== $last) $output .= ',';
                ++$i;
            }
            $output .= '}';

        }

        // return
        return $output;

    }

    /**
     * [INTERNAL] Format value
     * @param mixed $val the value
     * @return string
     */
    private static function _val($val)
    {
        if(is_string($val)) return '"'.rawurlencode($val).'"';
        elseif(is_int($val)) return sprintf('%d', $val);
        elseif(is_float($val)) return sprintf('%F', $val);
        elseif(is_bool($val)) return ($val ? 'true' : 'false');
        else  return 'null';
    }

}

// prints ["apple","banana","blueberry"]
echo custom_json::encode(array('apple', 'banana', 'blueberry'));

// prints {"name":"orange","type":"fruit"}
echo custom_json::encode(array('name' => 'orange', 'type' => 'fruit'));

// prints: ** try it yourself, cannot post long lines here **
$big_test = array(
    array(
        'name' => array('John', 'Smith'),
        'age' => 27,
        'sex' => 0,
        'height' => 180.53,
        'is_human' => true,
        'string' => 'Hello',
    ),
    array(
        'name' => array('Green', 'Alien'),
        'age' => 642,
        'sex' => null,
        'height' => 92.21,
        'is_human' => false,
        'string' => 'こんにちは！', // test utf8 here
    )
);

echo custom_json::encode($big_test);

?>

JAVASCRIPT FUNCTION - decode rawurlencoded() strings
==================
function decodeData(data) {
        for(var item in data) {
            var type = typeof data[item];
            if(type === 'object') decodeData(data[item]);
            else if(type === 'string') data[item] = decodeURIComponent(data
[item]);
        }
    }
===============================================================================

Anybody having empty arrays and needing the JSON_FORCE_OBJECT option but not
using 5.3 yet, you can substitute assigning an empty object:

<?php
    if (empty($array)) $array = (object) null;
    $return = json_encode($array);
?>
===============================================================================

Here is a bit more on creating an iterator to get at those pesky private/
protected variables:

<?php
   class Kit implements IteratorAggregate {

    public function __construct($var) {
        if (is_object($var)) {
            // if passed an object, we are cloning
           $this->kitID = $var->kitID;
           $this->kitName = $var->kitName;
           foreach ($var->productArray as $key => $value) {
               $this->productArray[$key] = (array)$value;
           }
        }
    }
   ...
    // Create an iterator because private/protected vars can't
    // be seen by json_encode().
    public function getIterator() {
        $iArray['kitID'] = $this->kitID;
        $iArray['kitName'] = $this->kitName;
        $iArray['productArray'] = (array)$this->productArray;
        return new ArrayIterator($iArray);
    }
}
?>

Calling something like  $t = json_encode($this->getIterator());  will give you
almost what you want:
<?php
{"kitID":"Kit_Essentials-Books.txt",
"kitName":"Essential Books",
"productArray":{"0470043601":{"Category":"Food","ASIN":"0470043601"} } }
?>

Notice that the productArray is converted to an object ignoring the cast I put
in front, which is not what I wanted. I haven't figured out how to make sure
that encodes as an array.

Regardless, bringing that JSON back into an object using json_decode() will
give you just a std object, and the only way I've found to get it into the
proper object type is to use a constructor that instantiates the object the way
it's supposed to be (see __construct($var) above). Like this:
<?php

        $newKit = new Kit(json_decode($t));
?>
===============================================================================

Be careful about one thing:
With a string key Php will consider it's an object:

<?php
echo json_encode(array('id'=>'testtext'));
echo json_encode(array('testtext'));
?>

Will give:

{"id":"testtext"}
["testtext"]

Beware of the string keys!
===============================================================================

I had trouble putting the results of mysql_fetch_assoc() through json_encode:
numbers being returned from the query were being quoted in the JSON output
(i.e., they were being treated as strings). In order to fix this, it is
necessary to explicitly cast each element of the array before json_encode() is
called.

The following code uses metadata from a MySQL query result to do this casting.

<?php
    $mysql = mysql_connect('localhost', 'user', 'password');
    mysql_select_db('my_db');

    $query = 'select * from my_table';
    $res = mysql_query($query);

    // iterate over every row
    while ($row = mysql_fetch_assoc($res)) {
        // for every field in the result..
        for ($i=0; $i < mysql_num_fields($res); $i++) {
            $info = mysql_fetch_field($res, $i);
            $type = $info->type;

            // cast for real
            if ($type == 'real')
                $row[$info->name] = doubleval($row[$info->name]);
            // cast for int
            if ($type == 'int')
                $row[$info->name] = intval($row[$info->name]);
        }

        $rows[] = $row;
    }

    // JSON-ify all rows together as one big array
    echo json_encode($rows);
   
    mysql_close($mysql);
?>
===============================================================================

When Using Libraries such as Prototype you may find that once in a while when
you return what you believe to be a empty array it will have a different
behavior (vis a vis enumerables) than when you give it an associative array. To
"fix" this, on your JS you may want to look for extended object properties to
verify if it is an empty array or an ocject.

example:

<?php
if (transport.responseJSON['User'].length == undefined){
        var user = $H(transport.responseJSON['User']);
}else{
        var user = transport.responseJSON['User'];     
}
?>

Thanks goes out to :
jani@php.net

This is totally expected behaviour. Please read this:
http://www.json.org/

Note: array and assoc-array are different things. Latter being "object"
in json.

http://bugs.php.net/bug.php?id=45162

[RQuadling] See http://bugs.php.net/bug.php?id=47493. Fixed by using
json_encode(array(), JSON_FORCE_OBJECT);
===============================================================================

Simple replacement for JSON_UNESCAPED_UNICODE (PHP < 5.4 for example)

Can be buggy, but works for simple UTF-8 strings.

<?php
$json = preg_replace_callback('/\\\u(\w\w\w\w)/',
    function($matches)
    {
        return '&#'.hexdec($matches[1]).';';
    }
    , json_encode($array));
?>
===============================================================================

Regarding encoding issues, if you make sure the PHP files containing your
strings are encoded in UTF-8, you shouldn't need to call utf8_encode.
===============================================================================

Note that json_encode always escapes a solidus (forward slash, %x2F).
This may be a problem if you are encoding a URL.
It's been recognised and fixed in September 2010:
http://bugs.php.net/bug.php?id=49366
But escaping will still be the default behaviour.
A crude repair can be done with
str_replace('\\/', '/', $jsonEncoded)
