
sem_get

(PHP 4, PHP 5, PHP 7)

sem_get — Get a semaphore id

说明

resource sem_get ( int $key [, int $max_acquire = 1 [, int $perm = 0666 [, int
$auto_release = 1 ]]] )

sem_get() returns an id that can be used to access the System V semaphore with
the given key.

A second call to sem_get() for the same key will return a different semaphore
identifier, but both identifiers access the same underlying semaphore.

参数

key

max_acquire

    The number of processes that can acquire the semaphore simultaneously is
    set to max_acquire.

perm

    The semaphore permissions. Actually this value is set only if the process
    finds it is the only process currently attached to the semaphore.

auto_release

    Specifies if the semaphore should be automatically released on request
    shutdown.

返回值

Returns a positive semaphore identifier on success, or FALSE on error.

注释

Warning

When using sem_get() to access a semaphore created outside PHP, note that the
semaphore must have been created as a set of 3 semaphores (for example, by
specifying 3 as the nsems parameter when calling the C semget() function),
otherwise PHP will be unable to access the semaphore.

参见

  • sem_acquire() - Acquire a semaphore
  • sem_release() - Release a semaphore
  • ftok() - Convert a pathname and a project identifier to a System V IPC key


User Contributed Notes 10 notes

===============================================================================

For those that encounter strange behavior in using sem_acquire() on resources
generated by sem_get(). Have a look at  sem_get()'s 4th parameter auto_release.
It allows multiple acquisitions through reassignments to resource variables.

./multi.acquire.php
<?php
class Sem {
  private $key = null;
  private $res = null;
  public function __construct() {
    $this->key = ftok(".",".");
    $this->set_res();
    $this->acquire();
  }
  public function set_res() {
    // 4th parameter auto_released is 1 by default
    $this->res = sem_get($this->key, 1, 0600, 1);
  }
  public function acquire() {
    echo "acquired='".sem_acquire($this->res,true)."'\n";
  }
}

$s = new Sem();
$s->set_res();
$s->acquire();

?>

$ php multi.acquire.php
acquired='1'
acquired='1'

To avoid reacquiring by default set sem_get()'s parameter auto_release to 0 or
check if your resource variable is already set, e.g. by using is_null().
===============================================================================

Actually it looks like the semaphore is automatically released not on request
shutdown but when the variable you store it's resource ID is freed. That is a
very big difference.
===============================================================================

It is possible to create an "infinite" amount of semaphores when setting $key =
0.

Run sem_get multiple times
php > sem_get(0,0);

and check the output of
$ ipcs -s

------ Semaphore Arrays --------
key        semid      owner      perms      nsems    
0x00000000 1277952    user       666        3        
0x00000000 1310721    user       666        3

As you can see there were multiple semaphores set up with key 0.
For any other integer sem_get works as expected. It returns another resource id
pointing to the semaphore previously created and does not create another
semaphore.
===============================================================================

with gentoo php5 you will need to add the USE flag :
sysvipc

see :
http://forums.gentoo.org/viewtopic-t-464175-highlight-semget+php.html

and also :
http://overlays.gentoo.org/proj/php/
===============================================================================

Watch out when you use fileinode() to get a unique semaphore key (as suggested
in some comment on this or a related function) in conjunction with version
control software: It seems, for example, SVN will change the inode. Using such
a file will leave you with your mutex not working reliably and your system's
semaphore pool being filled until further attempts to get a semaphore will
fail. Use ipcs and ipcrm commands from linux-util-ng (on most distros probably)
to examine/fix related problems.
===============================================================================

Heh, actually the above comment I added is not technically correct, it was more
of an idea to display the function.

$SHM_KEY = ftok("/home/joeldg/homeymail/shmtest.php", 'R');
$shmid = sem_get($SHM_KEY, 1024, 0644 | IPC_CREAT);
$data = shm_attach($shmid, 1024);
// we now have our shm segment

// lets place a variable in there
shm_put_var ($data, $inmem, "test");
// now lets get it back. we could be in a forked process and still have
// access to this variable.
printf("shared contents: %s\n", shm_get_var($data, $inmem));

shm_detach($data);
===============================================================================

<?
// thanks to
// http://www.ecst.csuchico.edu/~beej/guide/ipc/shmem.html
$SHM_KEY = ftok("/home/joeldg/homeymail/shmtest.php", 'R');
$shmid = sem_get($SHM_KEY, 1024, 0644 | IPC_CREAT);
$data = shm_attach($shmid, 1024);

$data = "test";
printf("shared contents: %s\n", $data);

shm_detach($data);
?>
===============================================================================

Implementation of a read-write semaphore in PHP:

<?php
class rw_semaphore {
       
    const READ_ACCESS = 0;
    const WRITE_ACCESS = 1;   
   
    /**
     * @access private
     * @var resource - mutex semaphore
     */
    private $mutex;
   
    /**
     * @access private
     * @var resource - read/write semaphore
     */
    private $resource;
   
    /**
     * @access private
     * @var int
     */
    private $writers = 0;
   
    /**
     * @access private
     * @var int
     */
    private $readers = 0;

    /**
     * Default constructor
     *
     * Initialize the read/write semaphore
     */
    public function __construct() {
        $mutex_key = ftok('/home/cyrus/development/php/sysvipc/
rw_semaphore.php', 'm');
        $resource_key = ftok('/home/cyrus/development/php/sysvipc/
rw_semaphore.php', 'r');       
        $this->mutex = sem_get($mutex_key, 1);
        $this->resource = sem_get($resource_key, 1);       
    }
   
    /**
     * Destructor
     *
     * Remove the read/write semaphore
     */
    public function __destruct() {
        sem_remove($this->mutex);
        sem_remove($this->resource);
    }
   
    /**
     * Request acess to the resource
     *
     * @param int $mode
     * @return void
     */
    private function request_access($access_type = self::READ_ACCESS) {   
        if ($access_type == self::WRITE_ACCESS) {
            sem_acquire($this->mutex);
           
            /* update the writers counter */
            $this->writers++;
           
            sem_release($this->mutex);           
            sem_acquire($this->resource);
        } else {           
            sem_acquire($this->mutex);           
            if ($this->writers > 0 || $this->readers == 0) {               
                sem_release($this->mutex);               
                sem_acquire($this->resource);               
                sem_acquire($this->mutex);               
            }
            /* update the readers counter */
            $this->readers++;
           
            sem_release($this->mutex);
        }
    }
   
    private function request_release($access_type = self::READ_ACCESS) {
        if ($access_type == self::WRITE_ACCESS) {
            sem_acquire($this->mutex);
           
            /* update the writers counter */
            $this->writers--;
           
            sem_release($this->mutex);
            sem_release($this->resource);
        } else {
            sem_acquire($this->mutex);
           
            /* update the readers counter */
            $this->readers--;
           
            if ($this->readers == 0)
                sem_release($this->resource);
           
            sem_release($this->mutex);
        }
    }
   
    /**
     * Request read access to the resource
     *
     * @return void
     */
    public function read_access() { $this->request_access(self::READ_ACCESS); }
   
    /**
     * Release read access to the resource
     *
     * @return void
     */
    public function read_release() { $this->request_release(self::READ_ACCESS);
}
   
    /**
     * Request write access to the resource
     *
     * @return void
     */
    public function write_access() { $this->request_access(self::WRITE_ACCESS);
}
   
    /**
     * Release write access to the resource
     *
     * @return void
     */
    public function write_release() { $this->request_release(self::WRITE_ACCESS
); }
   
}
?>
===============================================================================

Be aware that there is no way to ensure that you have exclusive access to a
lock, despite setting max_acquire=1.

In example,
<?
$fp = sem_get(fileinode('lock_file', 100);
sem_acquire($fp);

$fp2 = sem_get(fileinode('lock_file', 1);
sem_acquire($fp2);
?>

This will not block on the second sem_aquire.  Therefore, if you have functions
or processes that utilize shared locks (>1 max_acquire) you will still need to
provide a seperate lock mechanism (ie flock) for write access, making the sem_
functions useless.

Some more info, in flock, each reference to the lock file has it's own options
(can be shared exclusive blocking non blocking etc), but apparently php's sem
functions only support these options per semaphore, not per
semaphore-reference.
===============================================================================

A very simple to introduce semaphore...

<?php
$SEMKey = "123456" ;

## Get Semaphore id
$seg = sem_get( $SEMKey, 2, 0666, -1) ;

if ( $argv[1]=="remove" ) {
    sem_remove($seg);
}

echo "Try to acquire ..."
sem_acquire($seg);
echo "Acquired...\n" ;

echo "Press Any Key to continue...\n";
$fh = fopen("php://stdin", "r");
$a = fgets( $fh);
fclose($fh);

sem_release($seg);
?>
