
odbc_exec

(PHP 4, PHP 5, PHP 7)

odbc_exec — Prepare and execute an SQL statement

说明

resource odbc_exec ( resource $connection_id , string $query_string [, int
$flags ] )

Sends an SQL statement to the database server.

参数

connection_id

    ODBC 连接标识符，详见 odbc_connect()。

query_string

    The SQL statement.

flags

    This parameter is currently not used.

返回值

Returns an ODBC result identifier if the SQL command was executed successfully,
or FALSE on error.

参见

  • odbc_prepare() - Prepares a statement for execution
  • odbc_execute() - Execute a prepared statement


User Contributed Notes 20 notes

===============================================================================

If you are having problems with truncated text fields from ODBC queries (pe. at
4096 characters), try some of the following:

in php.ini:
- odbc.defaultlrl = 65536

in your php code, before your queries:
- ini_set ( 'odbc.defaultlrl' , '65536' );
===============================================================================

ODBC/MS Access Date Fields:

Matching dates in SELECT statements for MS Access requires the following
format:
#Y-m-d H:i:s#

for example:

SELECT * FROM TableName WHERE Birthdate = #2001-01-07 00:00:00#

or

SELECT * FROM TableName WHERE Birthdate BETWEEN #2000-01-07 00:00:00# AND #
2001-01-07 00:00:00#

This took me forever to figure out.
===============================================================================

As an addition to the note about square brackets earlier:

Enclosing sql field names in '[' and ']' also allows you to use MS Access
reserved words like 'date' and 'field' and 'time' in your SQL query... it seems
that the square brackets simply tell Access to ignore any other meaning
whatever is inside them has and take them simply as field names.
===============================================================================

Problem: Fieldnames in SQL-Statement have blanks and [] don't work!

Solution: Try "" instead

Ex.:

SELECT table2.first, table1.[last name] FROM tabel1, table2 -> don't work

SELECT table2.first, table1.\"last name\" FROM tabel1, table2 -> Try this

PS: Don't forget the espace characters !!!
===============================================================================

If you're running NT/IIS with PHP 3.0.11 and want to use MS Access dbs with
"stored procedures" you can send an ODBC SQL query like:
<?php
$conn_id = odbc_connect( "odbc_test_db", "", "", SQL_CUR_USE_DRIVER );
$qry_id = odbc_do( $conn_id, "{CALL MyQuery}" );
?>
This way you don't need to integrate query strings like

SELECT * FROM TblObject WHERE (((TblObject.something) Like "blahblahblah"));

in the php file. You directly call the query "MyQuery" that was generated by MS
Access.
===============================================================================

I tried this way to see the results of a query and it works!!

$Conn = odbc_connect
("bbdd_usuaris","","",SQL_CUR_USE_ODBC );

$result=odbc_exec($Conn,"select nom from usuaris;");

while(odbc_fetch_row($result)){
         for($i=1;$i<=odbc_num_fields($result);$i++){
        echo "Result is ".odbc_result($result,$i);
    }
}
===============================================================================

It is easy to inject evil code into SQL statements. This wraps parameters in
quotes so they are not executable. In your own stored procedures you can
convert the string to numeric as needed.

function sql_make_string($sin){
         return "'".str_replace("'","''",$sin)."'";
}

// this may delete all data from MYTABLE
$evil = "734'; DELETE FROM MYTABLE; print 'ha ha";
$sql = "SELECT * FROM MYTABLE WHERE mykey = '$evil'";
$rst = odbc_exec($connection,$sql);

// this probably will not delete the data.
$good = sql_make_string($evil);
$sql = "SELECT * FROM MYTABLE WHERE mykey =".$good
$rst = odbc_exec($connection,$sql);
===============================================================================

If a single quote exists within the field specified by your WHERE statement,
ODBC fails because of a parsing error.  Although it seems intuitive, using \"
around the field does not work (\"$var\").  The only solution I found was to
replace all single quotes in my field with two single quotes.  ODBC interprets
the first single quote as an escape character and interprets the second single
quote as a literal.  Thanks to http://www.devguru.com/features/knowledge_base/
A100206.html for this tip.
===============================================================================

Additional links to ODBC_exec:
How to actually write the SQL commands:
http://www.roth.net/perl/odbc/faq/
http://www.netaxs.com/~joc/perl/article/SQL.html
Demystifying SQL
BIG REF MANUAL:
http://w3.one.net/~jhoffman/sqltut.htm
Introduction to Structured Query Language
Covers read, add, modify & delete of data.
===============================================================================

An SQL statement that contains quotes (i.e. ") instead of apostrophes (i.e. ')
to delimit strings works fine in Access, however, in odbc_exec, it fails with

[Microsoft][ODBC Microsoft Access Driver] Too few parameters. Expected 6.

For example:

$q = "INSERT INTO TableA (Fld1, Fld2, Fld3) VALUES('A', 'B', 'C');"

works fine in both Access and ODBC, but

$q = 'INSERT INTO TableA (Fld1, Fld2, Fld3) VALUES("A", "B", "C");'

fails with the above error.
===============================================================================

The following seems counterintuitive to me and so I am constantly getting
burned by it.  Just thought I'd add a note for anyone else who might also get
burned.

  if (!odbc_exec("select MyValue from MyTable where Key1='x' and Key2='y'"))

is not a good way to search for the existence of a record with Key1 = x and
Key2 = y.  The odbc_exec always returns a result handle, even though there
aren't any records.

Rather, you must use one of the fetch functions to find out that the record
really doesn't exist.  This should work:

  if (!($Selhand = odbc_exec("select MyValue from MyTable where Key1='x' and
Key2='y'"))
    || !odbc_result($Selhand, 1))
===============================================================================

<?php
// - This is a complete working dynamic example of using:
//    odbc_connect, odbc_exec, getting col Names,
//    odbc_fetch_row and no of rows. hope it helps
// - your driver should point to your MS access file

$conn = odbc_connect('MSAccessDriver','','');

$nrows=0;

if ($conn)
{
$sql =  "select * from $month";
//this function will execute the sql satament
$result=odbc_exec($conn, $sql);

echo "<table  align=\"center\" border=\"1\" borderColor=\"\" cellpadding=\"0\"
cellspacing=\"0\">\n";
echo "<tr> ";
// -- print field name
$colName = odbc_num_fields($result);
for ($j=1; $j<= $colName; $j++)
{
echo "<th  align=\"left\" bgcolor=\"#CCCCCC\" > <font color=\"#990000\"> ";
echo odbc_field_name ($result, $j );
echo "</font> </th>";
}
$j=$j-1;
$c=0;
// end of field names
while(odbc_fetch_row($result)) // getting data
{
$c=$c+1;
if ( $c%2 == 0 )
echo "<tr bgcolor=\"#d0d0d0\" >\n";
else
echo "<tr bgcolor=\"#eeeeee\">\n";
    for($i=1;$i<=odbc_num_fields($result);$i++)
      {       
        echo "<td>";
        echo odbc_result($result,$i);
        echo "</td>";        
        if ( $i%$j == 0 ) 
           {
            $nrows+=1; // counting no of rows   
          }  
      }
    echo "</tr>";
}

echo "</td> </tr>\n";
echo "</table >\n";
// --end of table 
if ($nrows==0) echo "<br/><center> Nothing for $month yet! Try back later</
center>  <br/>";
else echo "<br/><center> Total Records:  $nrows </center>  <br/>";
odbc_close ($conn);

}
else echo "odbc not connected <br>";
?>
===============================================================================

hi all, I managed to get this little snippet working, it's pretty useful if you
have long forms to be inserted into a database.

if ( ! empty ( $_POST ) ){
array_pop($_POST);
foreach($_POST as $key => $val){
  $columns .= addslashes($key) . ", ";
    $values .= "'" . addslashes($val) . "', ";
     
}
$values = substr_replace($values, "", -2);
$columns = substr_replace($columns, "", -2);

$sql = "INSERT INTO table ($columns) VALUES ($values)";
echo $sql;
$results = odbc_exec($conn, $sql);
                 if ($results){
              echo "Query Executed";
                }else {
              echo "Query failed " .odbc_error();
            }   
}

Not the most secure in the world but, speeds up collecting data from large
forms.
===============================================================================

This opens select statements 'for update' by default in db2.  If you're using
db2, you have to tack on 'for read only' at the end to select from
SYSCAT.TABLES, for example, without firing an error like

Warning: SQL error: [IBM][CLI Driver][DB2/LINUX] SQL0151N The column
"MAXFREESPACESEARCH" cannot be updated. SQLSTATE=42808 , SQL state 42808 in
SQLExecDirect

For example :

$query = odbc_exec($conn, "select * from syscat.tables for read only");
odbc_result_all($query);

will work (only for db2).  I don't know about other databases.

The select statement will work in the 'db2' command line, but not in php,
because of this side effect.
===============================================================================

I tried the following line of code

<?php
$odbc=odbc_connect("pbk", "root","") or die(odbc_errormsg());
$q="insert into pbk values(\"$name\", \"$phone\")";
print $q;
odbc_exec($odbc, $q) or die("<p>".odbc_errormsg());
?>

it does not work. However if I use single quotes instead of \" the thing runs
smoothly

thus the following would work

<?php
$odbc=odbc_connect("pbk", "yourworstnightmare","abracadabra") or die(
odbc_errormsg());
$q="insert into pbk values('$name', '$phone')";
print $q;
odbc_exec($odbc, $q) or die("<p>".odbc_errormsg());
?>

Also having a user dsn is no good on win2k. Always have a System DSN. I don't
know yet what are the implications of the same.
===============================================================================

If Openlink -> MS Access Database fails and gives "Driver Not Capable" error or
"No tuples available" warning, use the SQL_CUR_USE_ODBC cursor when using
odbc_connect()...

Siggy
===============================================================================

for Win32(NT) and MSAcess 2000, whenever you retrieve a date column/field, php
will automatically convert it to 'yyyy/mm/dd hh:mm:ss' format regardless of the
style of date you've denoted in Access.
This seems to pose a problem when you exec SELECT, UPDATE, or DELETE queries,
but strangley INSERT works fine. I've tried parsing the date into the desired
format, but php still yells criteria mismatch.
===============================================================================

In a previous contribution it was told that if you're running NT/IIS with PHP
3.0.11 you can use MS Access dbs "stored procedures".

That was right, but if those stores procedures have parameters you have to
supply them in the command line like this:

$conn_id = odbc_connect( "odbc_test_db", "","", SQL_CUR_USE_DRIVER );
$qry_id = odbc_do( $conn_id, "{CALL MyQuery(".$param.")}" );
===============================================================================

"[Microsoft][ODBC Microsoft Access Driver] Too few
parameters. Expected 1."

this not so clear to understand error comes when using access-odbc and a field
name can't be found. check for correct spelling of fields.
===============================================================================

I wanted to access an MSAccess database via ODBC. The connection functioned
without problems, but when I placed a SQL statement into my odbc_exec() i
always got an error:
Warning: SQL error: [Microsoft][ODBC Driver Manager] Driver does not support
that function, SQL state IM001 in SQLSetStmtOption in \\Server\directory/
test.php3 on line 19.

Resolved my problem by myself: i simply had to install a new odbc-driver from
the microsoft homepage.
